\input texinfo.tex   @c -*-texinfo-*-
@setfilename pmml
@settitle PMML User's Manual (draft english translation))
@documentencoding UTF-8

@finalout

@ifinfo
PMML User's Manual
Copyright 1997,1998 (C)  Satoshi Nishimura
@end ifinfo

@c To convert to HTML
@c   texi2any --html --split=chapter pmml.texi
@c The Run.
@c the tag in the Simple Examples are when the die 2,5,6,7,8,10 Chapter of chapter number has changed
@c Entered and is chapter number also needs to be changed.
@c for translators.
@c to find areas of the manual that need help with translation, look for a comment tag with
@c helpme: at the start.
@c some areas are translated, but with imho, poor grammar. help appreciated to translate these better as well.

@ifinfo
@clear html
@end ifinfo

@titlepage
@title PMML User's manual

@ifclear html
@subtitle For the PMML interpreter Release 0.2
@author Satoshi Nishimura

@page 
@vskip 0pt plus 1filll
Copyright 1997,1998 (C) by Satoshi Nishimura
@sp 2
The author assumes no responsibility for any losses incurred by this manual.
@sp 2
Specification of PMML and its compiler are subject to change without notice.
@end ifclear
@ifset html
@author For the PMML interpreter Release 0.2
@author Last change: @today{}
@author Copyright 1997,1998 (C)  Satoshi Nishimura
@author The author assumes no responsibility for any losses incurred by the use of this manual.
@author The specification of PMML and its compiler are subject to change without notice.
@author please note. this is a draft translation of the manual, with chapter 14, inter-threaded communication not translated.
@author also, you will see japanese paragraphs here and there throughout the texxt.
@author however, the bulk of the manual is translated, enough for a new user to learn most of PMML.
@end ifset
@end titlepage

@node Top, Overview, (dir), (dir)

@ifinfo
@top PMML

The PMML (Practical Music Macro Language) is a music description language for the purpose of automatic performance of MIDI instruments by computer.
Source files of PMML are converted to a standard MIDI file by the PMML compiler. This manual serves as both a specification of the compiler, and it's input language.

Please send us Feedback, bug reports, etc. on PMML to @samp{nisim@@u-aizu.ac.jp}.

The author assumes no responsibility for any losses incurred by this manual

The specification of PMML and its compiler are subject to change without notice.
@end ifinfo

@menu
* Overview::                    Overview of the PMML
* Basic Concepts::              Explanation of basic terms necessary to understand the manual
* Simple Examples::             Short examples of PMML source files
* Compiler::                    Invoking the compiler, command line options
* Lexical Rules::               Lexical rules (comments, notation of constants, etc.)
* Data Types and Expressions::  Data types, expressions and operators
* Basic Commands::              Description of the basic musical elements (notes, rests, chords, etc.)
* Event Generating Commands::   Control Change, Program Change,
                                Pitch bend, aftertouch, Exclusive Messages,
     meta-events
* Macros::                      Macro definition and calling
* Control Structures::          Loops and conditionals
* Arrays::                      Working with arrays
* Built-in Functions::          Built-in functions
* Effectors::                   Using the effector
* Communication::               Inter-thread communication and synchronization
* Reading MIDI files::          How to Load a standard MIDI file
* Concept Index::               concept index
* Command and Macro Index::     Command and macro index

 --- The Detailed Node Listing ---

Basic concepts

* MIDI Channels::               The MIDI Channel
* Events::                      Events
* Tracks::                      Tracks
* Commands::                    Commands, macro commands, and built-in functions
* Glyphs::                      Explanation of symbols used in the manual

Examples of simple source code

* Single Part Example::         Single part example
* Multi Part Example::          Multi-part example

Basic commands used above

* Rational Constants::          Description of rational constants such as Q, I
* Pitch Constants::             Description of the pitch constant such as ^D, G
* Note Command::                Description of note commands
* Comments::                    Using // to denote comments
* Changing Registers::          Description of the octave commands such as ^ _ 

Event Generation Commands used above

* Meta Events::                  Description of tempo, timesig
* Threads::                     Description of Threads
* Creating Named Threads::       Description of thread creation with commands such as newtrack
* Register Sets::               Description of registers, such as ch, o, v
* Changing Registers::          How to change registers with commands such as ch=1
* Control-Change Events::       Controller generation commands, such as prog, vol
* Switching Threads::           How to switch between threads
* Loops::                       Description of the repeat command
* For Command::                 About the for command
* Grouping::                    Description of @{ ... @}
* Note Duration::               Changing note duration, such as dr=30
* If Command::                  About the if command
* Operators::                   Description of operators such as ==
* Continuous Control Change::   Description of continuous control change such as vol_to
* Chords::                      Description of the chord command [ ... ]

Invoking the Compiler

* Synopsis::                    Invoking the PMML compiler
* Options::                     Description of the command line options
* Start-up::                    The process of compiler startup
* Output Process::              at the end of compiler processing
* Output File::                 Settings effecting the output file
* Environment::                 Environment variables
* One Liner::                   Examples of one-liner commands
* Limitations::                 Limitations of the compiler

Output processing

* Priority::                    Event priority
* Note Collision::              Processing of note collisions

Settings of the output file

* Output File Name::            File name of the output file
* Output Format::               The format of the output file
* Output Resolution::           Resolution of the output file

Lexical rules

* Space Characters::            Meaning of space characters
* Comments::                    Writing Comments
* Integers::                    Integer constants
* Floating-Point Constants::    Floating-point constants
* Pitch Constants::             Pitch constants
* Rational Constants::          Rational constants
* Strings::                     String constants
* Identifiers::                 The rules for naming identifiers
* Accents::                     Accent marks
* Time Shifters::               Time shift symbols
* Tokens::                      List of all types of tokens

Data types and expressions

* Data Types::                  PMML has 6 data types
* Expressions::                 Expressions in PMML
* Token-list Constants::        Token list constants
* Array Constants::             Array Constants
* Logical Values::              Logical values
* Operators::                   Description of all the operators and their meanings
* Type Conversion::             The rules for implicit type conversion

Basic commands

* Registers::                   The role of registers and how to change them
* Note Command::                Note commands
* Note Length::                 How to specify the note length
* Note Duration::               How to specify the note duration
* Key::                         For tone and accidentals
* Threads::                     Concept and generation, the method of switching threads
                                How to Write chords and multiple parts
* Modifiers::                   Description of the modifier to temporarily change the notes attributes
* No Operation::                Command that does nothing

Registers

* Register Sets::               List of all registers
* Pseudo Registers::            List of pseudo-registers
* Changing Registers::          How to change the value of a register

Threads and their associated commands

* Grouping::                    Generation of unnamed thread and temporary registers
* Creating Named Threads::      How to generate a named thread
* Switching Threads::           How to switch between threads
* Wait for Child Threads::      Time alignment between threads
* Deleting Named Threads::      Deleting named threads

Event generation commands

* Note Events::                 Single generation of note-on, note-off
* Virtual Control Change::      Virtual control change
* Velocity Magnifier::          For velocity magnification
* Control-Change Events::       Control Change, Program Change,
                                Pitch bend, aftertouch, tempo changes, etc.
* Continuous Control Change::   Generating Continuous control changes
* Exclusive Events::            Exclusive and any message
* Meta Events::                 meta event Generation. Time signature settings, tone settings,
                                Insertion of markers, including the insertion of tune title.

Macros

* Types of Macros::             Macro classification, difference between function and variable macros
* Calling Macros::              How to call macros
* Defining Variable Macros::    How to define the variable type macro
* Defining Function Macros::    How to define a function-like macro
* Macro Examples::              A function-like macro example
* Local Macros::                Using the local macro
* Scope Rules::                 Rules for the scope of a macro
* Scope Specifiers::            How to explicitly specify the scope of an identifier
* Macro Directive::             The places where you can run macro directives
* Eval Macro Directive::        Force evaluation of the expression
* Evalstr Macro Directive::     Evaluation of a string as source text
* Undefining Macros::           How to cancel a macro definition
* Examine Empty Token Lists::   Determining if a token string is empty
* File Inclusion::              Reading of other source files

Definition of a function-like macro

* Argument Substitution::       Using argument values
* Argument Spec::               Writing of argument specification string

Control structures

* Conditionals::                Commands for conditional branching
* Loops::                       Commands for iteration

Commands for conditional branching

* If Command::                  Branching based on a condition
* Switch Command::              Multiple branches

Commands for iteration

* Repeat Command::              repeat a specified number of times
* While Command::               Repeating while  conditions are met
* For Command::                 Repeating commands while changing the value of a counter
* Foreach Command::             Repeating commands for each element of an array
* Break Command::               Exiting from the loop

Array Operations

* Array Subscripting::          Accessing and writing to elements of an array
* Array Size::                  How to obtain the size of the array
* Array Expansion::             How to deploy an array to the argument list
* Duplicating Arrays::          How to replicate the array
* Element Replication::         How to initialize an array with the same elements
* Resizing Arrays::             Adding or removing elements from existing array

Built-in functions

* Message Output Functions::    Output of messages. print, printf, etc..
* Math Functions::              Arithmetic functions. abs, sin, etc..
* Random Number Generators::    Functions that generate random numbers
* Numerical Type Conversion::   Function to perform the type conversion between numbers
* String Functions::            Functions to perform string processing
* Get Identifier Information::  Functions to determine the type and definition status of identifiers
* Expression Type::             Type functions to determine the type of the expression
* Token Extraction::            nth_token function for obtaining the n-th token
* Error Handling::              Functions for error handling
* Debugging::                   Support functions for debugging

Effectors

* Overview of Effectors::       Effector Overview. Glossary of terms
* Event Types::                 Event types and their event codes
* Defining Effectors::          How to define an effector
* Event Actions::               Description method of action for the event
* Attaching Effectors::         How to attach the effector to threads
* Changing Valid Flags::        Operation of the effector valid flag
* Changing Through Bits::       Operation of the through bit
* Undefining Effectors::        Removal of an effector definition
* Effector Examples::           Examples of some of the effectors
* Predefined Effectors::        Predefined effector (effector library)
* Virtual Controllers and Effectors::  How to define the meaning of a virtual controller

Effector Overview

* Effector Class::              Effector definitions and effector class
* Effector Instance::           Attach and effector instance of effector
* Effector Chain::              Attaching multiple effectors
* Inheritance of Attachment::   Propogation of the effector list to a child thread
* Through Bits::                through bits
* Effector Valid Flags::        The effector valid flag

Inter-thread communication

* Overview of ITC::             Overview of inter-thread communication.
Messages, communication channels, and signals
* Sending Messages::            Signal command to send a message
* Receiving Messages::          Wait command to receive a message
* Alternation::                 Monitoring of multiple communication channels and waiting for messages
* Destroying Channels::         Disruption of communication among channels

Reading of standard MIDI files

* Load Command::                Reading of the entire MIDI file
* Loadtrk Command::             Reading of only one track
* Closing MIDI Files::          Close the MIDI file
* Get MIDI File Info::          How to get MIDI file info such as the number of tracks
@end menu

@c --------------------------------------------------------------------
@node Overview, Basic Concepts, Top, Top
@chapter Overview of the PMML
@cindex Overview of the PMML

The PMML (Practical Music Macro Language) is a music description language for the purpose of automatic performance of MIDI instruments by computer.
Music can be specified either directly in standard notation, using pitch and rhythm, or algorithmically using the programming features of the language. 
Furthermore, for music that is written in one of these ways, For example, it is possible to perform further processing of the events units such as quantization.
In PMML You can describe such event processing procedures in the text.

PMML source files can be converted to standard midi files by the compiler. These can be played with any standard midi file player or midi sequencer.
The PMML compiler can generate format 0, 1 or 2 midi files. The pmml compiler is fast, having been designed to be run several times in a session to correct and play the music as it's developed.

The main features of PMML are as follows.
@enumerate
@item
PMML's musical description is similar to that of MML (Music Macro Language).
In comparison with MML, it is easy to finely adjust the velocity and timing of notes, Chord description is simple, it is possible to group notes into threads, etc.
Please note, there is no direct compatibility with MML.

@item
All types of events supported by midi files, including system exclusive messages are supported and can be described.

@item
Continuous controler change curves can be generated, both straight lines and free form curves.

@item
PMML includes a powerful macro function. Macros can take arguments, and can be local or global.
Local macros are only valid during the lifetime of another macro.
Macros are useful to describe the common phrase and accompaniment patterns.

@item
Control syntax similar to the C language. (@code{if}, @code{while}, @code{for}, etc.

@item
There are operators similar to the C language, including integer, rational operations, Floating-point arithmetic and string operations.
In addition, variable-length arrays are also supported.

@item 
Provides a module for performing event processing called the effector. An effector, for instance, could automatically add notes 1 octave above each note in a track while it is active.

@item 
You can load a standard MIDI file by the @code{load} command.
You can also apply effectors relative to the loaded song.
You can use this feature to turn the PMML compiler into a standard MIDI file processing tool (For example, conversion from format 1 to 0, changing resolution, channel reassignment)
@end enumerate

@c --------------------------------------------------------------------
@node Basic Concepts, Simple Examples, Overview, Top
@chapter Basic concepts

@menu
* MIDI Channels::               The MIDI channel
* Events::                      Events
* Tracks::                      Tracks
* Commands::                    Commands, macro commands, and built-in functions
* Glyphs::                      Explanation of symbols used in the manual
@end menu

@node MIDI Channels, Events, Basic Concepts, Basic Concepts
@section The MIDI channel
@cindex The MIDI channel
@cindex channel

The MIDI channel allows a midi synthesiser to play more than one sound at once over the midi connection. Such a sound source that can play more than one sound at once is a multi-timbral sound generator.
To distinguish one sound from another, a synthesizer can respond to any one of up to 16 midi channels, numbered from 1 to 16.

Each channel has independent settings for such things as volume, pan, pitch bend, 
and program change, therefore, any track in a midi file sharing a channel 
will share all of these settings. If you want to use the same sound on multiple 
tracks, but with different settings for any of the above, then you will need 
to set them to different channels.

By default, PMML is set to place events on channel 1, but this can, and will
need to be changed if you want to use multiple channels in a piece
(@pxref{Registers}).

It should be noted that PMML has a concept of the communication channel which is different to the MIDI channel
(@pxref{Communication}). Nevertheless,
when discussing midi channels, the word channel will simply be used to avoid confusion.

@node Events, Tracks, MIDI Channels, Basic Concepts
@section Events
@cindex Events
@cindex Meta-events

Aspects of an automatic performance are represented as a sequence of events.
Each event occurs at a specific time, and 
consists of information about what is being done, IE MIDI note generated, or information past to a synthesizer.

PMML has support for both events as defined in standard midi files, and
extentions that are used internally by PMML. 
The following events are supported.
@itemize @bullet
@item
MIDI events
@itemize @minus
@item
Note-on
@item
Note-off
@item
Key pressure (key aftertouch)
@item
Control Change
@item
Program Change
@item
Channel pressure (channel aftertouch)
@item
Pitchbend
@end itemize

@item 
System exclusive events
@itemize @minus
@item
Exclusive
@item
Any message (arbitrary midi bytes)
@end itemize

@item 
Meta-events
@itemize @minus
@item
Sequence number
@item 
Text events
@item
End of track
@item
Tempo
@item
SMPTE offset
@item
Time signature events
@item
Key signature events
@item
Other meta-events
@end itemize
@end itemize

PMML's own events are as follows.
@itemize @bullet
@item
Virtual Control Change (@pxref{Virtual Control Change}) @*
This event is used to pass data to an effector.

@item
Continuous Control Change (@pxref{Continuous Control Change}) @*
This event is a series of control changes along a line or curve.
When you run, events will be generated for each node of a line or curve.
@end itemize

@node Tracks, Commands, Events, Basic Concepts
@section Tracks
@cindex tracks

Tracks are a way to organise events. In PMML You can use multiple tracks.
As long as you do not specify a special format called format 2 as the output file type,
All the tracks are played in parallel. In other words, events with the same time
No matter  which  track they are in, will play together.

Typically, the events in a piece are stored in several tracks. This gives 2
advantages. One is that tracks can be muted or unmuted during playback.
While the PMML compiler lets you include or omit tracks during compilation, 
midi file players can mute tracks on-the-fly. Another advantage is if the computer
has multiple midi interfaces, each track can be directed to a different interface,
if supported by your midi player/sequencer. One interface can only handle up to 16
channels at once, therefore only 16 different instruments can play.
Such problems can be solved by using multiple interfaces.

By default, the PMML compiler generates format 1 midi files.
When format 1 is selected, events are directed to tracks
as indicated in the PMML source file.
However, if you choose format 0 as the output format, all of the tracks in the output 
will be merged into one. Therefore, performance features such as muting,
or using multiple interfaces will be unavailable.
However, when you create a standard MIDI file with the PMML compiler, there are 
still advantages to dividing your score into tracks in the input source.

Tracks are numbered with numbers starting from 1.
Track 1 (the first track) is called the conductor track.
Tempo, time signature settings, SMPTE offset, and sequence number events
Must be stored in this track. In adition, text events such as song title and copyright
can be stored there as well.
As a rule, note-on and note-off events are not placed here.

When deciding how to lay out your midi tracks and channels, you can organise
them any way you like. Typical schemes include each track with it's own channel,
or multiple tracks with the same channel, as in left and right hands for a piano.
However, nothing is stopping you from switching channels mid-track, or any other
organisation you like.

@node Commands, Glyphs, Tracks, Basic Concepts
@section Commands
@cindex Commands
@cindex Normal command
@cindex macro directive
@cindex built-in function
@cindex standard macro

The source text of PMML is made up of a sequence of commands.
Commands can, for example, generate notes or define macros, or perform a 
variety of tasks.

Commands are classified into 3 categories. @dfn{Normal commands}, @dfn{Macro instructions} and @dfn{Built-in functions}

Normal commands perform actions such as note generation, setting duration, or setting a register.
They are indicated in this manual with @samp{C:}.
Macro directives, in contrast, can be used within functions, and are used as
part of macros. (@pxref{Macro Directive})
They are indicated in the manual by @samp{MD:}.
Built-in functions include commands such as arithmetic functions and message output.
Like the macro directive, they can be used in the middle of expressions. The difference from macro directives
are that the user can re-define the meaning. (@pxref{Built-in Functions})
Built-in functions are indicated in the text with @samp{BI:}.

Similar to normal commands, above, there are @dfn{Standard macros}.
These are macros read at compiler startup, from a startup file. (@pxref{Start-up})
In the manual, these are indicated by @samp{SM:} 

@node Glyphs,  , Commands, Basic Concepts
@section Symbols in the manual
@cindex @expansion{}
@cindex @print{}
@cindex C: 
@cindex MD: 
@cindex BI: 
@cindex SM: 
@cindex BE: 
@cindex SE: 

@table @asis
@item @code{t}, @code{tb}, @code{dt}, @code{n}, etc.
These represent the value of the registers. Examples of how these would be used in sources are as follows.
@quotation
Event time (@code{t} + @code{dt}), Track number @code{tk},
MIDI Channel number @code{ch}
@end quotation

@item @expansion{}
Represents the macro expansion result.

@item @print{}
Represents the messages output by @code{print} and @code{printf}

@item C: 
Represents a normal command. (@pxref{Commands})

@item MD: 
Represents a macro directive. (@pxref{Commands})

@item BI: 
Represents a built-in function. (@pxref{Commands})

@item SM: 
Represents a Command/macro defined in startup files. (@pxref{Commands})

@item BE: 
Represents a built-in effector. (@pxref{Predefined Effectors})

@item SE: 
Represents an effector defined in startup files. (@pxref{Predefined Effectors})
@end table

@c --------------------------------------------------------------------
@node Simple Examples, Compiler, Basic Concepts, Top
@chapter Examples of  simple source code

@menu
* Single Part Example::         single-part example
* Multi Part Example::          Multi-part example
@end menu

@node Single Part Example, Multi Part Example, Simple Examples, Simple Examples
@section Single-part example

The folowing is the beginning part of Bach's Minuet
Only the right-hand part of the music is described in the PMML below.

@ifnothtml
@example
q ^D i G A B ^C     // q, i specifies note duration, ^D, G specify notes
q ^D G G      
^ q E i C D E F#    // ^ _ are octave up and down.
q G _ G G           // Effects following notes in the current thread
^C i ^D ^C B A      
q B i ^C B A G 
q F# i G A B G  
h. A                // h. A dotted half
@end example
@end ifnothtml
@ifhtml
@html
<PRE>
<A HREF="Note-Length.html">q</A> <A HREF="Pitch-Constants.html">^D</A> i G A B ^C  q ^D G G      <A HREF="Comments.html">//</A> q, i specifies note duration, ^D, G specify notes
<A HREF="Changing-Registers.html">^</A> q E i C D E F<A HREF="Pitch-Constants.html">#</A>  q G <A HREF="Changing-Registers.html">_</A> G G    // ^ _ are octave up and down.
                               // Effects following notes in the current thread
^C i ^D ^C B A  q B i ^C B A G 
q F# i G A B G  <A HREF="Rational-Constants.html">h.</A> A           // h. A dotted half note.
</PRE>
@end html
@end ifhtml

If you compile the above with the PMML compiler, a midi file containing the
minnuette on channel 1 will be generated.

@ifinfo
@subsubheading Tokens used in the source above

@menu
* Rational Constants::          Description of rational constants such as q, i
* Pitch Constants::             Description of pitch constants such as ^D, G
* Note Command::                Description of note commands
* Comments::                    Using // to comment sources
* Changing Registers::          Chaging octaves with ^ _
@end menu
@end ifinfo

@iftex
@page
@end iftex
@node Multi Part Example,  , Single Part Example, Simple Examples
@section Multi-part example

The following adds a left-hand part to the previous example, and also adds
a little musical expression to the piece.

@ifnothtml
@example
tempo(160)                        // Tempo setting in bpm
timesig(3,4)                      // Time signature

newtrack(righthand) @{             // Thread generation for the right-hand part
  ch=1 o=4 v=90 prog(69) vol(80)  // Initialization of the right-hand part
  /* Set midi channel to 1, octave to 4, velocity of notes to 90, */
  /* Set the midi program to 69 (oboe) and channel volume to 80. */
@}
newtrack(lefthand) @{              // Thread generation for the left-hand part
  ch=2 o=3 v=80 prog(1) vol(80)   // Initialization of the left-hand part
@}

righthand @{                       // music for the right-hand part
  for($i,1,2) @{                   // repeat this twice
    q ^D i G A B ^C  q ^D @{dr=30 G G@}
    ^ q E i C D E F#  q G++ _ @{dr=30 G G@}
    ^C i ^D ^C B A  q B i ^C B A G
    if( $i == 1 ) @{               // upon the first repeat
      q F# i G A B G  h. A
    @} else @{                      // upon the second repeat
      vol(80)
      q A i B A G F#  h. G
      vol_to(30)                  // Decrescendo
    @}   
  @}
@}

lefthand @{                        // Description of the left hand part
  h. [@{h G q A@} B ^D] B           // Representation of a chord
  ^C B 
  A G 
  q ^D B G  ^D i D ^C B A
  h B q A  q G B G 
  h. ^C  q B i ^C B A G
  h A q F#  h G q B
  q ^C ^D D  h G q _G
@}
@end example
@end ifnothtml
@ifhtml
@html
<PRE>
<A HREF="Control_002dChange-Events.html">tempo(160)</A>                        // Tempo setting in bpm
<A HREF="Control_002dChange-Events.html">timesig(3,4)</A>                      // Time signature

<A HREF="Creating-Named-Threads.html">newtrack</A>(righthand) {             // Generation of the righthand <A HREF="Threads.html">Thread</A>
  <A HREF="Register-Sets.html">ch</A> <A HREF="Changing-Registers.html">=</A>1 <A HREF="Register-Sets.html">o</A>=4 <A HREF="Register-Sets.html">v</A>=90 <A HREF="Control_002dChange-Events.html">prog</A>(69) <A HREF="Control_002dChange-Events.html">vol</A>(80)  // Initialization of the right-hand part
  /* Set <A HREF="MIDI-Channels.html">MIDI channel </A>to 1, octave to 4, velocity to 90*/
/* Set the midi program to 69 (oboe) and channel volume to 80. */
}
}
newtrack(lefthand) {              // Thread generation for the left-hand part
  ch=2 o=3 v=80 prog(1) vol(80)   // Initialization of the left-hand part
}

<A HREF="Switching-Threads.html">righthand</A> {                       // Description of the right-hand part
  <A HREF="For-Command.html">for</A>($i,1,2) {                   // 2<A HREF="Repeat-Command.html">Repeats</A>
    q ^D i G A B ^C  q ^D <A HREF="Grouping.html">{</A> <A HREF="Duration.html">dr=30</A> G G}
    ^ q E i C D E F#  q G<A HREF="Accents.html">++</A> _ {dr=30 G G}
    ^C i ^D ^C B A  q B i ^C B A G
    <A HREF="If.html">if</A>( $i <A HREF="Operators.html">==</A> 1 ) {               // Upon first repeat
      q F# i G A B G  h. A
    } else {                      // Upon second repeat
      vol(80)
      q A i B A G F#  h. G
      <A HREF="Continuous-Control-Change.html">vol_to</A>(30)                  // Decrescendo
    }   
  }
}

lefthand {                        // Description of the left hand part
  h. <A HREF="Chords.html">[</A> <A HREF="Chords.html">{</A>h G q A} B ^D] B           // Representation of a chord
  ^C B 
  A G 
  q ^D B G  ^D i D ^C B A
  h B q A  q G B G 
  h. ^C  q B i ^C B A G
  h A q F#  h G q B
  q ^C ^D D  h G q _G
}
</PRE>
@end html
@end ifhtml

@ifinfo
@subsubheading Tokens used in the source above

@menu
* Meta Events::                 Description of meta events such as tempo, timesig 
* Threads::                     Threads
* Creating Named Threads::      Description of thread creation, such as with newtrack
* Register Sets::               Description of register such as ch, o, v
* Changing Registers::          How to change registers, such as ch=1 
* Control-Change Events::       Description of the control change commands, such as prog, vol 
* Switching Threads::           How to switch between threads
* Loops::                       Description of repetition of commands
* For Command::                 for command
* Grouping::                    Description of @{ ... @}
* Note Duration::               Description of setting note duration, such as dr=30
* If Command::                  if command
* Operators::                   Description of operators such as ==
* Continuous Control Change::   Description of continuous control change, such as vol_to
* Chords::                      Description of [ ... ] to create chords
@end menu
@end ifinfo

@c --------------------------------------------------------------------
@node Compiler, Lexical Rules, Simple Examples, Top
@chapter Invoking the Compiler

The PMML compiler converts source files in the PMML language to standard 
midi files. These can be played in any midi file player/sequencer, to hear the 
music generated by the PMML description.
The compiler is able to generate format 0, 1, or 2 midi files.

@menu
* Synopsis::                    How to Start the PMML compiler
* Options::                     Description of the command line options
* Start-up::                    The process of compiler startup
* Output Process::              How the compiler generates output
* Output File::                 Settings effecting the output file
* Environment::                 Environment variables
* One Liner::                   Examples of one-liner commands
* Limitations::                 Limitations of the compiler
@end menu

@node Synopsis, Options, Compiler, Compiler
@section Command format
@cindex PMML, Starting
@cindex Invoking the Compiler
@cindex Standard input
@cindex Termination status

To start the PMML compiler from the command line, enter as follows.

@example
pmml @r{[}@var{options}@r{]} @r{[}@var{srcfile}@r{]}
@end example

@var{srcfile} Is the name of the PMML source file.
Extension of the file name @samp{.pml} can be omitted.
In this case, just give @var{srcfile} 
if @samp{-} is given, the text will be read from Standard input.

The filename of the output midi, unless otherwise specified
is the source filename with the extention changed to @samp{.mid}. (@pxref{Output File Name})
When source text is given that generates no midi events, no midi file is 
generated, and a warning is issued.

PMML returns an exit status to the OS upon completion.
0 upon success, 1 if an error was encountered,
2 when only help is output, otherwise 3.

@node Options, Start-up, Synopsis, Compiler
@section Command-line options
@cindex Options
@cindex Command-line options

Options available when you start the compiler  are as follows.
Options and their arguments can be given with or without spaces.
For options that do not take arguments, you can put 2 or more of these 
together, as in @samp{-np}.

@table @code
@item -0
@itemx -1
@itemx -2
Specify the format of the output MIDI file.
@samp{-0} format 0 - A single sequence with one track with all data,
@samp{-1} format 1 - A single sequence with multiple tracks
and @samp{-2} format 2 - multiple sequences, one per track.
When @samp{-0} is specified, all tracks are merged into 1.
If none of these options are specified, (@pxref{Output Format})

@item -c @var{channel}@r{[}-@var{channel}@r{]},@dots{}
Output the events for only the specified MIDI channels.
If you specify, for example, @samp{-c 1-3,6},
Only channels 1, 2, 3, and 6 will be output.
If you specify a negative number as part of @var{channel}, all channels except
those given will be output. If both positive and negative channel specifications are given,
These are combined to give the final channel output specification.
Regardless of any of these settings, exclusive and meta events are always 
output.

@item -d
Remove empty tracks from the output midi file. This includes tracks that 
generated no events from the PMML description, and tracks that, as a result ofchannel specifications, are empty.
This also includes out-of-range tracks as specified with the @samp{-T} option.

@item -e @var{PMML-srctext}
@var{PMML-srctext} is considered to be the contents of the source file and 
the commands within will be run. @var{srcfile} does not need to be specified 
if this option is present.

@item -f @var{songpos}
@var{sonpos} specifies at which position to begin midi generation and playback.
If a position in the middle of the song is specified, the initialization
events included up to this point are generated, so that playback will be the
same as if the entire song was generated.

@var{songpos} can be given in 4 formats.

@table @asis
@item (1) @code{@var{measure}@r{[}:@var{ticks}@r{]}}
The Measure number @var{measure} is the beginning (or the the end) of the
measure in the case of the @samp{-t} option to start generation.
The Measure number starts from 1, if in the middle of the bar there is a time signature setting event,
the new measure will be regarded to have started from there.
If @var{ticks} is specified, time is advanced or subtracted from the given
measure. @var{ticks} can be negative to advance backwards from the beginning of the measure.

@item (2) @code{/@var{marker}@r{[}/@r{]}}
@var{marker} sets position to the marker event (meta event #6) who's name is given.
These events are typically found on track 1.
You should surround the @var{marker} with either the @samp{/} or @samp{:} delimiters.
However, often you can leave off the ending delimiter.

@item (3) @code{/@var{marker}/+@var{measure}@r{[}:@var{ticks}@r{]}}
@var{marker} Specifies a marker as the bass position to start from.
@var{measure} is the number of measures to be added to this marker position.
Finally, @var{ticks} adds a final number of ticks to this position.
@var{marker} can be enclosed by @samp{/} and @samp{:} but it is optional.

@item (4) @code{/@var{marker}/-@var{measure}@r{[}:@var{ticks}@r{]}}
@var{marker} specifies a bass marker position,
@var{measure} is subtracted from this bass position to set the start point.
All other items are the same as (3).
@end table

If @var{measure} is 0 or negative, a blank measure is added to the song.

If the output file is format 2, this option will not work correctly.

@item -h
Outputs a help message and exits.

@item -i @var{startup-file}
The file that is read at compiler startup is changed to that specified by
@var{startup-file}. (@pxref{Start-up})
If @var{startup-file} has the extention @samp{.pml} it can be omitted.
The file is searched for along the file search path, (@pxref{Environment})

@item -l @var{SMF}
This option is equivalent to the @code{load} command.
@var{SMF} Specifies a standard midi file that is read into the events buffer.
Another way to execute this would be @samp{-e load("@var{SMF}")}
If the extention of @var{SMF} is @samp{.mid} it can be omitted.
If this option is used, @var{srcfile} is not needed.

@item -n
Does not modify events to avoid note collision (@pxref{Note Collision}).

@item -o @var{SMF}
Specify the file name of the standard MIDI file to be output.
If you omit the extension @samp{.mid} it will be added.
If you specify @var{SMF} as @samp{-} standard output will be used.

@item -p
Does not sort events by priority (@pxref{Priority}).

@item -q
When this option is specified, the startup file is not read.

@item -r @var{resolution}
@var{resolution} sets the number of ticks per quarter note in the output MIDI file.
(@pxref{Output Resolution}).

@item -t @var{songpos}
@var{songpos} specifies the point at which to stop playback.
If @var{songpos} is in the middle of a note, a note-off is added.

Please refer to the @samp{-f} option for information on the format of @var{songpos}.

If the output file is format 2, this option will not work correctly.

@item -w
Suppresses all warnings that are output.

@item -F @var{header-file}
@var{header-file} specifies a pmml source file that is treated as an additional 
include file for @var{srcfile}
This option is equivalent to @samp{-e include("@var{header-file}")}.
You can also use this in conjunction with @var{srcfile} if you want to process
more than 1 source file at once, or to run a command in @var{header-file} along
with source text in an @samp{-e} option and a midi processed by the @samp{-l} option.
If the extention of @var{PMML-file} is @samp{.pml} You can omit it.
The file search path is looked for in environment variables (@pxref{Environment}).
@var{srcfile} does not have to be present if this option is used.

@item -I @var{directory}
Add's @var{directory} to the beginning of the file search path (@pxref{Environment}).
Files are searched in the specified directory, then the path found in the environment,
and finally @code{PMMLPATH} set during installation.

@item -R
When outputting the MIDI file, do not apply the running status rules.
It is used when you want to generate a MIDI file
For sequencers/ players that do not support this feature.
If you specify this option, some MIDI files will be longer,
but There is no impact to the performance itself.

@item -T @var{track}@r{[}-@var{track}@r{]},@dots{}
Output only the specified tracks.
For example, @samp{-T 1-3,6} Only tracks 1, 2, 3, and 6 will be output.
If @var{track} contains a negative track number, all tracks except this one
will be output. If both positive and negative track numbers are given,
the positive tracks will be included, the negative ones won't.

You can also specify tracks by name, instead of by number.
in this case, @var{track} should have track names enclosed by @samp{/} and @samp{:}.
Track names are matched by looking for midi trackname events (meta event #3).

Even if the output MIDI file is format 0, individual tracks can be selected with the @samp{-T} option,
based on internal values of the @code{tk} register.

If the format of the output MIDI file is 0 or 1, track 1, the conductor track is included,
even if @var{track} doesn't explicitly specify 1.
therefore, if you specify @samp{-T 3} you will include tracks 1 and 3.
If you really don't want to include track 1 in the output,
Specify @samp{-1}.
For example, @samp{-T -1,3} will only include track 3.

If the tracks specified are outside the range of the source,
they will appear as empy tracks, unless the @samp{-d} option is specified.
@end table

@node Start-up, Output Process, Options, Compiler
@section start-up
@cindex Startup
@cindex Startup file
@cindex pmml.pml
@cindex %@{

When the compiler is invoked, Source text will be loaded first, in the following order.

@enumerate
@item 
A special string found in between @samp{%@{} and @samp{@}} as the first text
in the file is used to set global format parameters for the output before any further processing.
The format of the output file, (@pxref{Output Format}),
and the midi resolution (@pxref{Output Resolution})

@item 
The Startup file is loaded.
The name of the startup file can be changed with the @samp{-i} option.
If you have changed the name of the default file (@file{pmml.pml},
The compiler will not start properly. You can use the @samp{-q} option to not load the startup file.

@item
Any or all of the @samp{-e}, @samp{-l} or @samp{-F} options, which can appear in
any order, and more than once. Order of execution is in the order specified.
@end enumerate

Following these, the execution of the rest of the source file is started.

@node Output Process, Output File, Start-up, Compiler
@section Output processing

When PMML finishes command execution, all generated events are placed in 
an event buffer in memory and is stored separately for each track.
The compiler then performs a series of processing (subsequently referred to as output processing)
for the events in the buffer.
Once processed, the events are written to the output file.

The following are  the contents of the output process.

@enumerate
@item
If the @samp{-T} option is specified, follow it's specification and
remove any unwanted tracks.

@item 
For each track, sort by priority as described below and the times of the events.

@item
If the @samp{-f} and @samp{-t} options are present, any events with a time outside
the range indicated will be removed.
In addition, @code{end} commands (@pxref{Meta Events}) are added to the generated events,
even if later events would have added these, if they had been included.

@item
Continuous control change events are expanded into a series of regular control change events.

@item
Perform note collision processing as described below.

@item
If the output file is format 0, all the tracks will be merged into one.

@item
If tempo and time signature events are missing at time 0, they are added.
Tempo is set to 120 bpm, time signature is 4/4.

@item
Velocity magnification (@pxref{Velocity Magnifier}) is processed.

@item
All event times will be converted from rational numbers to ticks, with fractions truncated.
All values for control changes will be converted to integers by rounding.
@end enumerate

Of the above processes, 3, 4 and 5 will take place in parallel at the same time,
The other processes are performed sequentially in the order shown. 

@menu
* Priority::                    Event priority
* Note Collision::              Processing of note collisions
@end menu

@node Priority, Note Collision, Output Process, Output Process
@subsection Event priority
@cindex Event priority
@cindex Events sorting
@cindex -p option

Each event has a priority assigned to each of its types,
The events are sorted from highest to lowest priority and output in that order.
If events have the same priority, the order is kept as it originally was.

Event priorities are defined as follows.

@c helpme: in the following list, unsure how to translate items 2 and 5.
@display
1 (Minimum) key pressure, channel pressure
2        ノートオン、持続時間が０である音符のノートオフ
3        Control Change, tempo setting, exclusive
4        Meta events other than tempo setting
5 (最高) 持続時間が０でない音符のノートオフ 
@end display

If the @samp{-p} option is on the command-line,
All events are regarded to have the same priority.

@node Note Collision,  , Priority, Output Process
@subsection Processing of note collisions
@cindex Notes collision
@cindex -n option
@cindex Retrigger

If two or more notes with the same note number are played overlapping, In the same channel of the same track,
 the duration of the sound becomes shorter than the original length.
For example overlap two notes.
If the messages have been sent to the MIDI instrument in the following order:
Note-on, note-on, note-off, note-off;
The sound is intended to last until the later note-off,
but is in fact terminated by the earlier note-off.
In order to avoid such a problem, in the PMML compiler
in the file output section, the following processing is done.

@c helpme: in the following, unsure how to translate item 2.
@enumerate
@item
If a note-on event arrives for a note already sounding, add, immediately before
it, a note-off to smoothly retrigger the note and preserve the intended length.

@item
２重以上に発音されているキー、或は発音されていないキーに対して
ノートオフイベントが到着した場合にはそれを削除します。

@item
After replacing note-on and off events for one note, if needed, perform this 
recursively for subsequent notes produced.

@item
If a note-on is found at the end of the song without a note-off, add one.
This is not part of note collision processing.
@end enumerate

If the @samp{-n} option is specified, the processing described above does not occur.

@node Output File, Environment, Output Process, Compiler
@section The output file
@cindex Output file

If the source code leads to a midi file being generated, it is governed by 
the following conditions of output.

@menu
* Output File Name::            File name of the output file
* Output Format::               The format of the output file
* Output Resolution::           Resolution of the output file
@end menu

@node Output File Name, Output Format, Output File, Output File
@subsection File name of the output file
@cindex File name of the output file
@cindex out.mid

The filename where output will be written is determined as follows.

@enumerate
@item
The argument to the @samp{-o} option on the command line, 

@item
if input is from standard input, or the @samp{-e}, @samp{-l} or @samp{-F} Options are used,
with no source files, @file{out.mid} is written.

@item
Otherwise, the input source filename's extention is changed to @samp{.mid}, and written to.
@end enumerate

@node Output Format, Output Resolution, Output File Name, Output File
@subsection Format of the output file
@cindex The format of the output file
@findex $format

The MIDI format of the output is determined as follows.

@enumerate
@item
If one of @samp{-0}, @samp{-1} or @samp{-2} is present on the command-line,
the appropriate format is specified.

@item
If this is not the case,
if a @samp{%@{} ... @samp{@}} string is found at the top of the source,
which defines @code{$format} it's value is used.

@item
If only one track of events is generated, a format 0 file is produced.

@item
Otherwise, format 1.
@end enumerate

@node Output Resolution,  , Output Format, Output File
@subsection Resolution of the output file
@cindex Resolution of the output file
@findex $resolution

The resolution of the MIDI file, (ticks per Quarter note), is determined as follows.

@enumerate
@item
The @samp{-r} command-line option.

@item
A block in @samp{%@{} and @samp{@}} which defines @code{$resolution}.

@item
If @code{load} or @code{loadtrk} is used, the maximum resolution 
of the MIDI file read is used.

@item
Otherwise, 480 ticks per quarter note is used as a default.
@end enumerate

@node Environment, One Liner, Output File, Compiler
@section Environment variables
@cindex Environment variables
@cindex PMMLPATH
@cindex File search path
@cindex Search path
@cindex LANG
@cindex Error message

The PMML compiler refers to the following environment variables.

@table @code
@item PMMLPATH
When reading files with the @code{include} command, looking for 
the startup file, or using the @samp{-F} option,
This is the search path of the file that is referenced.
Directories are separated on the path by @samp{;}, and are searched in the 
order given. For dos/windows systems, drive letters can be included.
If @code{PMMLPATH} is not defined, the default search path specified during 
installation is used.
The @samp{-I} option also adds to the search path
(@pxref{Options}).

@item LANG
If this variable is defined, and it's value starts with @samp{ja}, help and error messages
will be displayed in japanese.
@end table

@node One Liner, Limitations, Environment, Compiler
@section One-liner
@cindex One-liner
@cindex Format conversion
@cindex Conversion of resolution
@cindex Concatenation of standard MIDI files
@cindex Splitting of standard MIDI file

Here it is possible to describe the behavior at the command line only, without using any source files.
Some useful examples will be introduced.
The single quotes that are used in the examples are  meta characters of the Unix shell.
Run by removing these in the case of a DOS/Windows environment.

@table @code
@item pmml -0 -l @var{format1SMF}
Merge all the tracks in the format 1 MIDI @var{format1SMF} to a format 0 midi file.
The output file will be @file{out.mid}.

@item pmml -i f0tof1 -l @var{format0SMF} 
Convert the format 0 MIDI file @var{format0SMF} to format 1.
In the output file, tempo information goes to track 1, track 2 contains
exclusive messages and tracks 3 to 18 contains each channels events.

@item pmml -r120 -np -l @var{SMF}
Convert the resolution of the MIDI file @var{SMF} to 120 ticks/quarter note.
It doesn't matter if @var{SMF} is format 0 or format 1.
The @samp{-np} options are used to avoid modifying the order of events during conversion.

@item pmml -c2 -l @var{SMF} 
Extract the events on channel 2 of the MIDI @var{SMF}.
Meta and exclusive events are also included.

@item pmml -f12 -t13 @var{SMF}
Extract bars 12 and 13 from @var{SMF}.

@item pmml -l @var{SMF1} -l @var{SMF2}
Concatenate the contents of @var{SMF1} and @var{SMF2} so that they play back-to-back.

@item pmml -l @var{SMF1} -e'&' -l @var{SMF2}
Merge the two MIDI files together so that they play in parallel.

@item pmml -e 'dump()' -l @var{SMF}
Displays the contents of @var{SMF} as readable text.

@item pmml -e 'quantize(s)' -l @var{SMF}
Quantise the notes in @var{SMF} to 16th notes.
(@pxref{Predefined Effectors}).
@end table 

@node Limitations,  , One Liner, Compiler
@section Limitations
@cindex The total length of the song
@cindex The maximum number of effectors
@cindex Limitations in note collision
@cindex Limit to the number of files

@table @asis
@item The number of effectors that can be attached
In the current compiler, 31 effectors can be attached to each thread.

@item The total length of the song
The total length of the song will be limited to 131068  quarter notes  maximum.
At 120 bpm, this is equivalent to around 18 hours.

@item Processing of note collisions
For one note of the same key on the same channel,
anything above 256 collisions will not be handled correctly.

@item The number of files that can be opened at the same time
Built-in functions that open MIDI files, @code{loadtrk}, @code{ntrk}, @code{format}, and @code{resolution},
can open a maximum of 16 midi files.
@end table

@c --------------------------------------------------------------------
@node Lexical Rules, Data Types and Expressions, Compiler, Top
@chapter Lexical rules

@menu
* Space Characters::            Meaning of space characters
* Comments::                    Writing comments.
* Integers::                    Integer constants
* Floating-Point Constants::    Floating-point constants
* Pitch Constants::             Pitch constants
* Rational Constants::          Rational constants
* Strings::                     Character strings
* Identifiers::                 The Rules for identifier names
* Accents::                     Accent marks
* Time Shifters::               Time shift symbols
* Tokens::                      Lists of all types of token
@end menu

@node Space Characters, Comments, Lexical Rules, Lexical Rules
@section Space characters
Space, tab, and newline characters all act as space characters. They can be 
inserted freely throughout your source text.
However, if one is placed in the middle of an identifier,
or a token such as @samp{+=} it is considered invalid by the compiler.

@node Comments, Integers, Space Characters, Lexical Rules
@section Comments
There are two ways to indicate comments. These can be mixed.

@table @code
@item /* @r{@dots{}} */
@samp{/*} ... @samp{*/} is a  multi-line comment, similar to the C language. Can be inserted anywhere a space character would 
be expected. Unlike C comments however, they can be nested as shown below.

@example
/*
 c d e /* f  This part is also still comment. */
 c  
 */
@end example

@item // @r{@dots{}}
@samp{//} text to the end of the line is considered a comment.
As above, can be inserted anywhere a blank character can be placed.
@end table

@node Integers, Floating-Point Constants, Comments, Lexical Rules
@section Integers
@cindex Integers
@cindex Decimal constant
@cindex Hexadecimal constant

There are 2 ways to indicate integer constants, either as decimal
or hexadecimal. To specify decimal, just write the number as usual.
For a hexidecimal constant, use @samp{0x} before the number.
The digits A to F can be either lower or upper case.

@node Floating-Point Constants, Pitch Constants, Integers, Lexical Rules
@section Floating-point constants
@cindex Floating-point constants

A floating point constant contains both an integer part, and a fractional part,
separated by a decimal point (.). They can also use an exponent indicated by @code{e} or @code{E}.
Both positive and negative exponents are supported.

@node Pitch Constants, Rational Constants, Floating-Point Constants, Lexical Rules
@section Pitch constants
@cindex pitch constants
@cindex Accidental
@cindex Musical alphabet
@cindex Designation of octave
@cindex Relative octave designation
@cindex Sharp
@cindex Flat
@cindex Natural
@findex a
@findex b
@findex c
@findex d
@findex e
@findex f
@findex g
@findex r
@findex ^
@findex _

Pitch constants represent the musical notes (c, d, e, etc) as midi note numbers.
Aloan, they generate the notes, or rests. When used as part of an expression,
They generate the MIDI note numbers they represent.

The format of the pitch constant is as follows.

@example
@r{[}@var{octave-adjusters}@r{]}@var{pitchname}@r{[}@var{accidentals}@r{][}@var{octave}@r{]}
@end example

@noindent
The parts are.

@display
@var{octave-adjusters} := Either of @samp{^ _}
@var{pitchname} := One of @samp{a b c d e f g r A B C D E F G R} 
@var{accidentals} := Either of @samp{# b %} 
@var{octave} := [@code{-}]@var{integer}
@end display

Notes are specified in @var{pitchname} with the letters @code{a} through @code{g}.
The letters can be in either upper or lower case.
The american form of notation is used, so that @code{b} and @code{a} are one tone apart,
and @code{H} the german @code{B}, is not supported.
@var{pitchname} represents a rest if it is @code{r} or @code{R}.
A rest is given the special note number 0x80000000.

@var{accidentals} can be one of@samp{#} for sharp, @samp{b} for flat, which should be lower case
or @samp{%} for natural.
A sharp increases the MIDI note number by 1,
a flat Reduces the MIDI note number by 1.
If you specify more than one sharp or flat sign, it just increases or decreases
the midi note number by the number of signs.
If @var{accidentals} is not present, the MIDI note number is determined by
the @code{key} register, and implicit sharps or flats are added.
(@pxref{Key}).
A natural can be used to override a sharp/flat note.

@var{octave} specifies the octave for notes, where @code{C4}is middle c,
or MIDI note number 60.
@var{octave} can be negative(example: @code{C-1}).
If @var{octave} is not present, the value of the @code{o} register is used.

A relative octave can be specified by @var{octave-adjusters}
They increase or decrease the octave as described above.
@samp{^} increases the octave by 1, @samp{_} decreases by 1.
If more than one symbol is used, the octave decreases
or increases by that amount.

The @code{tp} Register (@pxref{Register Sets}) is added to note constants, before they
are finally generated, but after all the above rules are taken into account.
However, rests (0x80000000) are not affected by changes to @code{tp}.

Pitch constants cannot contain spaces in them.
For example, @samp{C-1} is valid, while @samp{C - 1} is not.
@samp{^C} and @samp{^ C} are both valid, but have different meanings.

@subsubheading Examples of pitch constants

@example
C4 D#5 a bb Dbb ^E% __c D#-1
@end example

@node Rational Constants, Strings, Pitch Constants, Lexical Rules
@section Rational constants
@cindex rational constant
@cindex Length symbol

Rational constants are constants for representing rational numbers.
In PMML, these are particularly used to represent times accurately, using fractional numbers.
For example, the length of a whole note in 4/4 time signature is represented by one of the constants.
The length of a quarter note is expressed as a fraction of 1/4.

Aloan, Rational constants specify  note durations, like other commands.
Also, like other constants, they can be used in expressions.

The form of a rational constant is as follows.

@example
@r{[}@var{multiplier}@r{]}@var{lengthname}@r{[}@var{dots}@r{]}
@end example

@noindent
The parts are as follows.

@display
@var{lengthname} := One of @samp{w h q i s z u W H Q I S Z U}
@var{dots} := One or more @samp{.}
@end display
@findex w
@findex h
@findex q
@findex i
@findex s
@findex z
@findex u

@noindent
Each of the meaning of the length symbols @var{lengthname} is as follows.

@table @asis
@item @samp{w} or @samp{W}
A whole note, with a value of 1. Think @b{w}hole note.
@item @samp{h} or @samp{H}
A half note, with a value of 1/2. Think @b{h}alf note.
@item @samp{q} or @samp{Q}
A quarter note, with a value of 1/4. Think @b{q}uarter note.
@item @samp{i} or @samp{I}
An eighth note, with the value 1/8. Think @b{e}ighth note.
@item @samp{s} or @samp{S}
A sixteenth note, with the value of 1/16. Think @b{s}ixteenth note.
@item @samp{z} or @samp{Z}
32nd note / rest (@b{z}weiunddreissigstel in German). Value is 1/32.
@item @samp{u} or @samp{U}
Tick. A value where 1U is 1/480 of a quarter note, and 1/1920 of a whole note.
@end table

@noindent
@var{lengthname} can be in either upper or lower case.

@var{multiplier} Is a constant integer or floating-point number.
@var{multiplier} takes the value of a duration constant, and multiplies
it by the value given to specify a new duration.

@display
@code{2w}   = 2
@code{1.5q} = 3/8
@code{.5z}  = 1/64
@end display

When you add dots to the note/rest length symbol, The duration is extended by half of it's original length.
This affect is cumulative, IE, note lengths would increase as follows.
1, 1.5, 1.75, 1.875 @dots{}
Or, more generally, 1 + 1/2 + 1/4 + @dots{} + 1/(2 ** n).

@display
@code{q.}  = 1/4 * 1.5 = 3/8
@code{h..} = 1/2 * 1.75 = 7/8
@code{2q.} = 2 * 1/4 * 1.5 = 3/4
@end display

A length symbol that ends with @samp{u} specifies note/rest length by ticks.
Here tick always refers to the length of 1/480 of a quarter note, and does not necessarily coincide with the tick of a standard MIDI file to be output.
For example, in the case of the resolution of the output file being 120, @samp{4u} is equivalent to 1 tick in the output file.

Please refer to the @ref{Note Length} for representation of tuplets.

@node Strings, Identifiers, Rational Constants, Lexical Rules
@section Character strings
@cindex Character strings
@cindex Double quotes (")
@cindex Backslash sequence

A String enclosed in double quotes @samp{"} is a string constant.
The following  backslash sequences can be used to represent special characters in the string constants.

@table @asis
@item @code{\n}
New line
@item @code{\t}
Horizontal Tab
@item @code{\v}
Virtical tab
@item @code{\b}
Backspace
@item @code{\r}
Carriage return
@item @code{\f}
Form feed
@item @code{\a}
Bell
@item @code{\\}
A literal backslash.
@item @code{\"}
A literal @samp{"}
@item @code{\@var{ooo}}
An octal character, represented by @var{ooo}. Should be exactly three digits.
@item @code{\x@var{hh}}
Represents any character in hex (@var{hh} specifying 2 hex digits.
@item End-of-line @samp{\}
New line
@end table

@node Identifiers, Accents, Strings, Lexical Rules
@section Identifiers
@cindex Identifiers
@cindex Name
@cindex Reserved word
@cindex Keyword

Macros, threads, effectors and communication channels are all given unique identifiers.
The PMML identifier is one of the following two types.

@itemize @bullet
@item
Starting with a Letter, and then 1 or more letters, numbers or underlines @samp{_}.
@item
Starting with a dollar sign @samp{$} and then continuing using the rules described above.
@end itemize

@noindent
There is no distinction in meaning between the two types above.

Unlike note name and length symbols, uppercase and lowercase letters are distinguished as different characters.
There is no character limit to the identifier.
If you want to include Japanese  characters in an identifier, kanji code or EUC or Shift-JIS should be used.

The following reserved words cannot be used as identifiers.
In the following table, @samp{b*[0-9]*} means 0 or more of the proceeding can be used. Example, @code{b}. 
@code{Ab*[0-9]*} means this is followed by a number, @code{A}, @code{Ab}, @code{A2}, @dots{} Ab2 Etc.

@example
Ab*[0-9]*       Bb*[0-9]*       Cb*[0-9]*       Db*[0-9]*       Eb*[0-9]*
Fb*[0-9]*       Gb*[0-9]*       H               I               Q
Rb*[0-9]*       S               U               W               Z
ab*[0-9]*       ac              add_eff_chs     add_eff_etypes  all
alt             append          arbit           attach          bb*[0-9]*
bend            break           case            cb*[0-9]*       ch
close           cpr             ctrl            ctrl_any        ctrl_cto
ctrl_pt         ctrl_to         db*[0-9]*       def             default
defeff          defthread       del_eff_chs     del_eff_etypes  detach
disable         do              dp              dr              dt
du              eb*[0-9]*       ecode           edef            else
elsif           enable          end             eval            evalstr
excl            excl2           fb*[0-9]*       for             foreach
gb*[0-9]*       gr              gt              h               i
if              include         init            insert          key
keysig          kp              l               load            loadtrk
local           meta            n               note            note_off
note_on         null            nv              o               prog
q               rb*[0-9]*       reject          repeat          rt
s               seqno           set_eff_chs     set_eff_etypes  set_thru_chs
set_thru_etypes sh              shift           shl             shr
signal          smpte           switch          t               tb
tempo           text            timesig         tk              tp
u               undef           v               w               wait
while           wrap            xor             z               
@end example

PMML's list of reserved words as shown above there are several, also fairly short words
(For example @code{i}, etc.)  that are also included. You need to be careful when you define new identifiers.
Using a dollar sign at the beginning of identifiers greatly reduces the risk of keyword conflicts.

While it's not necessary to use a dollar sign for all identifiers, for readability,
it is suggested that variables use a dollar sign, while macros, threads and effectors are plane.

@subsubheading Identifier examples

@example
id x $i under_score p5c $_z are all valid.
@end example

@subsubheading Invalid identifier examples

@example
_id i$ a db 
@end example

@node Accents, Time Shifters, Identifiers, Lexical Rules
@section Accent marks
@cindex accents
@findex ++
@findex --

Accents are used to modify the velocities of notes, based on a register (@pxref{Modifiers}, @ref{Changing Registers}).
Described below are the accent marks available, and the affect each has on velocities.
In the following, @samp{ac} is the value of the @code{ac} register.
(@pxref{Registers}).
 
@table @asis
@item @code{+.}
@code{ac} * 0.5 (@t{ac}=16 will be 8)

@item @code{++}
@code{ac} (@t{ac}=16 will be 16)

@item @code{++.}
@code{ac} * 1.5 (@t{ac}=16 will be 24)

@item @code{+++}
@code{ac} * 2 (@t{ac}=16 will be 32)

@item 2 or more @samp{+}
@code{ac} * (the number of @samp{+} @minus{} 1)

@item One or more @samp{+} followed by a @samp{.}
@code{ac} * (The number of @samp{+} @minus{} 0.5)

@item @code{-.}
@minus{}@code{ac} * 0.5 (@t{ac}=16 will be @minus{}8)

@item @code{--}
@minus{}@code{ac} (@t{ac}=16 will be @minus{}16)

@item @code{--.}
@minus{}@code{ac} * 1.5 (@t{ac}=16 will be @minus{}24)

@item @code{---}
@minus{}@code{ac} * 2 (@t{ac}=16 will be @minus{}32)

@item 2 or more @samp{-}
@minus{}@code{ac} * (The number of @samp{-} @minus{} 1)

@item One or more @samp{-}followed by @samp{.}
@minus{}@code{ac} * (The number of @samp{-} @minus{} 0.5)
@end table

@node Time Shifters, Tokens, Accents, Lexical Rules
@section Time shift symbols
@cindex time shifter
@findex >>
@findex <<

Time shift symbols shift events back and forth in time based on a register, (@pxref{Modifiers}, @ref{Changing Registers}).
Below, the affect of each time shifter is described. The value of @samp{sh} is the @code{sh} register (@pxref{Registers}).
 
@table @asis
@item @code{>.}
@code{sh} * 0.5 (@t{sh}=1/32 will be 1/64)

@item @code{>>}
@code{sh} (@t{sh}=1/32 will be 1/32)

@item @code{>>.}
@code{sh} * 1.5 (@t{sh}=1/32 will be 3/64)

@item @code{>>>}
@code{sh} * 2 (@t{sh}=1/32 will be 1/16)

@item 2 or more @samp{>}
@code{sh} * (The number of @samp{>} @minus{} 1)

@item One or more @samp{>}followed by a @samp{.}
@code{sh} * (The number of @samp{>} @minus{} 0.5)

@item @code{<.}
@minus{}@code{sh} * 0.5 (@t{sh}=1/32 will be @minus{}1/64)

@item @code{<<}
@minus{}@code{sh} (@t{sh}=1/32 will be @minus{}1/32)

@item @code{<<.}
@minus{}@code{sh} * 1.5 (@t{sh}=1/32 will be @minus{}3/64)

@item @code{<<<}
@minus{}@code{sh} * 2 (@t{sh}=1/32 will be @minus{}1/16)

@item 2 or more @samp{<}
@minus{}@code{sh} * (The number of @samp{<} @minus{} 1)

@item 1 or more @samp{<}followed by a @samp{.}
@minus{}@code{sh} * (the number of @samp{<} @minus{} 0.5)
@end table

@node Tokens,  , Time Shifters, Lexical Rules
@section tokens
@cindex tokens

The source text is broken down into a series of lexical tokens, with the following types.

@itemize @bullet
@item 
Integer constants
@item
Floating-point constants
@item
Character strings
@item
identifiers
@item
Pitch constant including relative octave  specification (will be treated as a single token).
@item
Rational constants
@item
Reserved words
@item
Octave up and down symbols (@code{^}, @code{^^}, @code{^^^}, @dots{},
@code{_}, @code{__}, @code{___}, @dots{})
@item
Time shift symbols (@code{>.}, @code{>>}, @code{>>.}, @dots{},
@code{<.}, @code{<<}, @code{<<.}, @dots{})
@item
Accent marks (@code{+.}, @code{++}, @code{++.}, @dots{},
@code{-.}, @code{--}, @code{--.}, @dots{})
@item
Other  complex symbols (@code{>=}, @code{<=}, @code{&&}, @code{||},
@code{==}, @code{!=}, @code{+=}, @code{-=}, @code{*=}, @code{/=},
@code{%=}, @code{shl=}, @code{shr=}, @code{&=}, @code{xor=},
@code{|=}, @code{::}, @code{%@{}, @code{===}, @code{..}, @code{...})
@item
Single symbols (@code{+}, @code{@{}, @code{=} etc)
@end itemize

@c --------------------------------------------------------------------
@node Data Types and Expressions, Basic Commands, Lexical Rules, Top
@chapter Data types and expressions

@menu
* Data Types::                  PMML has 6 data types.
* Expressions::                 Expressions in PMML
* Token-list Constants::        How to write token string constants
* Array Constants::             Writing array constants
* Logical Values::              Definition of logical values
* Operators::                   Description of all the operators and their meanings
* Type Conversion::             Rules for implicit conversion
@end menu

@node Data Types, Expressions, Data Types and Expressions, Data Types and Expressions
@section Data types
@cindex Data types
@cindex Integer
@cindex Floating-point type
@cindex Rational type
@cindex Character string
@cindex Token string type
@cindex Array type

PMML can handle 6 types of data.

@itemize @bullet
@item
Integer type @*
is a 32-bit signed integer.

@item
Floating-point type @*
is a floating-point type of double-precision (64-bit).

@item
Rational type @*
Rational numbers in PMML are expressed in the form of a mixed fraction (a + b / c).
a is an integer from @minus{}32768 to 32767.
b is an integer from 0 to 16383, c is an integer from 1-16383.
b is always   less than c. Rationals are used to primarily represent  time.

@item
Character string @*
Variable-length character strings are supported. There is no limit on the length of the string.

@item 
Token string type @*
0 or more characters that make up a token.

@item
Array @*
An array is a collection of zero or more   elements of data.
Each element can be any of the 6 data types listed here, and can be freely mixed.
An aray can contain other arrays, This allows you to configure a two-dimensional or more array.

There is no limit to the number of elements in the array.
In addition, you will be able to increase or decrease dynamically the number of elements in an  existing array.

Each element of the array can be randomly accessed by a subscript starting from 1.
The time it takes to access is constant regardless of the number of elements and the array subscript.
@end itemize

@node Expressions, Token-list Constants, Data Types, Data Types and Expressions
@section Expressions
@cindex Expressions
@cindex Types

Expression refers to any of the following listed primary expressions
and what operators can be used to form them.
The type of the expression is one of the six data types.

@noindent
Primary expressions and their data types

@display
Integer constant (Integer).
Floating-point constants (floating-point type).
Rational constant (rational type).
Pitch Constant (Integer).
Register (integer or rational type according to the register)
Character string constant (Character string type).
Token string constants (token string type).
Array constant (Array type).
@end display

@node Token-list Constants, Array Constants, Expressions, Data Types and Expressions
@section Token string constants

Token string constants, for example @samp{$x = 'c4 d4'} can be assigned to variables with =, and so on.
It is used when you want to define a macro. The following are the token string constants
There are two types of format.

@table @t
@item '@var{token} @dots{}'
Zero or more tokens enclosed in single quotes.
Within single quotes, Macro expansion, argument substitution, and evaluation of macro directive does not take place at all.

@item `@var{token} @dots{}`
Zero or more tokens Enclosed in backquotes. 
In the back-quotes, argument substitution, @code{eval} and @code{evalstr} macro commands
Evaluation  take place, but the evaluation of macro expansion and other macro directives
Do not take place.
@end table

@node Array Constants, Logical Values, Token-list Constants, Data Types and Expressions
@section Array constants
@cindex Array constants

The format of the array constant is described  below.

@example
#(@var{EXPR}, @var{EXPR}, @dots{})
@end example

The type of the expression in @var{EXPR} can be any type.
In addition, it does not matter even if they are of different types for each element.

@samp{#()} is used to create an empty array.

@subsubheading Examples of array constants

@example
#(1, 2, 3)
#("Mozart", 1756, "Salzburg")
#(c4+5, w*2)
#(#(1,0,0), #(0,1,0), #(0,0,1))
#(#("a", "b", "c"), #(2,3), #(0))
#('c4', 'e4', 'g4++', '[c2 c3]')
@end example

@node Logical Values, Operators, Array Constants, Data Types and Expressions
@section Logical values
@cindex Logical values
@cindex True
@cindex false

@code{if} and @code{while} are conditional commands. Expressions can be of
Logical operators (@samp{!}, @samp{&&}and @samp{||},
The Conditional operator (@samp{? :}Can also be used within expressions.
The following expressions are considered to be false.

@itemize @bullet
@item 
An integer value of 0
@item 
A Floating-point number of  0.0
@item 
A rational value that calculates to 0
@item 
The empty string, in other words @samp{""}
@item 
An empty token string, IE @samp{''}
@item 
The empty array, for example @samp{#()}
@end itemize

@noindent
All other expressions are considered to be true.

@node Operators, Type Conversion, Logical Values, Data Types and Expressions
@section Operators
@cindex Operators
@cindex Operator pressidence
@cindex overflow

PMML has operators similar to the C language.
The following is a list of operators that can be used.
Lines that begin with [Number] show operator evaluation order, higher numbered operators
are evaluated first.
If there is more than one binary operator with  the same calculation ranking, they are evaluated from left to right.
Operator priority can be changed using Parentheses @samp{()}.

@table @asis
@item [13] @samp{[ ]}
Access an element of an array (@pxref{Array Subscripting}).

@item [12] @samp{-} (unary)
Reverses the sign of integer, floating point or rational numbers

@item [12] @samp{!} (unary)
Logical negation, if an expression is true, it will become false, (@pxref{Logical Values}).
It is available for all data types.

@item [12] @samp{~} (unary)
bit inversion. It is available for integer types.

@item [12] @samp{#} (unary)
gives the number of elements in the array (@pxref{Array Size}).

@item [12] @samp{@@} (unary)
expands an array to individual tokens, separated by commas (@pxref{Array Expansion}).

@item [11] @samp{*}
Multiplication operator. Available for integer, rational or floating point types.

@item [11] @samp{/}
Devision operator, available for integer, floating point and rational types.
When integers are divided, the result will also be an integer.
Division by zero will result in an error.

@c helpme: one line of japanese here.
@item [11] @samp{%}
Calculates the remainder of a devision. Available for integer, floating point or rational types.
In the case of integers, results when either operand is negative depends on the operating system.
In the case of floating-point or rational numbers, the result of X%Y is the quotient obtained by dividing X by Y.
０の方向へ丸めた整数を n としたとき、X @minus{} n * Y です。
Division by zero will result in an error.

@item [10] @samp{+}
Performs addition for integer and floating point types, and string concatenation for strings.

@item [10] @samp{-}
Subtraction operator. Available for integer, floating point or rational types.

@item [ 9] @samp{shl}
Left shift operator. It is available for integer types.

@item [ 9] @samp{shr}
Right shift operator. It is available for integer types.

@item [ 8] @samp{<}
@itemx [ 8] @samp{<=}
@itemx [ 8] @samp{>}
@itemx [ 8] @samp{>=}
Performs a magnitude comparison, gives the result as 1 (if true) or 0 (for false).
They can be used for Integer, floating-point, rational and string types.
In the case of strings, they will be compared in dictionary order.

@item [ 7] @samp{==}
@item [ 7] @samp{!=}
Performs an equality comparison, gives the result as 1 (if true) or 0 (for false).
It is available for all data types.
If floating point and integer types are compared, type conversion is performed, and then the expression is tested.
If types cannot be converted to compatible forms, the result of the expression is false.
In the comparison of arrays  with each other, they are only considered equal
if the nested structures of the arrays are the same, and the value of all the elements are equal.

@item [ 6] @samp{&}
Bitwise and. available for integers

@item [ 5] @samp{|}
Bitwise or. available for integers

@item [ 4] @samp{xor}
bit exclusive OR. It is available for integers.

@c helpme: Please crosscheck the below info on these last three items
@c to make sure I got the correct translation.
@item [ 3] @samp{&&}
Logical and operator. It is available for all data types.
Unlike the C language, the second operand notwithstanding the authenticity of the first operand is always evaluated.
Thus, for example, @samp{if( defined($x) && $x == 3 )} If called, and @code{$x} is the second operand, and is undefined, "Undefined macro" error will result.
As with the C language, evaluate the second  operand only when the first operand is true.
The second operand should be enclosed in braces to use this behaviour.
@samp{if( defined($x) && @{ $x == 3 @} )} 

@item [ 2] @samp{||}
 Logical OR operator. It is available for all data types.
Like with the @samp{&&} operator, the second operand is only evaluated when the first is true.
The second operand should be enclosed in braces to use this behaviour.

@item [ 1] @samp{? :}
The conditional operator (@pxref{Logical Values}). Evaluate the expression before ?
If true, return the second operand, else the third. This is available for all data types.

Unlike the C language, the second and third operands are always evaluated, regardless of
the truth of the first operand.
Like  C, if you wish to evaluate operand 2 or 3, based on the truth of operand 1,
enclose operands 2 and 3 in braces. @samp{if( defined($x) ? @{$x@} : @{10@} )}

If the condition operator is nested, it will be evaluated from the right. For example,
@samp{a ? b : c ? d : e} is equivalent to @samp{a ? b : (c ? d : e)}.
@end table

@noindent
Incompatibility with the C language is as follows.

@itemize @bullet
@item 
There are no increment @samp{++} or decrement @samp{--} operators

@item
Instead of @samp{<<}, @samp{>>} for bit shift operations, use @samp{shl}, @samp{shr}, like this.
@samp{$y = $x shl 2}

@item
Instead of @samp{^} for bitwise EX-OR, use @samp{xor}

@item
For the @samp{&&}, @samp{||}operators, and the condition expression @samp{? :}, all operands are always evaluated,
unless you use braces around operands (see above).
@end itemize

@subheading About overflow

In the arithmetic of integers,  overflow checking is not performed at all.
In arithmetic of rationals, if the denominator overflows (for example
@samp{w/480 + w/481}, a warning is issued, and 
rounding to the nearest fraction that can be represented takes place.
There is no check of overflow with respect to the integer part of the rational number.


@node Type Conversion,  , Operators, Data Types and Expressions
@section Type conversion rules
@cindex Conversion rules of data types
@cindex Type conversion rules

Implicit type conversions are done between integer, floating point and rational numbers. Described below are the rules
for such conversions.

In the type conversion, floating-point types are considered the highest, then rational types,
And then integer the lowest type.
If the types of operands in the binary operation are different, all types are converted to the highest common type,
and then the calculation is performed and returned as that type.

@subheading Conversion from low to high

Such conversions take place when a calculation of an equation is performed, When you pass an argument to a command or macro
, and it happens when you assign an integer to a rational type register.

@itemize @bullet
@item
Conversion from an integer to a floating-point type is  converted to an equal value.

@item
Conversion from an integer type to a rational type considers an integer to be a number of ticks.
For example, the integer 1 will be converted to 1 tick (1/1920).
For example, the integer 480 is converted to rational 1/4.
@c helpme: unsure how to translate this.
ただし、乗除算（剰余算も含む）のときだけは例外で、
演算数の片方が整数でもう片方が
有理数のときには、整数の値をそのまま有理数だと見なして演算が
行われます。従って、例えば @samp{q*2} の結果は有理数 1/2 となり、
2 をティック数だと見なして 2/1920 と 1/2 の積をとるという
意味にはなりません。

@item
Conversion from rational type to floating-point type, will be converted to the number of ticks.
For example, rational number 1/4 to 480.0, 1/13 will be converted respectively to 147.692.
@end itemize

@subheading Conversion from a higher to a lower type

Such a conversion takes place when you pass arguments to macros,
or assign values to registers.

@itemize @bullet
@item
Conversion from floating-point type to an integer type, This is done by rounding to the nearest integer.
Please keep in mind that it is different from the C language.

@item
Conversion from floating-point type to rational type, It will convert to the nearest fraction that can be represented. For example, 480.0 is converted to 1/4,
480.1 will be converted respectively to 4801/19200.

@item
Conversion from rational type to integer, will be converted to the number of ticks.
Rounding to the nearest tick count is done.
For example, 1/4 to 480, 1/13 will be converted respectively to 148.
@end itemize

@c --------------------------------------------------------------------
@node Basic Commands, Event Generating Commands, Data Types and Expressions, Top
@chapter Basic commands

@menu
* Registers::                   The role of registers and how to change them
* Note Command::                Note command
* Note Length::                 How to specify the note length
* Note Duration::               How to specify duration
* Key::                         Specifying key signature
* Threads::                     Concept and generation, the method of switching threads,
How to Write a chord and multiple parts
* Modifiers::                   Description of the modifiers to temporarily change the notes attributes
* No Operation::                Command that does nothing
@end menu

@node Registers, Note Command, Basic Commands, Basic Commands
@section The registers and how to  change them

Registers store the information required to run the commands for  event generation.
The registers have rational and integer types.

@menu
* Register Sets::               List of all registers
* Pseudo Registers::            List of pseudo registers
* Changing Registers::          How to change the values of the registers
@end menu

@node Register Sets, Pseudo Registers, Registers, Registers
@subsection Register List
@cindex Register

PMML's registers are listed below. Also included are the types, origin of the name, and the default value.

@table @asis
@item @code{t} (@b{T}ime: Rational type)
@findex t
Represents the current time. This sets when events will take place, and in the case of notes,
determine when the note-on event will be. The initial value is 0.

@item @code{tb} (@b{T}ime @b{B}ase: Rational type)
@findex tb
@code{rt} Pseudo register (@pxref{Pseudo Registers})
This is the reference time of when you specify a relative time. The initial value is 0.

@item @code{dt} (@b{D}elta @b{T}ime: Rational type)
@findex dt
It is a modified value of the event occurrence time.
When an event is generated, the actual time will be (@code{t} + @code{dt})
In the case of note commands, the note-off associated with the note-on willalso be shifted by dt. the initial value is 0.

@item @code{sh} (@b{SH}ift time: Rational type)
@findex sh
Sets the base value for the time shift symbols (@pxref{Time Shifters})
The initial value is 1/32 (a 32nd note).

@item @code{l} (@b{L}ength: Rational type)
@findex l
Note value (step time.
The amount of time between each note or chord, using, for example, note commands.
The initial value is 1/4 (the length of the quarter note).

@item @code{do} (@b{D}uration @b{O}ffset: Rational type)
@findex do
An offset of the duration of the sound (gate time, IE, the time from note-on to note-off).
(@pxref{Note Duration}).
The initial value is 0.

@item @code{dp} (@b{D}uration @b{P}ercentage: Integer)
@findex dp
Represents a percentage of the note duration (@pxref{Note Duration}).
The default value is 100.

@item @code{tk} (@b{T}rac@b{K}: Integer)
@findex tk
This is the track number of the track where events are stored (@pxref{Tracks}).
For format 0 or format 1 output, the initial value is 2.
For format-2, it is 1.
 
@item @code{ch} (@b{CH}annel: 整数型)
@findex ch
Represents the MIDI channel number of events that are generated (@pxref{MIDI Channels}).
The initial value is 1.

@item @code{n} (@b{N}ote number: 整数型)
@findex n
Represents the note number for generated note events, or key/channel aftertouch events.
When the value of this register is 0x80000000, a rest will be generated by note commands.
The initial value is 0x80000000.

@item @code{tp} (@b{T}rans@b{P}ose: 整数型)
@cindex Transposition
@findex tp
The value is added to the value of the pitch constant.
This also affects @code{load} And @code{loadtrk} where the value is added to all
note events from the read in MIDI file.
It is available in order to perform transposition.
The initial value is 0.

@item @code{o} (@b{O}ctave: Integer)
@findex o
Represents the octave.
Constant value of the pitch constant depends on the value of this register (@pxref{Pitch Constants}).
The initial value is 4.

@item @code{key} (@b{KEY}: Integer)
@findex key
Specifies the key signature. If the value is positive, it represents number of sharps,
if negative, it represents the number of flats.
For more information, @ref{Key}.
The initial value is 0.

@item @code{v} (@b{V}elocity: Integer)
@findex v
@cindex Velocity
Represents the velocity of the note-on events that are generated.
The initial value is 80.

@item @code{nv} (@b{N}ote-off @b{V}elocity: Integer)
@findex nv
@cindex Note-off velocity
Represents the velocity of the note-off events that are generated.
If this register is negative, note-on's with a velocity of 0, instead of note-off
messages are generated. This usually reduces MIDI traffic.
The initial value is @minus{}1.
@end table

@node Pseudo Registers, Changing Registers, Register Sets, Registers
@subsection Pseudo registers
@cindex Pseudo register
@findex rt
@findex du
@findex gt
@findex dr
@findex gr

Psudo registers do not take up any storage in the compiler themselves, but 
are treated just like any other register. They can be read and changed in exactly the same way as any normal register.

@table @asis
@item @code{rt} (@b{R}elative @b{T}ime: Rational type)
This register is the current time  based on the time represented by @code{tb}
If you assign a value @var{x} to this pseudo-register, @code{t} is assigned the value (@code{tb} + @var{x}).
Reading this psudo-register yields the value of (@code{t} - @code{tb}).

@item @code{du} (@b{DU}ration: Rational type)
This  represents the duration of the sound (gate time) (@pxref{Note Duration}).
If you assign a value of @var{x} to this psudo-register, @code{do} is assigned the value of @var{x}
In addition, @code{dp} is assigned the value of 0.
Reading this psudo-register yields the value (@code{do} + @code{l} * @code{dp} / 100).

@item @code{gt} (@b{G}ate @b{T}ime: Rational type)
This is an alias for the @code{du} Register.

@item @code{dr} (@b{D}uration @b{R}atio: Integer)
Duration of the sound of the (gate time)
This is the percentage of the note duration that is played (@pxref{Note Duration}).
If you assign a value of @var{x} to this register, @code{dp} is assigned the value of @var{x}.
In addition, @code{do} is assigned the value of 0.
Reading this psudo-register gives the value of @code{dp}.

@item @code{gr} (@b{G}ate time @b{R}atio: Integer)
This is an alias of the @code{dr} psudo-register.
@end table

@node Changing Registers,  , Pseudo Registers, Registers
@subsection Changing registers
@cindex Register assignment
@cindex Compound assignment operator
@cindex Designation of octave
@cindex Octave-up command
@cindex Octave down command
@cindex Accent command
@cindex Time shift command

The commands to change the contents of a register are as follows.

@table @t
@item @r{C:} @var{reg} = @var{expr}
@findex =
@findex @var{reg} = @var{expr}
The value of @var{reg} will be changed to the value of @var{expr}.

@item @r{C:} @var{reg} @var{op}= @var{expr}
@findex @var{op}= 
@findex @var{reg} @var{op}= @var{expr}
This is equivalent to

@example
@var{reg} = @var{reg} @var{op} @var{expr}
@end example

The following operators can be used for @var{op}.

@example
+ - * / % shl shr & xor |
@end example

@item @r{C:} @r{Expression that begins with a rational constant}
@findex Expression that begins with a rational constant
The value of the expression is assigned to the @code{l} register. Please see @ref{Note Length}

@item @r{C:} ^@r{,} ^^@r{,} ^^^@r{, @dots{}}
@findex ^
This is the octave up command, which increases the @code{o} register by the number of symbols given.

Note that this is the same command used for relative octave specification in pitch constants (@pxref{Pitch Constants}).
In @samp{o=4 ^C D} the @samp{^} is considered part of the pitch constant,
and @samp{^} in this case is not an octave up command.
@samp{^C} does not change the value of the @code{o} register.
The c is in octave 5, while the d is still in octave 4.
In order for @samp{^} to be recognised as an octave command, insert a space.
Thus, in @samp{o=4 ^ C D} Now the C and D are both in octave 5.

@item @r{C:} _@r{,} __@r{,} ___@r{, @dots{}}
@findex _
This is the octave down command, the @code{o} register
is reduced by the number of symbols given. The same level of care and attention as in the above octave up command is required.

@item @r{C:} @var{accent}
@findex ++
@findex --
These are the accent commands, they increase or decrease the @code{v} register according to the commands given in @var{accent} (@pxref{Accents}).
These effect velocity values.

Accents also serve as modifiers (@pxref{Modifiers}).
Thus, care needs to be taken.
If the command with a qualifier just before the accent symbol is present,
It is not an accent command, they will be recognized as qualifiers for the previous  command.
To forcibly be recognized as an accent command,
use a no-op command @samp{;} (@pxref{No Operation}).

@item @r{C:} @var{time-shifter}
@findex <<
@findex >>
The time shift commands increase or decrease the value in the @code{dt} register, as indicated by @var{time-shifter} (@pxref{Time Shifters}).

Note that Time shift commands, like accent commands, can also be modifiers (@pxref{Modifiers})

@item @r{SM:} fff
@itemx @r{SM:} ff
@itemx @r{SM:} forte
@itemx @r{SM:} mf
@itemx @r{SM:} mp
@itemx @r{SM:} p
@itemx @r{SM:} pp
@itemx @r{SM:} ppp
These standard macros set the @code{v} register, in order, to
127, 110, 95, 80, 65, 50, 35 or 20.
For example, instead of @code{v=95} you can say, @code{forte}.
@end table

@node Note Command, Note Length, Registers, Basic Commands
@section Note commands
@cindex Note command
@cindex Note
@cindex Rest

A Note command is a command to generate a note or rest.
The note command has two forms.

@table @t
@item @r{C:} @var{pitch-constant} @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@findex @var{pitch-constant}
When the pitch constant @var{pitch-constant} is anything other than @code{R} or @code{r},
A set of note-on events and note-off events are generated,
@code{t} is then updated by adding the value of @code{l}.
When the pitch constant in @var{pitch-constant} is @code{R} or @code{r},
this represents a rest, no note events  will be generated, but @code{t} will still
be updated as described above.

Please see @ref{Modifiers} for information about @var{modifiers}
When @samp{&} is attached to a note,
the value of @code{t} is not updated, so time is not advanced.

@var{pitch-constant} Will become the midi note number that is generated.
The MIDI channel number will be the value of the @code{ch} register.
The destination track number will be the value of the @code{tk} register.
The time of the note-on event will be the value of (@code{t} + @code{dt}).
The velocity will be the value of the @code{v} register.
The Time interval between note-on event and note-off events, IE,
the duration of the sound will either be (@code{do} + @code{l} * @code{dp} / 100) or 0,
whichever is larger (@pxref{Note Duration}).
The Note-off velocity of the note-off events will be determined by the value of @code{nv}.

When a note command is executed, the @code{n} register is given the value of @var{pitch-constant}.
@ignore
また、@var{pitch-constant} に絶対オクターブ指定が使われて
いる場合（例えば, @code{C4}, @code{D#5} などのような場合）、
@code{o} レジスタの値はそのオクターブに変更されます。
@end ignore

@item @r{C:} note @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@cindex Specifying the note number according to a formula
@findex note
In this format, rather than having the value of the pitch constant determine the MIDI note number,
The value of the @code{n} register is used. That is,
@code{n} specifies the midi note number directly.
Other aspects of the note generated are the same as described above. This form is used when you
want to specify note numbers using formulae rather than standard notation.

@example
note(n=C4+1)

for($i,C4,B4) @{ note(n=$i) @}
@end example
@end table

@node Note Length, Note Duration, Note Command, Basic Commands
@section Note length
@cindex Note length
@cindex tie
@cindex Tuplet
@cindex Specifying the step time

The amount of time before PMML advances to the next note command is
@dfn{note length} or the @dfn{Step time} と呼んでいます。
The note length  is stored in the @code{l} register.

An expression that begins with a rational constant is recognized as a command
to set the @code{l} register to it's value.
For example, the command @code{i} will set the @code{l} register to the rational 1/8.
Thus, all following notes will be 8th notes
Expressions that will be taken as note length commands include:

@example
w+h  z/2  q/7  2h/3  w+(q-i) 720u-5u
@end example

@noindent
However,

@example
2*w  (w+h)
@end example

@noindent
Will not be recognised as note length expressions.

@subheading Ties

PMML has no direct command for specifying that 2 notes are tied.
For example, if a C# is to have the length of a quarter note tied to a 16th note,

@example
q+s C#
@end example

@noindent
can be expressed with  the 2 durations added together as shown.

@subheading Tuplets

There is no command that has been specially prepared for tuplets representation in PMML.
It is because these can easily be expressed by using the division operator in the note length specified.
For example, to represent as below.

@example
q/3 C D E              // @r{3 notes in the space of a quarter note}
h/5 C D E F G          // @r{5 notes in the space of 1 half note}
3i/2 E D               // @r{Three two triplets that was divided into two eighth notes}
q/7 C C# D D# E F F#   // @r{7 notes in the space of a quarter note}
@end example

@node Note Duration, Key, Note Length, Basic Commands
@section Note duration (Gate time)
@cindex Duration
@cindex Gate time

The @dfn{Duration} or @dfn{Gate time} is the time between the note-on, and the note-off of a note event.
Setting the duration shorter than note length results in choppy or stacato
style playing, while setting it longer results in notes overlapping, legato style.

Note duration is calculated based on the values of the @code{do} (Offset value) and the @code{dp} (duration percentage) registers.
It is calculated by the following equation when note commands are executed.

@display
duration = @code{do} + @code{l} * @code{dp} / 100
@end display

@noindent
It should be noted that, as a result of the above calculation, it will be fixed to 0 if the duration is negative.

This allows flexibility when setting note durations, below are the 3 typical 
ways that the registers could be set.

@table @code
@item do=0 dp=@var{percentage}
The duration is specified by a percentage of the note length.
As a shortcut, these two assignments can be made in one with
@code{dr=}@var{percentage} or @code{gr=}@var{percentage}.

@item do=@var{duration} dp=0
 Regardless of the duration and note length, the duration will be fixed to @var{duration}.
As a shortcut, these two assignments can be made in one with
@code{du=}@var{duration} or @code{gt=}@var{duration}. 

@item do=@minus{}@var{gap} dp=100
Subtract the amount specified by @var{gap} from the duration of notes.
in other words, always place a blank time of @var{gap} between notes.
@end table

@subsubheading Examples of setting duration

@noindent
The following specifies that C,D,E have half of the note duration,
and then the F has a duration of 70% (7/10).

@example
dr=50 q C i D E h dr=70 F
@end example

@noindent
The following sets C,D,E to have a duration of 16th notes
then the F has a duration of 800 ticks.

@example
du=s q C i D E du=800u h F
@end example

@node Key, Threads, Note Duration, Basic Commands
@section Key signature
@cindex Key
@cindex Accidental
@cindex Sharp
@cindex Flat
@cindex Natural

PMML has the ability to automatically sharpen/flatten notes in a piece, based on the key signature.
You specify this in the @code{key} register. It sets the number of sharps/flats in the piece.
A positive number is used in the case of sharps,  a negative number in the case of flats.
For example, in the case of G major / E minor, @code{key = 1},
in the case of B flat major / G minor @code{key = -2} would be used.

The example below is part of a song in F major.

@example
key=-1 
i A B ^C ^D q ^C ^C B% B% ^C Bb
@end example

Note the first @code{B}, because of the @code{key=-1}, is actually generated as Bb.
If you wanted the B to be natural, add a %, as in @code{B%}.
Since PMML has no concept of the measure as in musical notation, a note that has
an accidental will revert to it's regular state after that one note.
Therefore, the @code{B%} would need to be repeated for any further occurrences. Otherwise,
the notes would revert to BB, not B natural.

When double sharps and double flats are required, you can write @samp{##}, @samp{bb}.
To cancel the automatic adding of flats or sharps, you can write either
@samp{%b} or @samp{b}.

The operation of the @code{key} register and the command to generate MIDI
key signature events @code{keysig} (@pxref{Meta Events}) work independently.
That is, changing the @code{key} register does not generate a key signature event.
On the other hand, when the @code{keysig} command is executed, the @code{key} register is not changed.
Therefore, if you want to perform automatic sharp/flat output, and generate a key signature event,
you should write both @code{key=}@var{expr} and @code{keysig} commands.
It is also possible to only use an @code{keysig} command, and not use the automatic sharpeing and flattening of notes.

@node Threads, Modifiers, Key, Basic Commands
@section Threads and their commands
@cindex Thread
@cindex Thread hierarchy
@cindex Thread tree
@cindex Root thread
@cindex Thread name

A @dfn{thread} in PMML allows a set of commands to be isolated and run in
parallel with other commands, instead of sequencially as would normally be the case.
Music can also be threaded for better organization. Threads are dynamic, they are created and disappear as needed.

Each thread has it's own set of registers (@pxref{Registers}),
with each set being independent from any other.
Therefore, if you change registers in one thread, the changes will only effect
subsequent commands in that thread, and not any other thread.
In addition, macros defined in one thread cannot be called from another thread,
unless certain conditions are satisfied (@pxref{Calling Macros}).

There are two types of thread. the @dfn{Named thread} and the @dfn{Unnamed thread} 
The @dfn{Named thread} has a @dfn{Thread name}.
It is mainly used to describe multiple instrument parts.
The @dfn{Unnamed thread} is used to set registers inside chords, for example.

Both named and unnamed threads have parent-child relationships, forming part of a tree structure.
When a new thread is generated, it is said to be a child of it's parent thread.
At the time of creation, all register values from the parent thread are copied to the child.
The thread at the root of the tree is called the @dfn{Root thread}.
At compiler startup, this is the only thread that exists.
The root thread has the thread name @samp{global}.

@menu
* Grouping::                    Grouping commands and temporary threds
* Chords::                      Representation of chords
* Creating Named Threads::      Creating named thredds
* Switching Threads::           How to switch threads
* Wait for Child Threads::      Syncronising between threads
* Deleting Named Threads::      Deleting named threads
@end menu

@node Grouping, Chords, Threads, Threads
@subsection Grouping commands
@cindex Unnamed thread
@cindex Change of local register
@cindex Representation of concurrent voices

The following commands are called grouping commands.

@table @t
@item @r{C:} @{ @var{command} @r{@dots{}} @} @r{[}@var{modifiers}@r{] [}&@r{]}
@end table
@findex @{ @var{command} @dots{} @}

The grouping command generates a new unnamed thread as a child thread,
The commands inside the curly braces are run, in order, within that thread.
Upon completion of the execution of all the commands, the child thread will automatically disappear.
the last @samp{&} Has a meaning similar to that of the Unix shell, specifying that commands are run in the background.
If the @samp{&} is not at the end, the execution of the parent thread is 
suspended while the commands inside the braces are run.
Therefore, immediately after the grouping command, The parent thread's @code{t} register's value becomes
the time after the last command in the braces.
If the command ends with @samp{&},Commands will be executed in parallel.
therefore, the parent thread's time does not change, and stays at the value it was before the commands in the braces were executed.

Grouping commands without @samp{&} are useful if you want to temporarily
change the values of registers. You can change the values of registers inside the child thread,
and they won't affect the parent thread.
Registers changed inside the braces will only affect commands inside them.
Registers from the parent thread are copied to the child thread within the braces, and remain separate.
For example, only the notes E and D in the example below are played at a velocity of 100, and otherwise
notes are played at the velocity of 80.
@example
v=80 C D @{v=100 E F@} E D C
@end example

Grouping commands with @samp{&} can be used when you want one part to be 
divided into separate voices temporarily.
For example, in the following, three voices are being played in parallel.

@example
@{w D E@}& 
@{w F G@}& 
@{h ^C B w ^C@}
@end example

@noindent
 Or, this way, using chord commands, shown in the next section.

@example
[@{w D E@} @{w F G@} @{h ^C B w ^C@}]
@end example

@noindent
You can choose either style to represent multiple voices,
however if the voices are independent, the first style is prefered.

@subsubheading Grouping commands and qualifiers

Like many of the other commands, you can use modifiers with grouping commands (@pxref{Modifiers}).
The modifiers are evaluated, and then applied to the commands in the braces 
before they are run. For example,

@example
@{v=100 E F@}(ch=2) 
@end example

@noindent
Before @code{v=100}, the @code{ch=2} is executed. as a result, the E and F
are placed on MIDI channel 2. You can also write this as:

@example
@{ch=2 v=100 E F@}
@end example

@noindent 
These two methods are generally the same,

@example
@{ @var{commands1} @} (@var{commands2})
@end example

@noindent 
as long as @var{commands2} doesn't change the @code{t} register.

@example
@{ @var{commands2} @var{commands1} @}
@end example

@noindent 
These are equivalent.

@node Chords, Creating Named Threads, Grouping, Threads
@subsection Chord command
@cindex chord
@cindex Chord command
@cindex Unnamed thread

Chords can be described by a chord command shown below.

@table @t
@item @r{C:} [ @var{command} @r{@dots{}} ] @r{[}@var{modifiers}@r{] [}&@r{]}
@end table
@findex [ @var{command} @dots{} ]

@noindent
The first @samp{[} and the last @samp{]} Represents the signs themselves in the text,
and not that this is an optional part of the command.
In other words, the command part of the cord command specification above replaces the pitch constant part of a note command.

Like the grouping command, a cord command generates a new unamed child thread.
The commands with in are run in order.
The difference between the grouping command and the chord command is that each 
command in the square brackets has an @samp{&} implicity attached.
For example,

@example
[C E G]
@end example

@noindent
is the same as

@example
@{C& E& G&@}
@end example

@noindent
This generates a triad, with the notes c, e, and g. The order of the notes is that specified in the brackets.

The amount of time added to the @code{t} register is the  length  of the longest
note inside the brackets. Thus, the two examples shown above are not equivalent.
However, if there is an @samp{&} at the end of the chord, the @code{t} register is not changed.

@subsubheading Chord commands and qualifiers

It is also possible to put a qualifier to a chord command (@pxref{Modifiers})
This qualifier will  modify the whole chord. For example,

@example
[C E G](w)  [C F A]++
@end example

@noindent
In the first chord, all notes are played for the length of a whole note.
In the second, all notes are increased in velocity a little.
These could also be written as:

@example
[w C E G] [++ C F A]
@end example

@noindent 
More generally,

@example
[ @var{commands1} ] (@var{commands2})
@end example

@noindent 
as long as @var{commands2} doesn't change the value of the @code{t} register.

@example
[ @var{commands2} @var{commands1} ]
@end example

@noindent 
these are equivalent.

@subsubheading Grouping commands in the chord command

It is also possible to include the grouping command in the commands of the square brackets.
With this structure it is possible to express sequential voice movement in a chord.
For example,

@example
w [D5 @{h C5 B4@} G4]
@end example

@noindent
Is treated as,

@example
w [D5& @{h C5 B4@}& G4&]
@end example

@noindent
it looks like the figure below to represent the timing and duration of each note in a straight line.

@display
D5: ------------
C5: ------ 
B4:       ------
G4: ------------
@end display

@subsubheading PRECAUTIONS

If an array immediately proceeds the @samp{[} chord command, it will be
mistaken for a subscript operation. To fix this, insert a no-op @samp{;} command
before the chord (@pxref{No Operation}).

@node Creating Named Threads, Switching Threads, Chords, Threads
@subsection Creating named threads
@cindex Creating named threads
@cindex Named thread
@cindex Generation of thread

Named threads are created by the @code{defthread} command.
When using a named thread to describe multiple parts, it is more convenient to use the standard macro @code{newtrack}.

@table @t
@item @r{C:} defthread(@r{[}@var{thread-path}@r{]}@var{thread-name}, @r{@dots{}} )
@findex defthread
Generate a named thread with the specified thread name in each argument.
The parent thread is specified by the path in @var{thread-path} (@pxref{Scope Specifiers}).
If not specified, the current thread will be the parent.

One parent thread should not have two child threads with the same name, which will
lead to a compiler crash. Threads with the same name can be in different
parent threds, however, this should be avoided to minimise confusion when switching and managing threads.

@item @r{SM:} newtrack(@r{[}@var{thread-path}@r{]}@var{thread-name}) @{ @var{command} @r{@dots{}} @}
@findex newtrack
Generates a named thread with thread name @var{thread-name}, with the @code{tk}
register of the thread being set to the new track number.
A track name string of "@t{(}@var{thread-name}@t{)}" is also generated on the track
(@pxref{Meta Events}).
Finally the commands in @var{command}@dots{} are run in the thread.
The @var{thread-path} specification is the same as in @code{defthread}, with
the same meaning. Track numbers start at 2, and are incremented each time the
@code{newtrack} macro is called.
IN the commands, it is suggested that initialization settings be written such as program and volume settings.
@end table

@node Switching Threads, Wait for Child Threads, Creating Named Threads, Threads
@subsection Command execution in other threads
@cindex Command execution in other threads
@cindex Thread switching command
@cindex multiple parts

To execute commands in another thread, use the command below, called the thread
switching command.

@table @t
@item @r{C:} @r{[}@var{thread-path}@r{]}@var{thread-name} @{ @var{command} @r{@dots{}} @} @r{[}+@r{]}
@end table
@findex @var{thread-name} @{ @var{command} @dots{} @}

@noindent
@var{thread-name} is the thread to which commands are directed.
@var{command}@dots{} is the set of commands to be executed.
@var{thread-name} can be at any point in the thread tree. If two or more threads
share the same name in the current thread's ancesters, the closest thread in the line will be selected.
If the thread @var{thread-name} does not exist in the tree, the results are unpredictable.
To avoid such ambiguity, specify a @var{thread-path}. 
For a description of the specification of @var{thread-path} please see @ref{Scope Specifiers}.

When a request to switch to the thread @var{thread-name} is made, and commands
previous to this one are still waiting to be executed, the system will complete the previous commands,
and then execute @var{command}@dots{}.
If, however, the previous commands have executed, @var{command}@dots{},
will immediately be run at the time of the request.
The thread that is switched to by @var{thread-name} has it's execution status restored,
independently to any other threads or commands.
therefore, immediately after the thread switching command, the value of the 
@code{t} register is restored to it's previous state when this thread was last used.

@c helpme: unsure how to translate this paragraph.
最後の @samp{+} は @samp{===} コマンドによる子スレッドの
実行終了待ちの
対象から除外したいときに付加します(@pxref{Wait for Child Threads})。

Multiple named threads are the key to describing music with multiple parts. 
Below is a simple example of music made up of two parts,
the organ part with the thread named  @code{organ} and the bass in the thread called @code{bass}.

@example
newtrack(organ) @{ ch=1 @}      // organ thread assigned to track 2.
newtrack(bass) @{ ch=2 o=2 @}   // bass thread assigned to track 3.

organ @{
  /* (a) */
  h [E Bb ^Eb] i R [E Bb ^Eb] R(q)
  h [Eb A ^D]  i R [Eb A ^D]  R(q)
@}
bass  @{ 
  /* (b) */
  C D E G F ^Eb ^C A 
@}
organ @{
  /* (c) */
  w [E Bb ^Eb]
  q R [E Bb ^Eb] i R [E Bb ^Eb] R(q)
@}
bass  @{
  /* (d) */
  C D E F G A Bb ^C
@}
@end example

@noindent
Since both threads initially start at time 0, (a) and (b) will be played in parallel.
The organ thread in @code{organ} will perform (a), then (c).
Similarly,the bass thread in @code{bass} will play (b) then advance to (d),
Since the register values of each thread are independent, at the beginning of part (c),
the register values after part (a) are unchanged.
By organizing the threads this way, associated passages of the music can also be
placed close together, reflecting the form of the music.

The above example, as shown below, can also be rewritten to score style.

@example
newtrack(organ) @{ ch=1 @}      //generation of organ thread
newtrack(bass) @{ ch=2 o=2 @}   // generation of bass thread

organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}

organ @{ w [E Bb ^Eb]                         @}
bass  @{ C     D          E              F    @}

organ @{ q R   [E Bb ^Eb] i R [E Bb ^Eb] R(q) @}
bass  @{ G     A          Bb             ^C   @}
@end example

@node Wait for Child Threads, Deleting Named Threads, Switching Threads, Threads
@subsection Syncronising threads
@cindex Syncronising threads

@table @t
@item @r{C:} ===
@end table
@findex ===

The @samp{===} suspends execution of the thread where the command is issued,
until either of the following 3 conditions are met in the descendent threads.

@enumerate
@item
All commands in all descendent threads are completed.

@item
A @code{wait} (@pxref{Receiving Messages}) or @code{alt} (@pxref{Alternation}) command is encountered in the execution path

@item
if a @samp{+} is the last part of a thread-switching command.

@end enumerate

The @samp{===} command is used as follows when describing multiple parts in a score.
For example, consider the case where you want to change the tempo in the middle of a song.
Since the tempo  instructions effect all parts, it would be considered 
reasonable to place tempo commands in the root thread as follows.

@example
tempo(120)
organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

tempo(130)
organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}
@end example

@noindent
But the above code does not work as intended.
Since time does not proceed before Running the thread switching commands in the root thread,
@code{tempo(130)} and @code{tempo(120)} will end up being executed at the same time.
Correct code is as follows.

@example
tempo(120)
organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

===
tempo(130)
organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}
@end example

@noindent
Inserting @samp{===} before the new tempo command will mean that the tempo will
change correctly after the first part of the music is played.

The @samp{===} Command will also have the effect of time alignment between parts.
Please look at the following example.

@example
/* (a) */
organ1 @{ q C D E F @}
organ2 @{ q E F @}
bass   @{ w C @}
===
/* (b) */
organ1 @{ G F E D @}
organ2 @{ B A G F @}
===
/* (c) */
organ1 @{ w C @}
organ2 @{ w E @}
bass   @{ w C @}
@end example

@noindent
In part (b) there is no music in the @code{bass} thread, but it does rest for the length of (b).
Thus, the @code{bass} thread starts again in part (c) 
at the same time as the @code{organ1} thread does in part (c).
If the @samp{===} hadn't been included, part (c) would have played at the same
time as part (b).
Also, part (a)'s @code{organ2} thread's playtime is shorter than other threads, which is acceptable.
The end result is that @code{organ2} has a half note rest inserted automatically.

When @samp{===} is used with threads that have tied notes, you might need to use
the @samp{+} thread switching command.
In the example below, if there is no @samp{+} used, the @code{organ1} thread
would not have an extra quarter note rest inserted.

@example
===
/* (b) */
organ1 @{ G F E D @}
organ2 @{ B A G h F @}+
===
/* (c) */
organ1 @{ w C @}
organ2 @{ h. E @}
bass   @{ w C @}
@end example

@node Deleting Named Threads,  , Wait for Child Threads, Threads
@subsection Deleting named threads
@cindex Erasure of thread
@cindex deleting named threads

When needed, a named thread can be deleted, clearing the memory and resources used,
and making the identifier available again.

@table @t
@item @r{C:} undef(@r{[}@var{thread-path}@r{]}@var{thread-name})
@end table
@findex undef

@noindent
You can delete the thread by.
@var{thread-name} Name of the thread to be erased,
@var{thread-path} specifies the path to it.

If @code{undef} is executed, the thread specified and all it's descendents
will be deleted.
However, deletion does not happen immediately. Instead, the roll of @code{undef}
is to mark all effected threads for deletion. Only when all child threads have 
executed their commands, then the parent thread, will they be deleted.

When a thread is actually erased, All macros that belong  to the thread are all erased as well.
Also, all effectors attached in the thread will be detached.

@node Modifiers, No Operation, Threads, Basic Commands
@section Modifiers
@cindex Modifiers
@cindex Accent, tone, emphasizing, underlining
@cindex Time shift
@cindex Unnamed thread
@cindex Change of local register
@cindex General qualifiers
@cindex Dependent events

A modifier is not a command, It is part of the event generation command or chord command.
The qualifier changes registers or executes commands related to  only one note.
It is useful for when you only want to change registers for one note, or
apply effects such as pitch bend or aftertouch to single notes.

If the modifier is attached to the event generation command,
a new thread with no name is generated just for the one command.
The evaluation and execution of commands will then take place in this unnamed
thread, Then, it will be deleted.
For this reason, the register changes made by the qualifiers to commands that are qualified
are only valid for the single note, and won't effect other commands.

If the modifier is attached to the grouping command or chord command,
Evaluation of Qualifiers in threads that are generated by those commands
is done (unlike the case of event generation commands,
no further new thread is created by using a modifier).
In this case, the evaluation of the qualifier is done before the command of braces (or brackets).

The qualifiers have the following three types. You can add as many commands
in a qualifier as needed.

@table @code
@item @var{accent}
The @code{v} register is temporarily updated  according to @var{accent}.
For  example, in @samp{C D++ E} only the velocity of the D note
is increased by the value of the @code{ac} register.

@item @var{time-shifter}
The @code{dt} register is temporarily updated according to @var{time-shifter}.
For example, in @samp{C D>> E} both the note-on and note-off for the D note wil
be delayed by the value of the @code{sh} register.

@item ( @var{commands} @r{@dots{}} )
This is called a general qualifier. In a newly created thread,
Prior to the execution of the command to be modified,
the compiler runs the commands in @var{commands}@dots{},
Then runs the command to be modified.
The qualifiers used most are the commands to change note length and duration.
For example,

@example
i C D E(q) F r(q) G
@end example

@noindent
Here, only the E and the rest have a quarter note length, the rest of the notes
and the rest are 8th notes.
Other examples where this is useful include:

@example
C D(dr=80) E
@end example

@noindent
Here, only the D note has it's duration changed to 80% of the note length.

The commands in the brackets may include other event generation commands,
and there can be more than one.
In particular this makes the relationship between notes and pitch bends, or aftertouch clearer. For instance:

@example
C4(kp(40))
@end example

@noindent
Here, a key pressure event will be generated with  the note at the same time.
When you run the command in the qualifiers, the @code{n} register is already set to the value of the pitch constant,
and then the @code{kp} command also has the same value as the @code{n} register
for the MIDI note number to be affected by key pressure.

In general qualifiers, immediately after the open parentheses, @samp{tb=t},
and Just before the closing parenthesis @samp{t=tb} is automatically inserted.
Therefore, in the qualifiers, event times can be relative to the note-on event of the qualifier using the value of @samp{rt=@var{expr}}.
For example, you can specify the time of the event that is subordinate in the following manner.

@example
C(kp(40) rt=30u kp(50) rt=60u kp(60))
C(bend(-200) rt=s bend_to(0))
@end example

@noindent
In order for the relative time functions described above to work in general qualifiers,
do not change the @code{t} register within the qualifier, else the function is disabled.
For example, in order to shift the time of the note, do not use @samp{C(t+=10u)} instead, write 
@samp{C(dt+=10u)}.
@end table

@node No Operation,  , Modifiers, Basic Commands
@section No-op command
@cindex No-op command

@table @t
@item @r{C:} ;
@end table
@findex ;

The Semicolon is recognized as a command to do nothing.
It can be freely inserted, such as to separate music into bars,
in order to increase the readability of the source text.
Also, in order to keep the similarity with the C language, it can also be added to the end of a command. 
It is likely to be called from within an expression
Please keep in mind that it can not be used in the macro definition.

@c --------------------------------------------------------------------
@node Event Generating Commands, Macros, Basic Commands, Top
@chapter Event generation commands

@menu
* Note Events::                 Note generation commands
* Virtual Control Change::      Virtual control changes
* Velocity Magnifier::          For velocity magnification
* Control-Change Events::       Control Change, Program Change,
                                Pitch bend, aftertouch, tempo changes, etc.
* Continuous Control Change::   Continuous control changes
* Exclusive Events::            Exclusive and any message
* Meta Events::                 Generating meta-events. time and key signature,
                                Insertion of markers, including the insertion of tune titles
@end menu

@node Note Events, Virtual Control Change, Event Generating Commands, Event Generating Commands
@section Generation of note events
@cindex Generation of note events
@cindex Single generation of note-on
@cindex Single generation of note-off

The commands to generate  note-on or note-off events are the following.

@table @t
@item @r{C:} @var{pitch-constant} @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@itemx @r{C:} note @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
See @ref{Note Command} for these.

@item @r{C:} note_on(@var{note-num} @r{[}, @var{velocity} @r{[}, @var{channel}@r{]]}) @r{[}@var{modifiers}@r{]}
@findex note_on
Generates a note-on event. the event's time will be (@code{t} + @code{dt}),
in track number @code{tk}. The MIDI channel will be @var{channel}.
The MIDI note number will be @var{note-num}, with a velocity of @var{velocity}.
If @var{velocity} is omitted, the value of the @code{v} register is used.
If @var{channel} is not included, the value of the @code{ch} register is used.

@item @r{C:} note_off(@var{note-num} @r{[}, @var{velocity} @r{[}, @var{channel}@r{]]}) @r{[}@var{modifiers}@r{]}
@findex note_off
This will generate a note-off event.
The event time is (@code{t} + @code{dt}), track number is @code{tk}.
The MIDI channel is @var{channel}, the MIDI note number is @var{note-num}. 
The note-off velocity is @var{velocity}. 
If @var{velocity} is omitted, the value of the @code{nv} register is used.
If the velocity is negative, a note-off, instead of a note-on with a velocity of 0 is generated.
Usually this is effective in reducing the MIDI traffic.
If @var{channel} is omitted, the value of the @code{ch} register is used.
@end table

@noindent
For @var{modifiers}, please see @ref{Modifiers}.

@node Virtual Control Change, Velocity Magnifier, Note Events, Event Generating Commands
@section Virtual and extended control change
@cindex Virtual Control Change
@cindex Virtual controller
@cindex Expanded Control Change
@cindex Expansion controller number

In MIDI, a control change can have a controler number between 0 and 127.
In PMML it has been extended to 255.
If a control change with a controler number of 128 or more is used, it is called a @dfn{Virtual controller},
and a control change using it is called a @dfn{Virtual Control Change}.
In addition, the virtual control change and (real) Control Change
is called the @dfn{extented control change} to match,
and its controller number (IE, from 0 to  255) is called the @dfn{extented controller number}.

Some of the specified virtual controller features such as pitch bend and tempo
are allocated in advance by the system. Other virtual controllers are allocated
with effectors (@pxref{Virtual Controllers and Effectors}),
By taking advantage, users can freely define the meaning.
For example, a certain virtual controller can be assigned to an exclusive message,
such as a master volume, and used.

A virtual controller number  that's less than 192  is controlled independently for each MIDI channel,
while 192 or more has been set aside as a control for all channels.
If the format of the output file is 0 or 1, virtual control changes with 
controlers 192 or above are always placed on track 1, regardless of the @code{tk} register.
In addition, in a continuous control change, when finding an event belonging to the same line or curve,
the MIDI channel number is ignored
(@pxref{Continuous Control Change}).

Virtual controler numbers reserved by the system, with their numbers and
meanings, are as follows.

@table @asis
@item 128
Pitchbend
@item 129
Key pressure
@item 130
Channel pressure
@item 131
Program Change
@item 132
Velocity magnification (@pxref{Velocity Magnifier})
@item 192
Tempo setting
@item 193
Relative tempo setting (@pxref{Control-Change Events})
@end table

@noindent
For example, the command @code{ctrl(128, 200)} 
outputs a virtual control change with the number of 128, and the value 200.
In other words, output a pitch bend message with a value of 200.
That is, @code{ctrl(128, 200)} and @code{bend(200)}  are exactly equivalent.
Within the PMML compiler, pitch bends are treated as controlers with an 
extended controler number of 128.
This is also true for other types of events that are listed above, including the tempo setting.

When the user defines a new virtual controller, it must be given a new 
controler number appropriate to the scope of the controler. The following two
standard macros facilitate the generation of unique virtual controler numbers.

@table @t
@item @r{SM:} new_vctrl
@findex new_vctrl
Gives the new virtual controller number For the independent controller for each MIDI channel.
The first time you call @code{new_vctrl} it is replaced with the value 133.
The value is increased by 1 each time the macro is called thereafter.

@item @r{SM:} new_gctrl
@findex new_gctrl
Will give the new virtual controller number For the controller for all MIDI channels.
The first time you call @code{new_vctrl} it is replaced by the value 194.
The value is increased by 1 each time the macro is called thereafter.
@end table

In addition, the standard macros below for manipulating  extented controllers are 
defined.

@table @t
@item @r{SM:} defctrl(@var{cntl-name}, @var{cap-ctrl-name}, @var{ctrl-num}, @var{tstep}, @var{threshold})
@findex defctrl
@var{ctrl-name} is a string that represents the name of the controller,
@var{cap-ctrl-name} a string that should be the same as @var{ctrl-name} with the first letter in uppercase,
@var{ctrl-num} is the controller number,
@var{tstep} and @var{threshold} is step size and threshold times for the continuous control change.
@code{defctrl} defines the following 7 macros when called.

@display
  @var{ctrl-name}, @var{ctrl-name}@t{_to}, @var{ctrl-name}@t{_pt}, @var{ctrl-name}@t{_cto}, 
  @var{cap-ctrl-name}, @var{cap-ctrl-name}@t{Step}, @var{cap-ctrl-name}@t{Threshold}
@end display

@noindent
For example,

@example
defctrl("chorus", "Chorus", 93, 15u, 1)
@end example

@noindent
is equivalent to:

@example
def(chorus, "n") @{ ctrl(93, $1) @}
def(chorus_to, "n") @{ ctrl_to(93, $1, ChorusStep, ChorusThreshold) @}
def(chorus_pt, "n") @{ ctrl_pt(93, $1) @}
def(chorus_cto, "n:nn") @{ 
  ctrl_cto(93, $1, ChorusStep, ChorusThreshold,
           null($2) ? 0 : @{$2@}, null($3) ? 0 : @{$3@})
@}
Chorus = 93
ChorusStep = 15u
ChorusThreshold = 1
@end example

@end table

@node Velocity Magnifier, Control-Change Events, Virtual Control Change, Event Generating Commands
@section Velocity magnification
@cindex Velocity magnification
@cindex Continuous change of velocity

in order to realize a crescendo / decrescendo using velocity in the PMML,
there is  a special virtual controller  called the velocity magnifier.
The control values of the velocity magnifier are called the velocity magnification.

Usually when you run a note command, the value of the @code{v} register 
directly controls the velocity in the MIDI output.
When you set a value other than 1.0 in velocity magnification,
in the course of output processing (@pxref{Output Process}),
its value will be multiplied by velocity.
Since velocity magnification can be continuously changed, you can gradually
increase or decrease the note velocities using this method.
It should be noted that the velocity magnification can be specified independently for each MIDI channel.

@subsubheading Example uses of velocity magnification 

@example
v=50
vmag(1.0)      // The same as ctrl(132, 1.0) 
q C D E F
vmag_to(1.6)   // The same as ctrl_to(132, 1.6) 
G
@end example

@noindent
Velocity of each note in this example is as follows.

@example
C: v=50
D: v=58
E: v=65
F: v=72
G: v=80
@end example

@node Control-Change Events, Continuous Control Change, Velocity Magnifier, Event Generating Commands
@section Control change events

The following  commands are used to generate control change events, including
standard macros to control common parameters such as tempo setting, Control Change, Pitch Bend

@table @t
@item @r{C:} ctrl(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl
@cindex Control Change
Generate an extended control change event.
The event time is the value of (@code{t} + @code{dt}), MIDI channel is @code{ch}.
The expansion controller number is @var{ctrl-num},
The control value is @var{value}.
When @var{ctrl-num} is 129, IE, expansion control corresponding to key pressure,
 the change will be the value of the @code{n} register.
@var{ctrl-num} must be in the range from 0 to 255.
Although the control value @var{value} will be able to take any data type,
if the value for the data type is invalid in the course of output processing
(@pxref{Output Process}), it is an error.

If @var{ctrl-num} is less than 192, the extended control change event will be
placed into the track indicated by the @code{tk} register.
If @var{ctrl-num} is 192 or more, track  placement depends on the format of the output MIDI file.
If format is 0 or 1, It is always placed in track 1 regardless of the value of the @code{tk} register.
If the output MIDI file format is 2, it is placed in the track indicated by the @code{tk} register.

@item @r{C:} bend(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend
@cindex Pitchbend
@cindex Pitch wheel change
The event time is (@code{t} + @code{dt}), the track number is @code{tk}.
The MIDI channel is @code{ch}, with the pitch bend value of @var{value}. 
The range of Bend value is @minus{}8192 to 8191, 
0 represents the centre position (no pitch change).

@item @r{C:} kp(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex kp
@cindex Key pressure
@cindex Key aftertouch
@cindex After touch
Generates an extended control change with the control number of 129, IE key 
pressure (polyphonic aftertouch).
The event time is (@code{t} + @code{dt}), track number is @code{tk}.
the MIDI channel number is @code{ch}.
The MIDI note number is @code{n}, the pressure value is @var{value}.
The range of pressure values is 0-127.

@item @r{C:} cpr(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex cpr 
@cindex Channel pressure
@cindex Channel aftertouch
@cindex After touch
Generates an extended controler event with the value of 130 , IE, key pressure
(channel aftertouch).
The event time is (@code{t} + @code{dt}), Track number is @code{tk}.
The MIDI channel number is @code{ch}, The pressure value is @var{value}. 
The Range of pressure values is 0-127.

@item @r{C:} prog(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex prog
@cindex Change of tone
@cindex Program Change
Generate an extended controler event with the value of 131, IE, program change.
The event time is (@code{t} + @code{dt}), the track number is @code{tk}.
The MIDI channel number is @code{ch}, program number is @var{value}.
The range of the program number is 1-128.

@item @r{SM:} vmag(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex vmag
@cindex Velocity magnification
Generate an extended control change with the value of 132, IE, velocity
magnifier (@pxref{Velocity Magnifier}).
The event time is (@code{t} + @code{dt}), Track number is @code{tk}.
The MIDI channel number is @code{ch}, Velocity magnification is @var{value}.

@item @r{C:} tempo(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex tempo
@cindex Setting the tempo
Generates an extended control change event with a value of 192, (tempo change).
The event time is (@code{t} + @code{dt}), the tempo value is @var{value}.
Tempo is specified in bpm (beats per minute) and can have fractional values.
If the output MIDI file is format 0 or 1, Tempo setting events are always placed
in track 1 regardless of the value of the @code{tk} register.
If the output MIDI file is format 2, it is placed in the track indicated by
by the @code{tk} register.

When a tempo setting event does not exist at time 0, @code{tempo(120)} is 
inserted automatically.

@item @r{SM:} rtempo(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex rtempo
@cindex Setting of relative tempo
 Relative tempo serves as a multiplier to the @code{tempo} command, multiplying
it's value by @var{value} 
An extended control change with a value of 193 is generated.
The event's time is (@code{t} + @code{dt}).

@item @r{SM:} mod(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex mod
@cindex Modulation Wheel
Generate an event to set the modulation wheel value.
This is equivalent to @code{ctrl(1, @var{value})}.

@item @r{SM:} breath(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex breath
@cindex Breath controller
Generate an event to set the breath controller value.
This is equivalent to @code{ctrl(2, @var{value})}.

@item @r{SM:} foot(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex foot
@cindex Foot controller
Generate an event to set the foot controller value.
This is equivalent to @code{ctrl(4, @var{value})}.

@item @r{SM:} pmtime(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex pmtime
@cindex Portamento time
Generate an event that sets the portamento time.
This is equivalent to @code{ctrl(5, @var{value})}.

@item @r{SM:} vol(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex vol
@cindex Volume
Generate an event to set the volume value.
This is equivalent to @code{ctrl(7, @var{value})}.

@item @r{SM:} pan(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex pan
@cindex Pan pot
Generate an event to set the pan pot value.
This is equivalent to @code{ctrl(10, @var{value})}.

@item @r{SM:} expr(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex expr
@cindex Expression
Generate an event that sets the expression value.
This is equivalent to @code{ctrl(11, @var{value})}.

@item @r{SM:} ped @r{[}@var{modifiers}@r{]} 
@findex ped
@cindex sustain pedal
generate an event  equivalent to stepping on the sustain pedal.
This is equivalent to @code{ctrl(64, 127)} 

@item @r{SM:} pedoff @r{[}@var{modifiers}@r{]} 
@findex pedoff
@cindex sustain pedal
Generate an event that releases the sustain pedal.
This is equivalent to @code{ctrl(64, 0)}.

@item @r{SM:} pm @r{[}@var{modifiers}@r{]} 
@findex pm
@cindex Portamento
Generate an event to turn on the portamento.
This is equivalent to @code{ctrl(65, 127)}.

@item @r{SM:} pmoff @r{[}@var{modifiers}@r{]} 
@findex pmoff
@cindex Portamento
Generate an event to turn off the portamento.
This is equivalent to @code{ctrl(65, 0)}.

@item @r{SM:} sped @r{[}@var{modifiers}@r{]} 
@findex sped
@cindex Soft pedal
Generate an event equivalent to stepping on the soft pedal.
This is equivalent to @code{ctrl(67, 127)}.

@item @r{SM:} spedoff @r{[}@var{modifiers}@r{]} 
@findex spedoff
@cindex Soft pedal
Generates an event that releases the soft pedal.
This is equivalent to @code{ctrl(67, 0)}.

@item @r{SM:} all_notes_off @r{[}@var{modifiers}@r{]} 
@findex all_notes_off
@cindex All Notes Off
Generate the All Notes Off event.
This is equivalent to @code{ctrl(123, 0)}.

@item @r{SM:} rpc(@var{rpn}, @var{byte})
@findex rpc
@cindex RPC
@cindex RPN
Generate a sequence of control change events for the MSB (most significant byte) of the RPC (register parameter control)
consisting of (high byte) only. 
The value of the @var{rpn} parameter is split into values for controlers 100 and
101, and then the lower 7 bits of the integer @var{byte} are output to controler
no. 6, data entry MSB.
The parameter number @var{rpn} must be specified as a 16-bit integer.
For example, MSB is 0x01, LSB 0x08, so for the argument, you should specify 0x0108.

@item @r{SM:} rpcw(@var{rpn}, @var{word})
@findex rpcw
Generate a sequence of control change events for the RPC consisting of both MSB and LSB.
The value in @var{rpn} is turned into control change events for controlers
100 and 101.
The lower 14 bits of the value in @var{word} are output to data entry msb,controler 6 and data entry lsb, controler 38. 
The specification method of the parameter number is the same as the @code{rpc} macro above.

@item @r{SM:} nrpc(@var{nrpn}, @var{byte})
@findex nrpc
@cindex NRPC
@cindex NRPN
Generate a sequence of control change events for the NRPC (non-Registered 
Parameter and control) From only the MSB (high byte)
The @var{nrpn} parameter is made into controler events for control 99, nrpn msb,
 and 98, nrpnlsb.
Using controler no. 6  (data entry MSB), output the lower 7 bits of @var{byte}.
The specification method of the parameter number is the same as the @code{rpc} macro above.

@item @r{SM:} nrpcw(@var{nrpn}, @var{word})
@findex nrpcw
Generate a sequence of control change events for the NRPC consisting of both MSB and LSB.
The value in @var{nrpn} is split into nrpn msb (controler 99( and lsb (controler 98.
The lower 14 bits of the value in @var{word} are used for the values of 
controlers 6, (data entry msb) and 38, (data entry lsb).
The method of parameter specification is the same as in the @code{rpc} macro above.

@item @r{SM:} bender_range(@var{byte})
@cindex bendor range
@cindex Pitch bend sensitivity
Uses the RPC to set the bendor range (pitch bend sensitivity).
@var{byte} is an integer, 0-127.

@item @r{SM:} fine_tune(@var{word})
@cindex Fine tuning
Set the fine tuning using the RPC.
@var{word} is an integer from @minus{}8192 to 8191.

@item @r{SM:} coarse_tune(@var{byte})
@cindex Course tuning
Set the course tuning using the RPC.
@var{byte} is an integer from @minus{}64 to 63.
@end table

@findex LASTVAL
The control value of each command above (@var{value}) is also available as 
@code{LASTVAL}, a standard macro that is defined as 0x80000000.
If it is called, all of the attributes of the last control change event are
recalled, including the same extension controller number and the same track
number if extension controller number is 191 or less and the MIDI channel number.
In addition, it has the same MIDI note number in the case of key pressure.
@code{LASTVAL} starts a continuous control change from the same value as before,
especially used in the case of continuous control changes.

Take a look at the @ref{Modifiers} for @var{modifiers} of each command.

@node Continuous Control Change, Exclusive Events, Control-Change Events, Event Generating Commands
@section Continuous Control Change
@cindex Continuous Control Change

If the control value is required to be varied little by little, it will need to
be changed in several MIDI messages to achieve a smooth change.
For example, using the volume controler (control 7) to achieve a diminuendo/cresendo.
PMML has a function to do this automatically, called @dfn{Continuous Control Change},

Two shapes for continuous changes are offered, those along a straight line, or a free curve.
In both cases, the starting point, zero or more intermediate points, and an end
point are specified.
For the starting point, you can specify this with @code{ctrl} as a normal control change command,
To specify 1 or more points along a multi-segment curve, use the @code{ctrl_pt} command.
The end point is specified with the @code{ctrl_to}command for a line, and
 @code{ctrl_cto} for a free-form curve.
For example:

@example
ctrl(7,0)              //set the volume value at the start to 0.
q C D
ctrl_to(7,80,15u,1)    //Vary the volume over the time of the C and D notes,
// linearly from 0 to 80
                       E F
ctrl_to(7,60,15u,1)    // Linearly change the volume from 80 to 60 over the 
// length of the E and F notes.
ctrl(7,30)             // Suddenly change the volume from 60 to 30.
G A B 
ctrl_pt(7,100)         // Specify the midpoint of a free curve as 100.
^C
ctrl_cto(7,120)        // Change the volume in a smooth curve from 30 to 100
                       // then continue from 100 to 120.
@end example

@c helpme: unsure how to translate these next two paragraphs
@noindent
前半部分では２つの直線に分けて記述していますが、これを１つの折れ線と
見なして、

@example
ctrl(7,0)
q C D
ctrl_pt(7,80)          // The midpoint of a line is set to 80.
E F
ctrl_to(7,60,15u,1)
@end example

@noindent
と書いても結果は同じになります。自由曲線の場合は、中間点のところで分割
すると、そこで傾きが不連続になるため、結果が違ってしまいます。

The commands  that specify the mid-point and end point do not generate the
individual control change events at the time of execution.
Instead, events will be generated, refered to as the mid-point and the 
end-point events. These are the continuous control change events.
They are converted to individual control changes during output processing
(@pxref{Output Process}) or
when the @code{ExpandCtrl} flag is specified in an effector
(@pxref{Defining Effectors}).
When the effector is detached, In the process, all events are sorted by time, and then output.

Some end points of previous continuous control change events can be the start of
another continuous change, the order in the source text does not matter.
To determine if events are ment for the same set of continuous control change
events, the following conditions are tested.
First,  the track number and extended controller numbers are the same.
The MIDI channel number is also the same when the extended controller number is 191 or less.
Furthermore, in the case of key pressure, the MIDI note number must also be the same.
If these conditions are not met, it is considered that the point belongs to another polyline / free curve.
Because of this, a continuous control change for more than 1 controller as in
the example below can be performed in parallel, it is handled without problems.

@example
ctrl(7,0) ctrl(1,100)
q C D
ctrl_to(7,40,15u,1) ctrl_to(1,0,15u,1)
@end example

Below  shows the description of each command.

@table @t
@item @r{C:} ctrl_to(@var{ctrl-num}, @var{value}, @var{tstep}, @var{threshold}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_to
@cindex Control change along a straight line
@cindex Control Change along a line
@cindex Time step size
@cindex Threshold
Generates an endpoint event for performing control changes along a line.
If a mid-point is assigned, the control changes will follow a free form curve,
otherwise, a straight line from the start to the end point is generated.

The Time of the end point event is (@code{t} + @code{dt}).
The MIDI channel number is @code{ch}.
Expansion controller number is @var{ctrl-num},
Control value is @var{value}.
The track number will be determined by the same rules as the @code{ctrl} command.
When @var{ctrl-num} is 129, IE, expansion control corresponding to key pressure,
any change to the MIDI note number is in @code{n}.
@var{ctrl-num} should be in the range 0 to 255.

The Time step size is @var{tstep} and Threshold is @var{threshold}.
Determines the fineness of when to send out  individual control change events.
@var{tstep} is the minimum time between adjacent events,
@var{threshold} sets the difference between changes in control events.
IE, the minimum interval between controlers.
@c helpme: unsure how to translate below footnote.
@footnote{
ただし、直線の開始点と終点との時間差が @var{tstep} の倍数になって
いない場合には、最初の２つのイベントにおける時間間隔
およびコントロール値間隔が指定した最小間隔より小さくなることがあります。}。
@var{tstep} is a positive rational number and @var{threshold} should be a number greater than 0.
@c helpme: unsure how to translate the rest of this paragraph.
PMMLインタンプリタは、まず @var{tstep} で指定される一定の時間間隔の
イベント列を想定し、そこから隣り合うイベントでの
コントロール値の変化が @var{threshold} 未満であるようなイベントを取り除き、
それを最終的なイベント列とします。
@var{threshold} に 0 を指定すれば、
常に一定の時間間隔でイベント列が生成されることになります。

@item @r{C:} ctrl_pt(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_pt
produces an intermediate point event for a continuous control change along a
broken line or free-form curve.
The Event time is (@code{t} + @code{dt}),
the MIDI channel number is @code{ch}.
The expansion controller number is @var{ctrl-num},
the control value is @var{value}.
The track number will be determined by the same rules as the @code{ctrl} command.
When @var{ctrl-num} is 129, IE, expansion control corresponding to key pressure,
note changes are reflected in the @code{n} register.
The expansion controller number  @var{ctrl-num} should be between 0-255.

@item @r{C:} ctrl_cto(@var{ctrl-num}, @var{value}, @var{tstep}, @var{threshold} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_cto
@cindex Control Change along a curve
@cindex Control Change along a free curve
@cindex Cubic curve
@cindex Quadratic curve
@cindex Sine curve
@cindex Exponential curve
@cindex Logarithmic curve
Generates an endpoint event for performing a control change along a free curve.
Starts with the starting point, moving through all the intermediate points in order, so as to reach the end point smoothly.
A curve is assumed, a row of control change events along with it are generated.
The curve generated is a cubic curve, which is defined for each section.
At each intermediate point you are guaranteed the continuity of the first derivative (IE slope).

The time of the end point event is (@code{t} + @code{dt}),
The MIDI channel number is @code{ch}.
The expansion controller number is @var{ctrl-num},
the control value is @var{value}.
The track number will be determined by the same rules as the @code{ctrl} command.
When @var{ctrl-num} is 129, IE, expansion control corresponding to key pressure,
Changes in the MIDI note number are reflected in @code{n}.
The Expansion controller number in @var{ctrl-num} should be between 0-255.

For info on the Time step size @var{tstep} and the threshold @var{threshold},
refer to the section of the above @code{ctrl_to} command.

The Initial slope @var{slope1} and the final slope @var{slope2} is the slope at the start point and end point,
specified in multiples for the slope of the line connecting the start and end points (which may be a floating-point number).
If it is omitted, it is assumed to be 0 (IE, horizontal).
Depending on these values, you can also get an exponential or logarithmic curve without using an intermediate point.
If there is no intermediate point in @var{slope1}=0 @var{slope2}=2,
it becomes a quadratic curve which looks like an exponential curve.
In the case of @var{slope1}=0 @var{slope2}=3,
It becomes a cubic curve looking more like a high exponential curvature.
If @var{slope1}=0 and @var{slope2}>3,
the curvature will be higher, but the overshoot will occur.
On the other hand,
@var{slope1}=2 @var{slope2}=0 will be a quadratic curve of logarithmic scale.
In the case of @var{slope1}=3 @var{slope2}=0,
It becomes a cubic curve looking more like a logarithmic curve.
Finally, @var{slope1}=0 @var{slope2}=0 will be from @minus{}90 to  90-degree intervals,
becoming almost a sine curve.

@item @r{SM:} bend_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend_to
@findex kp_to
@findex cpr_to
@findex vmag_to
@findex tempo_to
@findex rtempo_to
@findex mod_to
@findex breath_to
@findex foot_to
@findex pmtime_to
@findex vol_to
@findex pan_to
@findex expr_to
These were defined for each control, this is the standard macro in order to carry out the control change along a broken line.
Any of the standard macros will also be replaced by the @code{ctrl_to} command.
For the meaning of each controller, please see @ref{Control-Change Events}.
Although there is no argument for giving the step size and threshold time,
these are standard values that are defined for each controler.
Standard value of the time step size is @code{XxxStep},
standard value of the threshold is @code{XxxThreshold},
@code{Xxx} is the standard macro name above with the first letter uppercase,
@samp{_to} is added for the continuous controler macro.
In the initial state, @code{XxxStep} is, for any controller, @samp{15u},
@code{XxxThreshold}, for VmagThreshold and RTempoThreshold is 0.01,
For other controllers it is set to 1.
The user will be able to change these macro-type variables to another value.

@item @r{SM:} bend_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend_pt
@findex kp_pt
@findex cpr_pt
@findex vmag_pt
@findex tempo_pt
@findex rtempo_pt
@findex mod_pt
@findex breath_pt
@findex foot_pt
@findex pmtime_pt
@findex vol_pt
@findex pan_pt
@findex expr_pt
These are The standard Macros for generating a midpoint event, defined for each control.
Any of the standard macros will also be replaced by the @code{ctrl_pt} command.
For the meaning of each controller, take a look at @ref{Control-Change Events}.

@item @r{SM:} bend_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@findex bend_cto
@findex kp_cto
@findex cpr_cto
@findex vmag_cto
@findex tempo_cto
@findex rtempo_cto
@findex mod_cto
@findex breath_cto
@findex foot_cto
@findex pmtime_cto
@findex vol_cto
@findex pan_cto
@findex expr_cto
These are the standard macros in order to carry out the control changes along a free curve, defined for each control.
Any of the standard macros will also be replaced by the @code{ctrl_cto} command.
For the meaning of each controller, see @ref{Control-Change Events}.
Refer to the section of the above @code{bend_to} command for time step size and threshold.
@end table

@noindent
 You can also use @code{LASTVAL} as the @var{value} of each command.
For information about @code{LASTVAL} see @ref{Control-Change Events}. 
In addition, for each commands @var{modifiers} argument see @ref{Modifiers}.

@node Exclusive Events, Meta Events, Continuous Control Change, Event Generating Commands
@section Generation of exclusive events
@cindex Exclusive events
@cindex Exclusive message

There are three types of command to generate an exclusive message.

@table @t
@item @r{C:} excl(@var{array}) @r{[}@var{modifiers}@r{]}
@findex excl
At the time indicated by (@code{t} + @code{dt}) and on the track number @code{tk},
an exclusive message is generated.

The contents of the exclusive message is specified by the array @var{array}.
Each element of @var{array} must convert to a number.
Since the start of the message, 0xF0 and the end, 0xF7 will be automatically added,
do not include them in the array elements.
There is no limit to the length of the exclusive message.

When you create an exclusive message, each element will be multiplied by the bit mask 0x7F.
That is, except for the lower 7 bits of each element, the data will be ignored.

@subsubheading @code{excl} examples

@example
excl( #(0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x04, 0x64, 0x58) )
@end example

@item @r{C:} excl2(@var{array}) @r{[}@var{modifiers}@r{]}
@findex excl2
It is almost the same as @code{excl}, except that bit mask of 0x7F is not applied,
and that 0xF7 is not added to the exclusive message.
@c helpme: unsure how to translate the rest of this paragraph.
次の @code{arbit} と合わせて
長いエクスクルーシブメッセージを分割して送出したり、
（MIDIの規約には違反するが）最上位ビットが1のデータを
メッセージに含めたい場合に使用されます。

@item @r{C:} arbit(@var{array}) @r{[}@var{modifiers}@r{]}
@findex arbit
@cindex Any message
@cindex System common message
At the time specified by (@code{t} + @code{dt}) and on track @code{tk},
Generate the event to output any MIDI message.

Unlike the @code{excl} command, for each element of @var{array},
Bit mask is not applied.

The @code{arbit} command, combined with the @code{excl2} command, can be used to
split a long exclusive message into smaller chunks for better timing, as follows.

@example
excl2( #(0x41, 0x10, 0x42) )   // First start with excl2
r(s)
arbit( #(0x12, 0x40, 0x00) )   // use arbit for the second and subsequent times
r(s)
arbit( #(0x04, 0x64, 0x58, 0xf7) )  // Last 0xf7 needed
@end example

The @code{arbit} command can be used to handle any MIDI message that can not be
produced in other commands, such as system common messages.
@end table

@noindent
Take a look at the @ref{Modifiers} for the @var{modifiers} of each command.

@node Meta Events,  , Exclusive Events, Event Generating Commands
@section Generation of meta-events
@cindex Generation of meta-events

Use the following commands to generate meta events.
However, for the tempo setting, Please refer to @ref{Control-Change Events}.
All meta events use the time of (@code{t} + @code{dt}).

@table @t
@item @r{C:} seqno(@var{value}) @r{[}@var{modifiers}@r{]}
@findex seqno
@cindex Sequence number
Generate a sequence number meta-event.
The sequence number is @var{value},
If the MIDI format is 0 or 1, the event is placed on track 1,
or the value of @code{tk} will determine the track for format 2 output.

To comply with the MIDI specification, the event should always be at time 0.

@item @r{C:} text(@var{type}, @var{string}) @r{[}@var{modifiers}@r{]}
@findex text
@cindex Text events
Generate any kind of text event.
The track number is @code{tk},
the text classification number is @var{type},
the contents of the text is @var{string}.
The Text type number @var{type} must be between 1-15.

@item @r{SM:} title(@var{string}) @r{[}@var{modifiers}@r{]}
@findex title 
@cindex Song title
@cindex Title
Generate General text string of events (text events of type number 1) in Track 1
(however, generate on Track @code{tk}) when the output MIDI file is format 2.
It is used mainly to insert the song title string to a standard MIDI file.

@item @r{SM:} comment(@var{string}) @r{[}@var{modifiers}@r{]}
@findex comment
@cindex Comment
Generate general text string of events (text events of type number 1) to track @code{tk}.
It is used for insertion of a comment for a song into a standard MIDI file.

@item @r{SM:} copyright(@var{string}) @r{[}@var{modifiers}@r{]}
@findex copyright
@cindex Copyright notice
Generate a copyright display string event in track 1 (text events of type number 2).

@item @r{SM:} seqname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex seqname
@cindex Sequence name
Generate sequence or track name  event (text events of type number 3) on Track 1.
however, place on track @code{tk} when the output MIDI file is format 2.
This command is used to specify the name of a sequence.

@item @r{SM:} trackname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex trackname
@cindex Track name
Generate a sequence or track name event (text events of type number 3) on track @code{tk}.
This command is used to specify the track name.
The track name can be used to specify to the PMML compiler, what tracks to
generate with the @samp{-T} command-line option.

@item @r{SM:} instname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex instname
@cindex Instrument names
generate a musical instrument name event (text events of type number 4) to
track @code{tk}.

@item @r{SM:} lyric(@var{string}) @r{[}@var{modifiers}@r{]}
@findex lyric
@cindex Lyrics
トラック @code{tk} に
generate a lyrics event (text events of type number 5).

@item @r{SM:} mark(@var{string}) @r{[}@var{modifiers}@r{]}
@itemx @r{SM:} marker(@var{string}) @r{[}@var{modifiers}@r{]}
@findex mark
@findex marker
@cindex Marker
Generate Marker Events (text events of type number 6) to track 1. however, use
track @code{tk} when the output MIDI file is format 2.
Both @code{mark} and @code{marker} are the same macro.
You can use the PMML compiler's @samp{-f} and @samp{-t} command line options
when you want to specify a range to play, using marker names.

@item @r{SM:} cue(@var{string}) @r{[}@var{modifiers}@r{]}
@findex cue
@cindex Cue point
Generate a cue point event (text events of type number 7) on track @code{tk}.

@item @r{C:} end @r{[}@var{modifiers}@r{]}
@findex end
@cindex The end of the track
Generate an `End of track ' event. Track number will be @code{tk}.
You usually do not need to run this command since an `End of track ' event is
automatically added to the end of each track.
The @code{end} command is valid if you want to abort the performance of a 
certain track in the middle, since `End of Track' events are ignored after 
@code{end} is encountered.
@ignore
曲の最後に無音部分を残したい場合。
@code{end} コマンドがない限り、最後の音符のノートオフイベントが
曲の終りだと見なされますので、
曲の最後が休符であったり、あるいは最後の音符の
持続時間が音価より短かい場合には、
生成されるMIDIファイルは最後の小節だけ少し短い格好になってしまいます。
これが望ましくない場合には、最後の音符の後に @code{end} コマンドを置きます。
@end ignore

@item @r{C:} smpte(@var{hour}, @var{min}, @var{sec}, @var{frame}, @var{frac}) @r{[}@var{modifiers}@r{]}
@cindex SMPTE offset
@findex smpte
Generate a SMPTE offset event.
Generate on track number 1 (if the output MIDI file is format 0 or 1)
or @code{tk} (in the case of format 2).
The offset time is divided into the hour@var{hour}
and minute @var{min},
Seconds @var{sec},
Frame number @var{frame},
and frame number fractional part is @var{frac}.

@item @r{C:} timesig(@var{num}, @var{den}, @r{[}@var{metro}, @r{[}@var{div}@r{]]}) @r{[}@var{modifiers}@r{]}
@cindex Beat setting
@findex timesig
Generate a time signature setting event on Track number 1 (if the output MIDI
file is format 0 or 1), or track @code{tk} (in the case of format 2).

The Numerator @var{num} and denominator @var{den} is the numerator and denominator of the time signature appearing in the musical score.
@c helpme: unsure how to translate the rest of this paragraph.
メトロノーム周期 @var{metro} は 分母 @var{den} で表される
音符（例えば @var{den}が 4 なら４分音符）のいくつ毎に
メトロノームのクリックを鳴らすかを表します。
@var{metro} を省略すると 1 になります。
分割数 @var{div} はMIDIにおける４分音符がシーケンサーにおける32分音符の
何個分に相当するかを表し、通常は８に設定します（省略値も８です）。

If @var{num}, @var{den} and @var{div} is 0 or negative,
or if @var{metro} is negative,
it is an error. The warning is issued if the denominator @var{den} is not a power of two   ,
It will be modified to become a power of two.

Examples of some of the rhythm settings is shown below.

@example
timesig(4,4)       // @r{4/4 beat}
timesig(3,4)       // @r{3/4 beat}
timesig(2,4)       // @r{2/4 beat}
timesig(2,2)       // @r{2/2 beat}
timesig(6,8,3)     // @r{6/8 beat (3+3)/8 }
@c helpme: these comments marked by // need translating.
timesig(6,8,2)     // @r{6/8 beat (2+2+2)/8 の場合）}
timesig(12,8,3)    // @r{12/8 拍子（(3+3+3+3)/8 の場合）}
timesig(12,8,4)    // @r{12/8 拍子（(4+4+4)/8 の場合）}
timesig(5,8)       // @r{5/8 拍子}
@end example

When time signature is not set at time 0, automatically set a 4/4 time signature.

@item @r{C} keysig(@var{sharp-flats}, @var{mode}) @r{[}@var{modifiers}@r{]}
@findex keysig
@cindex Setting the tone
@cindex Key signature events
Generate a key signature event. Track number will be @code{tk}.

@var{sharp-flats} Is the number of sharps or flats appearing in the key signature,
Positive for number of sharps, negative for number of flats.
@var{mode} specifies the mode, 0 for major, 1 for minor.
For example, @code{keysig(1,0)} is g major, @code{keysig(-2,1)} is g minor.

The operation of the @code{keysig} command and the @code{key} register is
completely independent (@pxref{Key}).
Also, @code{keysig} does not effect operation of the @code{tp} register.
Therefore, if you have transposed the song by changing the @code{tp} register,
it is up to you to modify the argument of @code{keysig}.

@item @r{C:} meta(@var{type}, @var{array}) @r{[}@var{modifiers}@r{]}
@findex meta
@cindex Any of the meta-events
Generate any kind of meta-event.
The meta-event type number @var{type} must be between 0-127.
The data portion of the meta event is specified in the array @var{array}.
Each element of the array must convert to a numeric value.
Since the data length is calculated from the number of elements in @var{array},
you do not need to include the byte string representing the data length in the array elements.

Track meta events include.
@var{type} is 0x01 (sequence number), 
0x54 (SMPTE offset), 0x58 (time signature).
If the output MIDI file is not format 2, the events will be output to track 1,
regardless of the value of the @code{tk} register.
Otherwise, the value of the @code{tk} register is the track number.

@code{meta} should not be used to generate tempo events, use the command instead.

@c helpme: unsure how to translate this paragraph.
メタイベントの種別によっては、MIDIファイルの規約によってデータ長が
定められているものがあります。
これとは異なる長さのメタイベントを生成してもエラーにはなりませんが、
間違った標準MIDIファイルが生成されてしまうことになります。
@end table

@noindent
Take a look at the @ref{Modifiers} for @var{modifiers} of each command.

@c --------------------------------------------------------------------
@node Macros, Control Structures, Event Generating Commands, Top
@chapter Macros
@cindex Macro

Macros can be used to both assign easy-to-remember names to common patterns of a
piece, and to note numbers for rhythm instruments, or common tones used in a song.

@menu
* Types of Macros::             Variable and function macros
* Calling Macros::              How to call a macro
* Defining Variable Macros::    How to define a variable type macro
* Defining Function Macros::    How to define a function type macro
* Macro Examples::              Examples of function-type macros
* Local Macros::                Using the local macro
* Scope Rules::                 Rules for the scope of macros
* Scope Specifiers::            How to explicitly specify the scope of names
* Macro Directive::             When you can run a macro directive
* Eval Macro Directive::        Force evaluation of an expression
* Evalstr Macro Directive::     Evaluation of a string of the source text
* Undefining Macros::           Canceling a macro definition
* Examine Empty Token Lists::   Determine if a token is empty
* File Inclusion::              Reading of other source files
@end menu

@node Types of Macros, Calling Macros, Macros, Macros
@section Types of macros
@cindex Macros, kind of
@cindex Variable type macro
@cindex Function type macro
@cindex Thread macro
@cindex Local macro

The macros of PMML are classified in two ways.
One classification by function of macro,
And one classification by the scope of the macro.

@noindent
When you classify the macro by function, it results in the following two types.

@table @dfn
@item Variable type macro
This corresponds to a variable in other programming languages.
They cannot take arguments.
They are expanded faster than function type macros.
A variable type macro is defined by the assignment operator.
A variable type macro  can be associated with any data type (@pxref{Data Types}).

@item Function type macro
This is equivalent to a function in other programming languages.
It is slower than the variable type macro, but there are benefits, for example, they can be passed arguments.
In addition, only function type macros can have local macros declared within them.
A function type macro is defined using the @code{def} or @code{edef} commands.
A function type macro can only be assigned a token string as its data type.
@end table

@noindent
When classifying macros by scope, the following two types are available.

@table @dfn
@item Thread macro
This is a macro that is defined for each thread,
It is enabled only in the thread where the macro is defined and its descendant threads.
A thread macro that belongs to the root thread in particular is called a @dfn{global macro}, this is always in the global scope.

@item Local macro
This is equivalent to a local variable in other programming languages.
It is only valid during the lifetime of a function type macro.
When the macro expansion is finished it will automatically disappear.
@end table

@node Calling Macros, Defining Variable Macros, Types of Macros, Macros
@section Calling macros
@cindex Macro call

To call a variable type macro, just use it's name, as follows.

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name}
@end table
@findex @var{macro-name}

@noindent
@var{scope} specifies the scope where the macro can be found.
and can be omitted if the scope is current (@pxref{Scope Specifiers}).

In the case of a function type macro, a list of arguments in parentheses,
separated by commas, is placed after the macro name.
Even if there are no arguments, an empty set of parentheses @samp{()} are required.

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name}(@var{argument}, @r{@dots{}})
@end table

@noindent
When the number and types of arguments are different from the argument specification
(@pxref{Argument Spec}), it results in an error.
If the end of the argument list is finished by a comma, in other words,

@example
macro2(1,2,)
@end example

@noindent
the last comma is ignored.

@c helpme: unsure how to translate this paragraph.
トークン列型のデータに結び付いた変数型マクロと関数型マクロは、
式の中の演算数として呼び出された時の展開のされ方が異なります。
トークン列と結び付いた変数型マクロは、トークン列定数と同じように
扱われます。これに対して関数型マクロは、式を構成するトークンの一部として
展開されます。下の例を参照して下さい。

@example
x = '1 + 2'        // variable type macro x is associated with the token string
def(y) @{ 1 + 2 @}   // y is a function-like macro

x2 = x    // This is expanded as follows, eventually leading to the token string x2.
     @expansion{} x2 = '1 + 2' 

y2 = y()  // This is expanded as follows, eventually leading to the integer 3 in y2.
     @expansion{} y2 = 1 + 2 
     @expansion{} y2 = 3
@end example

@node Defining Variable Macros, Defining Function Macros, Calling Macros, Macros
@section Definition of variable type macros
@cindex Definition of variable type macros

The following command defines a variable type macro.

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name} = @var{expr}
@end table
@findex =
@findex @var{macro-name} = @var{expr}

@noindent
@var{scope} specifies the scope where the macro is defined
and can be omitted to define in the current thread (@pxref{Scope Specifiers}).
@var{macro-name} Is the name of the macro to be defined.
@var{expr} can be any type.
The calculation of macro expansions and expressions contained in the @var{expr} is performed at the time of macro definition,
The lead and @var{macro-name} is the result of the calculation.

@var{macro-name} does not have to be a previously defined macro.
In this case it will be re-defined.
However, other than a macro identifier (for example, a thread name)
It is an error if it has already been defined.

Definition of variable type macro is also possible,
In the same way as in the case of register changes, using the compound assignment operators as follows:

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name} @var{op}= @var{expr}
@end table
@findex @var{op}=
@findex @var{macro-name} @var{op}= @var{expr}

@noindent
The above command is equivalent to,

@example 
@r{[}@var{scope}@r{]}@var{macro-name} = @r{[}@var{scope}@r{]}@var{macro-name} @var{op} @var{expr}
@end example

@noindent
@var{op} is one of the following operators.

@example
+ - * / % shl shr & xor |
@end example

The following example will make the definition of the integer type, floating-point type and string type of the variable type macro.

@example
$v1 = 64
$v2 *= 1.5
song_title = "Simple song"

v=$v1 C4 D4 v=$v2 E4 F4
     @expansion{} v=64 C4 D4 v=96.0 E4 F4

title(song_title)
     @expansion{} title("Simple song")
@end example

@noindent
The example below is an example of using a expression of token string type.

@example
chord1 = '[C4 E4 G4]'
Violin = 'prog(41)'

Violin
     @expansion{} prog(41)
q chord1 i chord1 chord1
     @expansion{} q [C4 E4 G4] i [C4 E4 G4] [C4 E4 G4]
@end example

@node Defining Function Macros, Macro Examples, Defining Variable Macros, Macros
@section Definition of a function-like macro
@cindex Definition of a function-like macro

A function type macro is defined by the @code{def} or @code{edef} commands.

@table @t
@item @r{MD:} def(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{arg-spec}@r{]}) @{ @var{token} @dots{} @}
@item @r{MD:} edef(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{arg-spec}@r{]}) @{ @var{token} @dots{} @}
@end table
@findex def
@findex edef

@var{scope} specifies the scope of the macro,
and can be omitted to define in the current scope (@pxref{Scope Specifiers}).
@var{macro-name} is the name of the macro to be defined.
@var{arg-spec} Is a string that represents the macro argument specification
(@pxref{Argument Spec}).
The token string @var{token} @dots{} Is the definition of the macro.
Although there are Braces surrounding the token string, which could be confused
for the grouping of commands (@pxref{Grouping}),
they are simply intended to indicate the range of  the macro definition.
They do not appear in the results that have been replaced by the defined macro.

In the case of the @code{def} command, for the token string inside the curly braces,
Macro expansion at the time of definition, argument substitution and evaluation of macro directives
do not take place at all. these are described as the definition of an intact macro.
In contrast, the @code{edef} command performs argument substitution, @code{eval} and @code{evalstr} evaluation of macro commands only
are done at the time of definition.

The identifier does not have to be a previously defined macro. In this case,
re-definition will take place. However, other than the macro kind of identifier (for example, thread name)
it is an error if it has already been defined.

@menu
* Argument Substitution::       using macro arguments
* Argument Spec::               Writing the argument specification string
@end menu

@node Argument Substitution, Argument Spec, Defining Function Macros, Defining Function Macros
@subsection Argument substitution
@cindex Argument substitution
@findex $@var{number}
@findex $#
@findex $@@
@findex $*
@findex $$
@findex $[@var{expr}]

In the @code{def} or @code{edef} commands, if you use the following in the
token string enclosed in @samp{@{} and @samp{@}},
that part will be replaced by the contents of the argument when the macro is expanded.

@table @code
@item $@var{number}
is replaced by the contents of the @var{number} argument.
@var{number} Is an integer of 1 or more, you can not use an expression.
When @var{number} has exceeded the number of actual arguments,
if the argument is specified as optional, an empty argument is returned.
It is an error if it is not.

@item $#
is replaced by the number of macro arguments.

@item $@@
 is replaced by the list of all the arguments separated by commas.

@item $[@var{expr}]
The value of the expression @var{expr} is calculated, it is replaced with the contents of the value's argument.
When the value of @var{expr} has exceeded the number of actual arguments,
Similar to $@var{number},
if the argument is specified as optional, an empty argument is returned.
It is an error if it is not.

@item $*
It is replaced by an array of macro arguments.
Expressions like @samp{$*[@var{expr}]} can be used to retrieve arguments from the array.
When the value of @var{expr} has exceeded the number of arguments, it is always an error.

@item $$
it is replaced by the @samp{$} itself.
It is mainly used in the @code{edef} command to refer to arguments (@pxref{Macro Examples}).
@end table

@node Argument Spec, Argument Substitution, Defining Function Macros
@subsection The argument specification string
@cindex The argument specification string

The second argument in the @code{def} or @code{edef} commands is called the
argument specification string, it represents the types of the macro arguments.
The argument specification string is optional, the default is @t{"q*"}.
 To define a macro that takes no arguments, you should specify @t{""} as the
argument spec.
Note that when calling such a macro, the set of empty parentheses @samp{()} is
required.

An argument specification string can be any of the following characters,
one character for each argument.

@table @asis
@item @code{q} --- No evaluation token string (Quoted token list)
implements the method of argument passing, which is referred to as the so-called lazy evaluation.
It is possible to put any  token string as an argument, it does not matter even if it is empty.
The argument token string will be passed directly to the macro as a token string.
However, before it is passed to the macro, argument substitution, @code{eval}
and @code{evalstr} evaluation of macro commands Takes place. Macro expansion 
and evaluation of macro commands other than these will not be performed.

@c helpme: unsure how to translate this paragraph.
マクロ定義の中において、この方法によって受け渡されたトークン列を
式の演算数として参照したときは、関数型マクロの展開と同じように、
式を構成するトークンの一部として展開されます(@pxref{Calling Macros})。

@item @code{i} --- Integer
An integer, rational, or floating-point type expression is received as an argument,
which in the case of a non-integer type is automatically converted to an integer (@pxref{Type Conversion}).
Evaluation of the expression will be done at the time of the call. That is,
expansion of a macro contained in the argument when calling the macro, register references,
and calculation of equations is carried out, which will be past to the macro as an integer.

@item @code{f} --- Floating-point Number
An integer, rational, or a floating-point type expression is received as an argument,
Any non-floating point type number is automatically converted (@pxref{Type Conversion}).
Evaluation of the expression will be done at the time of the call.

@item @code{r} --- Rational Number
An integer, rational, or floating-point type expression is received as an argument,
Automatic conversion in the case of  a non-rational type
is automatically carried out (@pxref{Type Conversion}).
Evaluation of the expression will be done at the time of the call.

@item @code{n} --- Numeric value (Number)
Receives an integer, rational, or a floating-point type expression as an argument.
Type conversion does not take place.
Evaluation of the expression will be done at the time of the call.

@item @code{s} --- Character string (String)
will receive a string type expression as an argument.
Evaluation of the expression will be done at the time of the call.

@item @code{p} --- Numeric or string (Primary Data)
receives an integer, rational, a floating-point or string type expression, as an argument.
Evaluation of the expression will be done at the time of the call.

@item @code{a} --- Array
receives an expression of array type as an argument.
When the macro is called, for each element, macros are expanded and expressions
are evaluated.

@item @code{t} --- Token List
receives a token string type expression as an argument.
Evaluation of the expression will be done at the time of the call.

Within a macro definition, the token string that was passed by this method
When you see as an operand of expression, as in the deployment of variable type macros,
it is treated in the same way as the token string constants (@pxref{Calling Macros}).

@item @code{e} --- Any type of expression (Expression)
Receives any type of expression as an argument.
Evaluation of the expression will be done at the time of the call.

@item @code{l} --- Loop Variable
It is a special argument specification to pass as an argument, the name of a
loop variable to be used in the @code{for} or @code{foreach} commands.
useful in cases such as, @samp{def(for10, "l") @{ for($1,1,10) @}}.
@end table

@noindent
You can include the following characters in addition to the above characters for further options.

@table @asis
@item @code{:} ---  Option specified
Indicates that the subsequent arguments are optional.

@item @code{*} --- repeated argument
Means zero or more occurrences of the previous argument.
You must always place this at the end of the argument specification string.
@end table

@noindent
For example,

@example
def(macro1, "n:qs*") @{ @dots{} @}
@end example

@noindent
If called, @code{macro1} should be past a number as it's first argument,
A token string as it's second argument, and a character string as it's third
argument. Furthermore, the ":" after the first argument indicates that further
arguments are optional.

@node Macro Examples, Local Macros, Defining Function Macros, Macros
@section Function type macro examples
@cindex function type macro examples

@subsubheading Definition of an accompaniment pattern

The example below is a macro that defines the accompaniment of a simple waltz.
Three arguments are past into the macro on each call, which are treated as follows.
The first argument is played with an accent, then the second and third arguments
are combined into a chord and repeated twice. They are also played in a stacato
fashion. The note length  is also set to a quarter note at the start of the macro.
Because any token can be past as an argument, octaves can be specified, as in the
last call.

@example
def(waltz) @{
  q $1++ @{dr=30 [$2 $3] [$2 $3]@}
@}
waltz(C, E, G)
waltz(_B, F, G)
waltz(C, E, G)
waltz([_C C], E, G)
@end example

@subsubheading Example of a note modification macro

The next macro, called @code{grace}, adds a grace note one semitone under the given note.
The bass note length is shortened with @samp{$1(l -= z)}, but only for the note
within the macro.

@example
def(grace) @{
  note(n=$1-1    // The grace note, 1 semitone below the argument.
        v *= 0.5       // Velocity is half of the given value
        z )            // The note length is a 32nd note.
  $1(l-=z)         // The basic tone
@}
grace(c4)
@end example

@noindent
@c Helpme: unsure how to translate this paragraph.
上の例では装飾音の先頭がもともとの発音タイミングに一致していますが、
逆に基本音の先頭を一致させたい場合には下のようにします。
ただし、装飾音が１つ前の音と重なって発音される可能性があります。

@example
def(grace) @{
  note( n = $1 - 1; v *= 0.5; z; dt -= z ) &      
  $1       // The basic tone
@}
@end example

@subsubheading Definition of arithmetic functions

The example below is a macro that squares the value of the argument.  parentheses surrounding Results are necessary,
If they are not, @samp{1 / sqr($x)} would expand to @samp{1 / $x * $x}.
The end result would be incorrect. The expression is performed when the macro is
expanded,
Since @t{"n"} is used, @samp{(($1) * ($1))} You do not need that.

@example
def(sqr, "n") @{
  ($1 * $1)
@}
@end example

@subsubheading Recursive call of a macro
@cindex recursive call of a macro

Macros can also be  called recursively. The example below, using recursion,
is to calculate the Fibonacci numbers.

@example
def(fib, "n") @{
  if( $1 < 2 )  @{ 1 @}
  else @{ (fib($1-1) + fib($1-2)) @}
@}
@end example

@subsubheading @code{edef}, Examples of use
@cindex @code{edef}, Examples of use
@findex edef

Below, in order to define a macro for the Control Change,
the @code{edef} command was used.

@example
def(defcontroller, "qn") @{ 
  edef($1) @{ ctrl($2, $$1) @}
@}
@end example

@noindent
If you define a  volume controller using this macro,  it looks like the following.

@example
defcontroller(vol, 7)
     @expansion{} def(vol) @{ ctrl(7, $1) @}
@end example

@noindent
In @code{edef}, @samp{$$1} was used
in the definition of the @code{defcontroller} macro to reference the first 
argument of the macro being returned.
If @samp{$1} had been used instead, it would have expanded as follows.

@example
def(defcontroller2, "qn") @{ 
  edef($1) @{ ctrl($2, $1) @}
@}

defcontroller2(vol, 7)
     @expansion{} def(vol) @{ ctrl(7, vol) @}
@end example

@node Local Macros, Scope Rules, Macro Examples, Macros
@section Local macros
@cindex Local macro
@findex local

A local macro is a valid macro only during the deployment of  a function type macro.
When the macro expansion is finished it will automatically disappear.
Local macros are useful when you need temporary macros during the execution of
another, main macro, and do not want to risk name conflicts with other global macros or thread
macros.

A local macro is defined by placing the scope specifier @samp{local::} in
front of the macro's name.
@samp{local::} is only necessary when you first define the macro, when you call
or redefine the macro, it is not needed.
However, it is no problem to add  @samp{local::} to all occurrences of the macro.

The following example is a macro to compute the square sum of two numbers,
written using local macros. for example, @code{sqr_dist(1,2)} will return 5 when it is called.
Because @code{$t} and @code{sqr} are local macros, the names can be used without
worrying about name conflicts.

@example
def(sqr_dist, "nn") @{
  local::$t = 0          // Local macro (variable type)
  def(local::sqr, "n") @{ // Local macro (function type)
     ($1 * $1) 
  @}

  $t += sqr($1)
  $t += sqr($2)
  $t                     // This corresponds to the return value of the function
@}
@end example

A Local macro is valid only within the macro that defines it. That is,
a local macro cannot be called from another macro, the call becomes invalid.
Look at the example below.

@example
def(macro1) @{
  local::$x = 2      // Define the local macro called $x
  macro2()
  print($x)          // Since this $ x is a local macro above
                     // Here 2 is output
@}

/* macro2 is called from within macro1 */
def(macro2) @{        
  print($x)          // This $ x is not a local macro above
                     // $ X references a global macro
                     // Here 5 is output
@}

$x = 5
macro1()
@end example

When you pass The name of a local macro into a macro using the @t{"q"} argument specification,
the above rules for macro scope no longer apply.
the reference to the name of the local macro will be replaced  before calling.
Thus, the @code{swap} macro shown below performs as expected.

@example
def(swap, "qq") @{    // exchange the values of the two macros.
  local::$tmp = $1    // $ 1 is not named $ x, the reference to it
                      // Since replacement are, 5 is obtained.
  $1 = $2
  $2 = $tmp
@}

def(macro1) @{
  local::$x = 5
  local::$y = 7
  swap($x, $y)
  print($x, $y)
       @print{} 7 5
@}

macro1()
@end example

@node Scope Rules, Scope Specifiers, Local Macros, Macros
@section Macro scope rules
@cindex scope rules

When you go to call a macro in a thread, without a scope specified by @var{scope},
the macro is checked for in several places, starting with the current thread's
thread macros, and then it's ancester threads.
If not found there, the macro is searched for in the following places, with the
highest priority macro being run as shown below.

@display
(Highest)
Local macro
Of the current thread thread macro
Thread macro of the current thread of parent thread
  :
  :
Root thread of thread macro (global macro)
(Lowest)
@end display

On the other hand, when the macro is being defined, in case you did not put the scope specified
defined behavior is as follows.

@itemize @bullet
@item
If a local macro of the same name already exists,
redefine the local macro.

@item
If a thread macro exists with the same name in current thread,
redefine the thread macro.

@item
In other cases, define a new thread macro in the current thread.
@end itemize
@noindent
By defining a thread macro ancestors thread
Note that there is no. For example, in the example below
 there are three points in which @code{$x} is defined
Each point will mean another macro is called.

@example
$x = 1 
@{ $x = 2 
  print($x)     @print{} 2
@}        
print($x)     @print{} 1
@{ $x += 2       // Same meaning as $x = $x + 2 
  print($x)     @print{} 3
@}
print($x)     @print{} 1
@end example

If you want to call or define a macro with  a different scope from those of the default scope,
you use the scope specification described in the next section.

@node Scope Specifiers, Macro Directive, Scope Rules, Macros
@section Scope specification
@cindex Scope
@cindex Scope specification
@findex local
@findex global
@findex .
@findex ..
@findex ...

If you use a scope specifier identifier, which is different from the default of the generic range
you can make a reference / define for identifier of the generic range.
A Scope specification is one of the following.

@table @t
@item local::
specify a local macro.

@item @r{[}global@r{]}::
Global identifier, IE, specify the identifier belonging to the root thread of a dictionary.
@code{global} is optional, does not change the meaning even without.

@item @r{[}@var{thread-path}@r{]}@var{thread-name}::
Specify the identifier belonging to the specified named thread of a dictionary.
The Thread name @var{thread-name} can be a thread at any part of the thread tree.
If you have more than one thread with the specified name,
the closest thread specified by @var{thread-name} at the current level, or any of the thread's ancesters is chosen.
If the thread  @var{thread-name} is not found in the thread's ancesters, then behaviour is undefined.
Use The @var{thread-path} in order to avoid such ambiguity.
There is a need to show until the thread that you specify the path (path).
To indicate a path, among the ancestors of the thread to be specified
First, write the name of the uniquely can be specified thread,
Then you side by side while separate the Jun'niko thread name in @samp{::}.
If the path contains unnamed thread, you can write to the exclusion of it.
You start at the beginning @samp{::} if you want to describe the path from the root thread.

@item .::
Specify the identifier belonging to the current thread of a dictionary.

@item ..::
Specify the identifier belonging to the parent thread of a dictionary.

@item ...::
Specify the identifier belonging to the nearest named thread of a dictionary in the ancestor thread.
@end table

@subsubheading Scope specifier examples

@example
$x = 1             // Global macro
defthread(t1)
t1 @{ 
   defthread(t2)   // t2 child thread of t1
   $y = 3          // t1 thread macro
   ::$x = 5        // Redefinition of global macro
   t2 @{
     $z = 7        // t2 thread macro
   @}
@}

t1::$y += 1        // redefinition of t1 thread macro
::t1::$y += 1      // Same as above
t2::$z = 9         // redefinition of t2 thread macro
::t1::t2::$z = 9   // Same as above
@end example

@node Macro Directive, Eval Macro Directive, Scope Specifiers, Macros
@section Macro directives
@cindex Places where you can use macro instructions
@cindex Places where you can use argument substitution
The macro commands and built-in functions as described in @ref{Commands} are
available in expressions, however, they can not be used at any arbitrary
position in an expression. In addition, the locations that argument substitution can also be used  are limited.
The available locations for these are listed below.

@enumerate
@item 
Locations for Macro instructions, and built-in functions other than @code{eval}and @code{evalstr}

@itemize @bullet
@item
The position of a general command
@item
The number of operations position of expression.
@item
@code{null} as an argument of the macro instruction.
@item
Arguments of @code{defeff} and @code{case} commands,
Also, @code{ecode}, @code{set_thru_etypes},
@code{set_eff_etypes}, @code{add_eff_etypes}, @code{del_eff_etypes}, 
Location of the event type name that appears in the argument.
In addition, the controller number followed by the event type name, meta-event type number,
Location of text type number.
@item 
MIDI channel number locations that appear in the argument of
@code{set_thru_chs}, @code{set_eff_chs}, @code{add_eff_chs} 
and @code{del_eff_chs} commands.
@item
The effector name argument of the @code{attach} command.
@end itemize

@item
Locations where @code{eval} and @code{evalstr}, as well as argument substitution are valid

@itemize @bullet
@item 
All locations mentioned in item 1
@item
A macro argument with the @t{"q"} Argument specification.
@item
Between the @samp{@{} and @samp{@}} of the @code{edef} instruction
@item
@c helpme: unsure how to translate this item.
@code{def}、@code{undef} など識別子を引数として受けとる
マクロ指令または組み込みマクロにおける識別子の場所。
@item
Assignment operator, the left-hand side of the variable type macro definition by compound assignment operators.
@item
Position other than @samp{::} in scope specification.
@item
within a token string constant that is enclosed in back quotes.
@end itemize
@end enumerate

@noindent
Position and of the operator, at the position of the parentheses around the argument or modifier
Macro directive Note that you can not use.

@example
// Example that causes an error

plus = '+'
$x = 1 plus 5

velup = '(v+=10)'
C velup
@end example

@noindent
However, it is possible with the following macro definition.

@example
plus1 = '1 +'
$x = plus1 5

velup = 'v+=10'
C(velup)
@end example

@node Eval Macro Directive, Evalstr Macro Directive, Macro Directive, Macros
@section @code{eval} Macro instruction
@findex eval
@cindex Force evaluation of an expression

The @code{eval} instruction takes an expression which, instead of being 
evaluated in the normal way, is evaluated immediately and it's result returned.

@table @t
@item @r{MD:} eval(@var{expr})
@end table

@noindent
@code{eval} is available when you want to place part of an expression in an 
@code{edef} instruction, in backquotes. like this.

@example
$x = 'v+=10'
$y = `n=3 eval($x)`

dumpdef($y)     // display the definition of $ y
     @print{} ::$y = 'n = 3 v += 10'

n = 60
$z = `n=eval(n + 1)`
dumpdef($z)
     @print{} ::$z = 'n = 61'
@end example

@noindent
Below is an example of using @code{eval} in the left-hand side of a variable type macro definition.
When such evaluation result of the expression has become token column, @code{eval} is
But it does not want to further evaluate the token column. To do it
There is the need to double or more @code{eval}.

@example
$x = '$y'
$y = '$z'

eval($x) = 5
     @expansion{} $y = 5

print($y)
     @print{} 5

$y = '$z'

eval(eval($x)) = 6
     @expansion{} $z = 6

print($z)
     @print{} 6
@end example

@noindent
It can also be used in combination with an array as follows.

@example
$table = #('one', 'two', 'three')
for($i, 1, #$table) @{
  eval($table[$i]) = $i
@}
     @expansion{} one = 1  two = 2  three = 3
@end example

@node Evalstr Macro Directive, Undefining Macros, Eval Macro Directive, Macros
@section @code{evalstr} Macro instruction
@findex evalstr

@code{evalstr} is  a macro instruction  that considers the given string as PMML source text.
The format is as follows.

@table @t
@item @r{MD:} evalstr(@var{string})
@end table

@noindent
The string @var{string} will be divided into tokens as returned to the lexical analyzer.
The macro command above will be replaced with the token string.
For example,

@example
$x = "c" + "4"      // $ X becomes the string "c4"
evalstr($x)
@end example

@noindent
Is,

@example
c4
@end example

@noindent
Which will be interpreted as a note command.

The @code{evalstr} command is often used in a macro definition to specify the name of the macro by string.
Since the evaluation of @code{evalstr} is done in The left-hand side of the 
first argument  of @code{def}, and the left-hand side of the assignment operator,
you can specify the name of the macro in the string.

@example
$base = "expr_"
$opr = "mlt"

/* Macro definition that specifies the name of the macro in the string */
def(evalstr($base + "add"), "nn") @{ ($1 + $2) @}
def(evalstr($base + "mlt"), "nn") @{ ($1 * $2) @}

print(expr_add(5,7))
     @print{} 12

/* Macro call that specifies the name of the macro in the string */
$x = evalstr($base + $opr) (5,8)

print($x)
     @print{} 40
@end example

@node Undefining Macros, Examine Empty Token Lists, Evalstr Macro Directive, Macros
@section Undefining macros
@cindex undefining macros
@findex undef

In order to cancel a macro definition, use the @code{undef} macro instruction.

@table @t
@item @r{MD:} undef(@r{[}@var{scope}@r{]}@var{macro-name})
@end table

@var{scope} specify the scope of the macro
which can be omitted if scope is current (@pxref{Scope Specifiers}).
@var{macro-name} Is the name of the macro to cancel.

If @var{macro-name} was the name of a built-in function,
this means to disable the built-in functions. Thus, it is possible to re-define the meaning of a built-in function.

@code{undef} can also be used to remove threads or communication channels, as 
well as macros. Please see their respective chapters for more information.

@node Examine Empty Token Lists, File Inclusion, Undefining Macros, Macros
@section testing for an empty token string
@cindex testing for an empty toeken string
@findex null

@code{null} will test whether a token string is empty.

@table @t
@item @r{MD:} null(@var{token} @dots{})
@end table

Macro expansion, argument substitution and macro commands are executed Against
the token string @var{token} @dots{}.
The command returns 1 if the token string is found to be empty,
otherwise it will return 0.
It is often used to test for the presents of arguments, as follows.

@example
def(mac1, "q:q") @{
  if( null($2) ) @{    // $# < 2 But good
    print("The 2nd argument does not exist")
  @} else @{
    print("The 2nd argument exist")
  @}
@}
@end example

@node File Inclusion,  , Examine Empty Token Lists, Macros
@section @code{include} Macro instruction
@cindex Loading files
@findex include

The @code{include} macro directive reads the PMML source text from the specified
file, embedding the contents to the location of the @code{include} statement.

@table @t
@item @r{MD:} include(@var{filename})
@end table

@var{filename} is an expression of type string that represents the name of the file to be read.
In the case of ms-dos/windows only, it may contain a Directory path or drive specification.
If @var{filename} contains the extention @samp{.pml} it can be omitted.

The search path (@pxref{Environment}) is referenced to find the file, including
the current directory and the library path.
It is an error if the file is not present.

@code{include} statements can also be nested, that is, included files can also
have @code{include} statements and they are processed correctly.

@subsubheading @code{include} examples

@example
include("gs")         // Reading the library for the GS sound source
include("drums")      // Read macro library for rhythm description  
@end example

@c --------------------------------------------------------------------
@node Control Structures, Arrays, Macros, Top
@chapter Control structures

This chapter describes the commands for conditional branching and iteration.
All of these commands have been implemented as a macro instruction.
Therefore, You can use these at the location of the operand of an expression as stated in @ref{Macro Directive}.

@menu
* Conditionals::                Commands for conditional branching
* Loops::                       Commands for iteration
@end menu

@node Conditionals, Loops, Control Structures, Control Structures
@section Commands for conditional branching
@cindex Conditional branching

There are two types of  conditional branching command, @code{if} and @code{switch}.

@menu
* If Command::                  Selects a token string based on a condition
* Switch Command::              Multiple branching
@end menu

@node If Command, Switch Command, Conditionals, Conditionals
@subsection @code{if} command
@findex if

@code{if} is a macro command to select a different token string depending on the conditions.
The format is as follows.

@table @t
@item @r{MD:} if(@var{expr1}) @{@var{tokens-1}@} @r{[}elsif(@var{expr2}) @{@var{tokens-2}@}@r{]} @dots{} @r{[}else @{@var{tokens-n}@}@r{]}
@end table

If the expression @var{expr1} is true (@pxref{Logical Values}),
the token string @var{tokens-1} is selected.
If the expression @var{expr1} is false or @var{expr2} is true,
the token string @var{tokens-2} is selected (hereinafter the same).
If all expressions are false, the token string @var{tokens-n} is selected.
The @code{elsif} and @code{else} clauses are optional.

The Braces to enclose the token string @samp{@{ @}} are needed in all cases.
Please note. You can not write, @samp{if( x == 1 ) y += 1}, as in the C language. 
It must be written @samp{if( x == 1 ) @{ y += 1 @}}.

@subsubheading @code{if} examples

@example
/* To produce one of the notes of the two depending on the value of $ t */
if( $t == 1 ) @{ g4 @} else @{ d4 @} 

/* Place an accent on the C4 note if $i is non-zero. */ 
c4(if($i)@{++@})     // c4 if($i)@{++@} is not allowed.

/* Using if as part of an expression. */
v = 20 + if( v > 40 ) @{ 40 @} else @{ v @}
@end example

@node Switch Command,  , If Command, Conditionals
@subsection @code{switch} command
@findex switch
@cindex Multiple branches

@code{switch} selects a token string based on a condition, which can be one of several branches.
The format is as follows.

@table @t
@item @r{MD:} switch(@var{expr}) @{ case(@var{val1}, @var{val2}, @dots{}) @{@var{tokens-1}@} @dots{} @r{[}default @{@var{tokens-n}@}@r{]} @}
@end table
Based on the value of @var{expr}, chooses one of the token strings among
@var{tokens-1} @dots{} @var{tokens-n}. 
The @var{expr} argument of @code{case}  is tested against @var{val1}, @var{val2}, @dots{},
and the one which matches determines the token string returned by @code{case}.
If there is more than one match for @code{case} the earliest takes pressidants.
If there is no matching @code{case} argument, the token string following a @var{tokens-n} with a value of @code{default} is selected.
@var{expr} can be any data type.
The @code{case} arguments for @var{val1}, @var{val2}, @dots{} can also be any type of expression.

@subsubheading @code{switch} examples

@example
switch($x) @{
  case(1,2) @{
    print("Hi")                 // Printted if $x is 1 or 2
  @}
  case(1,3) @{
    print("How are you?")       // Executed if $x is 3
  @}
  default @{
    print("Nice to meet you.")  // This is executed if $x is any other value.
  @}
@}

switch(1) @{
  case($x < 0)  @{ $y = 1 @}    // A case argument can also be an expression
  case($x == 0) @{ $y = 0 @}
  case($x > 0)  @{ $y = -1 @}
@}
@end example

@node Loops,  , Conditionals, Control Structures
@section Commands for iteration
@cindex repeat
@cindex loop

there are 4 commands available for repetition,@code{repeat}, @code{while},
@code{for} and @code{foreach}.
The @code{break} command can be used to exit repetition.

@menu
* Repeat Command::              repeat a specified number of times
* While Command::               Repeat while conditions are met
* For Command::                 Repeat while changing the value of a counter
* Foreach Command::             Repeat for each element of an array
* Break Command::               Exit from a loop
@end menu

@node Repeat Command, While Command, Loops, Loops
@subsection @code{repeat} command
@findex repeat
@code{repeat} is a macro instruction to repeat the token string a specified number of times.

@table @t
@item @r{MD:} repeat(@var{expr}) @{ @var{tokens} @}
@end table

@noindent
Repeat the given token string the number of times indicated by @var{expr}. 
If the value is 0 or less, replace with an empty token string.

@node While Command, For Command, Repeat Command, Loops
@subsection @code{while} command
@findex while
@code{while} is a macro instruction that repeats the given token string while
a condition is true.

@table @t
@item @r{MD:} while(@var{expr}) @{ @var{tokens} @}
@end table

@noindent
 The token string @var{tokens} is repeated while the expression @var{expr} is true (@pxref{Logical Values}).
The empty token string is returned if @var{expr} is false at the start of the loop.
If the value of @var{expr} is true, and never becomes false, the compiler will ,
become stuck in an infinite loop.
The Braces to enclose the token string @samp{@{ @}} are necessary in all cases.
Please note, you cannot write, as in the C language, @samp{while( x < 1 ) x += 1}, 
Instead, you need to write @samp{while( x < 1 ) @{ x += 1 @}}.

@subsubheading @code{while} example

@example
/*Play a c4 note repeatedly with velocities of 40, 50, 60 and 70. */
v = 40
while( v <= 70 ) @{
  c4
  v += 10
@}
@end example

@node For Command, Foreach Command, While Command, Loops
@subsection @code{for} command
@findex for

@code{for} is a macro instruction to repeat the token string while changing the
value of  a variable type macro (called the loop variable).

@table @t
@item @r{MD:} for(@r{[}@var{scope}@r{]}@var{macro-name}, @var{from}, @var{to} @r{[}, @var{step}@r{]}) @{ @var{tokens} @}
@end table

@noindent
The @var{macro-name} and @var{scope} are the scope specifier and the name of the loop variable.
If @var{scope} is omitted, and @code{for} is being used in a function-like macro,
@samp{local::} is assumed as the scope specifier.
In other words, it is treated as a local macro as long as the loop variable is otherwise specified.
The starting point @var{from}, ending point @var{to} and step value @var{step}
must all be integer expressions. @var{step} is assumed to be 1 if omitted.

The behavior of @code{for} is as follows.
The loop variable starts with the value of @var{from},
and will move between that and the value of @var{to}, increasing (or decreasing
if negative) by the value of @var{step}.
Each time, the token string in @var{tokens} is executed.
If @var{from} > @var{to} is true, or if @var{step} is negative, @var{from} < 
@var{to} is true, an empty token string is returned and the loop does not execute.

If necessary you can change the value of the loop variable in the loop.

The loop variable will remain without  being erased after you exit the loop.
Aside from the case where @code{break} is used, the loop variable will have 
the value before @var{to} is exceeded, or lower than @var{to} if @var{step} is
negative.
If @code{break} is used to exit the loop, the value of the loop variable will be
it's value at the time @code{break} was run.

@subsubheading @code{for} examples

@example
for($i,1,3) @{ print($i) @}
     @print{} 1
     @print{} 2
     @print{} 3
for($i,3,1,-1) @{ print($i) @}
     @print{} 3
     @print{} 2
     @print{} 1
for($i,1,4,2) @{ print($i) @}
     @print{} 1
     @print{} 3

x = #(for($i,1,8) @{$i,@})         // initialize an array in one operation.
print(x)
     @print{} #(1,2,3,4,5,6,7,8)

/* Menuett   J.S. Bach */
for($i,1,2) @{
  q ^D i G A B ^C q ^D G G 
  q ^ E i C D E F# q G _ G G 
  q ^C i ^D ^C B A q B i ^C B A G 
  if( $i == 1 ) @{
    q F# i G A E G h. A	         // the first iteration
  @} else @{
    q A i B A G F# h. G          // The second iteration
  @}
@}
@end example

@node Foreach Command, Break Command, For Command, Loops
@subsection @code{foreach} command
@findex foreach

The @code{foreach} macro instruction repeats a token string, with a loop 
variable being set to each element of an array.

@table @t
@item @r{MD:} foreach(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{array}@r{]}) @{ @var{tokens} @}
@end table

@noindent
@var{macro-name} and @var{scope} are the name of the loop variable with a scope
specifier. If @var{scope} is omitted, and @code{foreach} is used in a function-like macro,
@samp{local::} is assumed as the scope specifier.
In other words, it is treated as a local macro as long as the loop variable is otherwise specified.

@code{foreach} sets the loop variable to each element of @var{array} in order,
each time executing the token string @var{tokens}.
If the array reference @var{array} is omitted, the array @samp{$*} is assumed.
If the size of the array is 0, an empty toeken string is returned and the loop
is not executed.

The loop variable will remain without being erased after the loop.
Except in the case where @code{break} is used to exit the loop, the loop
variable will be set to the last element of @var{array}. If @code{break} is used
to exit the loop, the loop variable will be set to the element where the loop
was stopped when @code{break} was called.

@subsubheading @code{foreach} examples

@example
$a = #("one", "two", "three")
foreach($i,$a) @{ print($i) @}
     @print{} one
     @print{} two
     @print{} three

foreach($i, #(10,20)) @{
  print($i)
@}
     @print{} 10
     @print{} 20

def(printall) @{
  foreach($i) @{ print($i) @}    // If you omit the name of the array
@}

printall(5,6,7)
     @print{} 5
     @print{} 6
     @print{} 7
@end example

@node Break Command,  , Foreach Command, Loops
@subsection @code{break} command
@cindex exiting from a loop
@findex break

The @code{break} macro instruction exits from repetition commands (@code{repeat}, @code{while}, 
@code{for}, @code{foreach}, and the alternation command @code{alt}(@pxref{Alternation})).

@table @t
@item @r{MD:} break@r{[}(@var{level})@r{]}
@end table

@noindent
If you simply write @code{break}, immediately ignore the rest of the loop for
the innermost loop.
If you specify @var{level}, exit the loop at that level of execution and continue.

If @code{break} is called from  a different thread to the one that initiated a
looping command, and the thread where @code{break} is called is a decendent
of the loop thread, created by grouping commands (@pxref{Grouping}), not
involving @samp{&}, the loop will be exited. See the last example below.

@subsubheading @code{break} examples

@example
$x = 0
while( $x != 3 ) @{
  print($x)
  if( $x == 1 ) @{ break @}
  $x += 1
@}
     @print{} 0
     @print{} 1

for($i,1,3) @{
  for($j,1,3) @{
    print($i, $j)
    if( $i == 2 && $j == 1 ) @{ 
      break(2)       // exit the outer loop
    @}
  @}
@}
     @print{} 1 1
     @print{} 1 2
     @print{} 1 3
     @print{} 2 1

for($i,1,2) @{
  C D
  @{                // Generation of child thread
    v=80 E F
    if( $i == 2 ) @{ break @}   // Different thread, but exit possible
  @}
  G A
@}
@end example

@c --------------------------------------------------------------------
@node Arrays, Built-in Functions, Control Structures, Top
@chapter Array operations
@cindex array

PMML has dynamic arrays, who's size can increase or decrease as required.
An array can have any type of data element, it does not matter even if the data type is different for each element.
An array can also contain other arrays, so that a two or more dimentional 
arrays can be expressed easily.
The following sections will describe the macro instructions, operators and
built-in functions to manipulate arrays.

@menu
* Array Subscripting::          writing subscripts and accessing elements
* Array Size::                  How to get the size of the array
* Array Expansion::             How to deploy an array in the argument list
* Duplicating Arrays::          How to duplicate the array
* Element Replication::         How to initialize an array with the same elements
* Resizing Arrays::             Adding and removing elements from an existing array
@end menu

@node Array Subscripting, Array Size, Arrays, Arrays
@section Referencing elements
@cindex Reference of array elements

You can use @samp{[@var{expr}]} after an array to extract one of it's elements.
@var{expr} is a numeric expression.
This is called a subscript. Please note, array subscripts start at 1, unlike in the C language.
If the subscript is a floating-point or rational number, it will be rounded to an integer according to the type conversion rules (@pxref{Type Conversion}).
If you specify a subscript beyond the range of the array, it will result in an error.
Accessing elements of an array takes the same amount of time, regardless of the
amount of elements in the array being accessed.

@subsubheading Examples of element references

@example
$a = #(10,20,30)
print($a[2])
     @print{} 20
print(#(10,20,30)[2])
     @print{} 20

$x = #(#(1,2,3),        // 2 dimentional array
       #(4,5,6),
       #(7,8,9)) 
print($x[2][3])
     @print{} 6

$y = $x[1]              // $y is #(1,2,3) 
print($y[3])
     @print{} 3

$n = #('c4', 'd4', 'e4')  // An array of token strings
$n[3] $n[2]               // Has the same effect as writing e4 d4 directly.
@end example

@noindent
Subscripting can also be used on the left side of an assignment operator to
assign values to specific elements of an array variable.

@example
$b = #(1,4,7)
$b[3] = 6               // change the third element to 6.
print($b)
     @print{} #(1,4,6)
$b[1] += 1
print($b)
     @print{} #(2,4,6)
@end example

@node Array Size, Array Expansion, Array Subscripting, Arrays
@section Array size
@cindex The number of elements in the array

Placing  @samp{#} in front of an array will return the number of elements
in the array, or the number of elements at the first level of a multi-dimentional
array.

@example
$a = #(10,20,30)
print(#$a)
     @print{} 3
$z = #( #(1,2), #(3,4) )
print(#$z)
     @print{} 2
print(# #())  
     @print{} 0          // 0 printed because #() is the empty array.
@end example

@node Array Expansion, Duplicating Arrays, Array Size, Arrays
@section Convert an array to a token string
@cindex Convert array to token string

When you place @samp{@@} in front of an array, each element is joined by a
comma, and converted to a token string. For example, an array, @code{#(1,2,3)},
when @samp{@@} is placed in front of it, will be converted to the token string
@code{1,2,3}.
This can be passed as an argument list to a macro, or to concatenate arrays, as
follows.

@example
$a = #(1,2,3)
$b = #(4,5,6)
$c = #( @@$a, @@$b )     // add the combined arrays $a and $b to $c.
print($c) 
     @print{} #(1,2,3,4,5,6)
@end example

@node Duplicating Arrays, Element Replication, Array Expansion, Arrays
@section Duplicating an array
@cindex Duplication of an array
@findex dup

When an array type of macro is defined by the assignment operator,
or when an array is passed as an argument to a macro,
rather than replication of the array, only a reference to the original sequence is passed.
For this reason, all macros that refer to an array will seem to have elements changed,
rather than just the array reference that was specified. For example,

@example
$a = #(1,2,3)
$b = $a                // $ B becomes "alias" of the same sequence.
$a[3] = 5              // If you change $a, $b also changes.
print($a)
     @print{} #(1,2,5)
print($b)
     @print{} #(1,2,5)

def(macro1, "a") @{
  $1[1] = 10
@}

macro1($a)             // call with an array argument

print($a)
     @print{} #(10,2,5)
print($b)
     @print{} #(10,2,5)
@end example

While it is usually fine for arrays to be past by reference, it being the
fastest, in the cases where you don't want the side effects as described above,
use the @code{dup} function with the array.

@table @t
@item @r{BI:} dup(@var{array})
@end table

@subsubheading @code{dup} examples

@example
$a = #(1,2,3)
$b = dup($a)           // $b is a duplicate of the above array.
$a[3] = 5              // If you change $a, $b is unchanged.
print($a)
     @print{} #(1,2,5)
print($b)
     @print{} #(1,2,3)
@end example

@node Element Replication, Resizing Arrays, Duplicating Arrays, Arrays
@section repeating the same element in an array
@cindex repeating array elements
@findex rep

@noindent
@code{rep} returns a sequence of elements, made up of the given element repeatedly.

@table @t
@item @r{BI:} rep(@var{nelms}, @var{element})
@end table

@var{nelms} is the number of repetitions, @var{element} is the element to be repeated.
If the element to be repeated is an array, the actual elements are repeated,
not repeated references.

@subsubheading @code{rep} examples

@example
$a = rep(5,0)          // $a becomes the array #(0,0,0,0,0)
$b = rep(3,rep(2,1))   // $b becomes #(#(1,1),#(1,1),#(1,1))
@end example

@node Resizing Arrays,  , Element Replication, Arrays
@section Ading and removing elements from an array
@cindex Expansion and contraction of the array
@findex append
@findex insert
@findex shift

PMML has the ability to dynamically add or remove elements from an array,
similar to a list in other programming languages. Note however that while
elements can be added or removed, there is no way to insert elements into the
middle of an array. The following 3 commands can be used.

@table @t
@item @r{MD:} append(@var{array}, @var{element}, @dots{})
Add any number of elements to the end of the array @var{array}.
The second and subsequent arguments are a list of elements to be added.
@var{array} cannot refer to the array of arguments to a macro (@samp{$*}).

@item @r{MD:} insert(@var{array}, @var{element}, @dots{})
 Add any number of new elements to the array @var{array}.
The second and subsequent arguments are a list of elements to be added.
@var{array} cannot refer to the array of arguments to a macro (@samp{$*}).

@item @r{MD:} shift@r{[}(@var{array} @r{[}, @var{n}@r{]})@r{]}
Reduces the size of the array @var{array}.
@var{n} Is an integer expression,
if positive, removes @var{n} elements from the beginning of the array,
if @minus{}@var{n} (negative), removes elements from the end of the array.
Nothing is done if @var{n} is 0.
If @var{n} is equal to or greater than the number of elements the result is an empty array.
Note that @var{array} can refer to the array of macro arguments @samp{$*}.
If you omit @var{n}, it is assumed to be 1.
You can also simply write @code{shift}, without any arguments, including the parentheses.
It is the equivalent to writing @code{shift($*,1)}.

If you modify @samp{$*} by using @code{shift}, the argument substitution
shortcuts, @samp{$1}, @samp{$2}, @dots{} will reflect the modified elements 
of the array.
@end table

@subsubheading example 1 changing array size

@example
$a = #(1,2,3)
append($a, 4,5)       // Add 4 and 5 at the end of $a.
print($a)
     @print{} #(1,2,3,4,5)
insert($a, 0)         // Add 0 to the beginning of $a.
print($a)
     @print{} #(0,1,2,3,4,5)
shift($a, 2)          // Remove two elements of the beginning of $a.
print($a)
     @print{} #(2,3,4,5)
shift($a, -2)         // Remove two elements of the end of $a.
print($a)
     @print{} #(2,3)
@end example

@subsubheading example 2 changing array size

@example
def(mac1, "n*") @{
  print($1, $2, $#)
       @print{} 5 6 3 
  shift               // shift the arguments, one by one.
  print($1, $2, $#)
       @print{} 6 7 2
@}

mac1(5,6,7)
@end example

@c --------------------------------------------------------------------
@node Built-in Functions, Effectors, Arrays, Top
@chapter Built-in functions
@cindex built-in functions

Built-in functions are a kind of macro that are prepared in advance by the system.
They are written in C and incorperated into the PMML compiler itself.
In this regard, they are not the same as the standard macros (which are described in the PMML language).

The difference between macro directives and built-in function is that the latter can be re-defined.
In the thread, if you define a macro with the same name as a built-in function,
within that thread user-defined macro will take precedence over the function.
You can also use @code{undef} in the root thread to override a built-in function.
However, if you re-define built-in functions with macros, these could affect
standard macros in the library which rely on these built-in functions. Care should be taken.

@menu
* Message Output Functions::    output of a message. print, printf, etc
* Math Functions::              Arithmetic functions. abs, sin, etc
* Random Number Generators::    Functions that generate random numbers
* Numerical Type Conversion::   Functions to do the type conversion between numeric types
* String Functions::            Functions for string processing
* Get Identifier Information::  Functions to determine the definition status and type of identifiers
* Expression Type::             Type functions to determine the type of the expression
* Token Extraction::            nth_token function for obtaining the n-th token
* Error Handling::              Functions for error handling
* Debugging::                   Support functions for debugging
@end menu

@node Message Output Functions, Math Functions, Built-in Functions, Built-in Functions
@section Message output
@cindex Message output

The following are the built-in functions to output messages.

@table @t
@item @r{BI:} print(@var{expr}, @dots{})
@findex print
Output the value of an expression @var{expr} to standard output.
@var{expr} may be of any type, if it is an array or token string type,
its entire contents are output.
in the case of a rational type, It will be output in the form,
(Disjoint b and c, b <c, b>= 0, c> 0) a + b / c.
Single expressions are separated by a space character, and finally a new line is
added after all expressions are printed.

@item @r{BI:} eprint(@var{expr}, @dots{})
@findex eprint
Output is the same as @code{print} except that the output goes to standard error.

@item @r{BI:} printf(@var{format}, @var{expr}, @dots{})
@findex printf
Output in the same format as  printf of the C language.
Output goes to standard output. Addition of the last newline character is not performed.
You can use the following format specifiers in the format string for @var{format}.

@example
%@r{[}+@r{][}-@r{][}0@r{][}@var{space}@r{][}@var{width}@r{[}.@var{precision}@r{]]}@var{convchar}
@end example

@noindent
The width of a field is @var{width} and the precision is @var{precision}  @samp{*}
folloing these is a conversion character @var{convchar}. It can be one of the following.

@table @code
@item d
Decimal integer representation. If the argument is a non-integer is displayed rounded to an integer.
@item o
Octal integer representation.
@item x @r{or} X
Hexadecimal integer representation. @code{%X} directs the characters a-f to be output in uppercase.
@item f
Decimal format display. The default precision is six decimal places.
Lower part than the specified accuracy rounding is performed.
@item e @r{or} E
Exponential format display. The default precision six decimal places. @code{%E} is displayed in upper case e.
@item g @r{or} G 
As appropriate of the decimal format or exponential format.
0 of the following end-point is deleted.
The default maximum number of significant digits is 6.
@code{%G} is displayed in upper case e.
@item c
output the code of the character given by the argument.
@item s
Display as a character string
@item %
A literal @samp{%}.
@end table

@item @r{BI:} eprintf(@var{format}, @var{expr}, @dots{})
@findex eprintf
The same as @code{printf} but output is to standard error.
@end table

@node Math Functions, Random Number Generators, Message Output Functions, Built-in Functions
@section Arithmetic functions
@cindex Arithmetic functions

@table @t
@item @r{BI:} floor(@var{expr})
@findex floor
Return the largest integer less than or equal to the value of the argument.
Applical to integers, floating point or rational types.
The results will always be an integer type.

@item @r{BI:} ceil(@var{expr})
@findex ceil
Return the smallest integer greater than or equal to the value of the argument.
Applical to integer, floating point or rational types.
The results will always be an integer type.

@item @r{BI:} abs(@var{expr})
@findex abs
Return the absolute value of the argument.
Applical to integer, rational or floating point types.
The data type of the result will be the same as the argument.

@item @r{BI:} sqrt(@var{expr})
@findex sqrt
return the square root of the argument's value.
It is an error if the argument is negative.

@item @r{BI:} sin(@var{expr})
@findex sin
Return the value of the sine function. The argument is in radians.

@item @r{BI:} cos(@var{expr})
@findex cos
Return the value of the cosine function. The argument is in radians.

@item @r{BI:} atan2(@var{y}, @var{x})
@findex atan2
On the basis of the inverse tangent function of @var{y} / @var{x},
Point in Cartesian coordinates (@var{x},@var{y}) of when it was converted to polar coordinates
returns the angle.
returns the correct result even if @var{x} is 0.
The result is in radians, and is in the range from @minus{} π to π.

@item @r{BI:} exp(@var{expr})
@findex exp
Return the value of the exponential function that has a base of e.

@item @r{BI:} log(@var{expr})
@findex log 
Return the value of the logarithmic function that has a base of e.
It is an error if the argument is not positive.
@end table

@node Random Number Generators, Numerical Type Conversion, Math Functions, Built-in Functions
@section Functions for the random number generator
@cindex Functions for the random number generator

@table @t
@item @r{BI:} rand()
@findex rand
Return a random floating point number in the range 0 <= x <= 1.

@item @r{BI:} irand(@var{n} @r{[}, @var{m}@r{]})
@findex irand
Return a random value that is an integer. If @var{m} is omitted,
the range is from 1 to @var{n}.
If @var{m} is specified, the range is from @var{n} to @var{m}.

@item @r{BI:} frand(@var{n} @r{[}, @var{key}@r{]})
@findex frand
Returns an integer of 1 / f random value in the range 0 to @var{n}@minus{}1.
Distribution of random number value is a uniform distribution. @var{n} must be a power of two.
@var{key} is an integer, it means a random number sequence number (different from the species).
In the case of generating in parallel two or more random number sequences are different for each
You do not assign a series number and should not be in the correct 1 / f random number.
If you omit the @var{key} is considered to be a 1.

@item @r{BI:} fgrand(@var{n} @r{[}, @var{m} @r{[}, @var{key}@r{]]})
@findex fgrand
Return the 1 / f random value of integer.
If @var{m} is omitted, the range will be from 1 to @var{n}.
If @var{m} is specified, the range is from @var{n} to @var{m}.
Random number value will be distribution close to the Gaussian distribution, IE (@var{n} + 1) / 2 to @var{m}.
When it is specified (@var{n} + @var{m}) / 2) as an integer random number value in the vicinity of
Probability that is returned will be the highest.
@var{key} has the same meaning as in the case of the above-mentioned @code{frand}.

@c !!!!!!!!!! 乱数関数を追加／削除したら下も直す !!!!!!!!!!!!!
@item @r{BI:} srand(@r{[}@var{seed}@r{]})
@findex srand
Set the random number seed in the four functions above.
If you omit the argument, the current time (in seconds)
By the sum of the process number, you can set the seed for the random number.
@end table

@node Numerical Type Conversion, String Functions, Random Number Generators, Built-in Functions
@section Type conversion between numeric types
@cindex Type conversion between numeric types

@table @t
@item @r{BI:} int(@var{expr}) 
@findex int
Converts any number to an integer according to type conversion rules (@pxref{Type Conversion}).

@item @r{BI:} rational(@var{expr}) 
@findex rational
Converts any number to a rational type according to the rules of type conversion (@pxref{Type Conversion}).

@item @r{BI:} float(@var{expr}) 
@findex float
Converts any number to floating point according to the rules of type conversion (@pxref{Type Conversion}).

@c helpme: unsure how to translate the following 3 function's descriptions
@item @r{BI:} intg(@var{rational})
@findex intg
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 a を返します。

@item @r{BI:} num(@var{rational})
@findex num
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 b を返します。

@item @r{BI:} den(@var{rational})
@findex den
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 c を返します。
@end table

@node String Functions, Get Identifier Information, Numerical Type Conversion, Built-in Functions
@section String handling functions
@cindex String handling functions

@table @t
@item @r{BI:} strlen(@var{string}) 
@findex strlen
Return the length of the string @var{string}.

@item @r{BI:} substr(@var{string}, @var{pos} @r{[}, @var{nchars}@r{]}) 
@findex substr
Return a substring of the string @var{string} starting at position @var{pos}, and stop after @var{nchars} characters.
A @var{pos} of 1 corresponds to the beginning of the string,
if less than 1, regard as 1.
If you omit the @var{nchars}, regard this as the end of the string to stop.

@item @r{BI:} index(@var{string1}, @var{string2})
@findex index
Locate the string @var{string2} that is in the string @var{string1} from the beginning
and return the first matching position.
The result is an integer that counts the beginning of @var{string1} from 1.
If it is not found it will be 0.

@item @r{BI:} charcode(@var{string} @r{[}, @var{pos}@r{]})
@findex charcode
The character's ASCII code which is at @var{pos} of the string @var{string}
will be returned. If you omit @var{pos} it is assumed to be 1.
If there is no @var{pos}th character, 0 will be returned.

@item @r{BI:} atoi(@var{string})
@findex atoi
Return the integer value represented by the string @var{string}.
@var{string} returns 0 if it is not a string that represents an integer.

@item @r{BI:} atof(@var{string})
@findex atof
Return the floating-point value that is represented by the string @var{string}.
If @var{string} is not a string that represents a number of floating-point type, returns 0.0.

@item @r{BI:} sprintf(@var{format}, @var{expr}, @dots{})
@findex sprintf
The same formatting as performed by @code{printf} (@pxref{Message Output Functions})
is performed, and the resulting string is returned.
The functions that convert from strings to values use @code{sprintf}.

@item @r{BI:} toupper(@var{string})
@findex toupper
All the characters in @var{string} are returned in uppercase.

@item @r{BI:} tolower(@var{string})
@findex tolower
All the characters in @var{string} are converted to lowercase.

@item @r{BI:} notename(@var{note-num} @r{[}, @var{octave}@r{]})
@findex notename
Return a string representing the MIDI note number @var{note-num} as a note name.
For example, @code{notename(61)} will return @t{"C#4"}.
If the integer @var{octave} is specified,
the octave as a reference, octave is the relative notation (for example,
@code{notename(61,3)} returns @t{"^C#"}.
When @var{octave} is 0, it is converted to a string with no octave notation.
In @code{notename}, @code{tp} and @code{key} value of the register and the independent conversion is done.
In addition, a sound that is inharmonic is always returned with a sharp sign.

@item @r{BI:} idstr(@var{identifier})
@findex idstr
Convert the identifier @var{identifier} to a string.
For example, @code{idstr($zzz)} will be replaced by @t{"$zzz"}.
It does not matter if @var{identifier} is an undefined identifier.
Reserved words are not accepted (@pxref{Identifiers}).

@item @r{BI:} concat(@var{array} @r{[}, @var{delimiter}@r{]})
@findex concat
Convert all the elements of the array @var{array} to a string and return it.
@var{delimiter} is a string that is inserted between the elements,
the default is an empty string.
@end table

@node Get Identifier Information, Expression Type, String Functions, Built-in Functions
@section Acquisition of identifier information
@cindex Acquisition of identifier information

@table @t
@item @r{BI:} defined(@r{[}@var{scope}@r{]}@var{identifier})
@findex defined
Tests if the identifier @var{identifier} is defined, as any type. Returns 1 if defined,
Otherwise, it returns 0.
@var{scope} is THE scope specification (@pxref{Scope Specifiers}).

@item @r{BI:} idtype(@r{[}@var{scope}@r{]}@var{identifier})
@findex idtype
Returns the following values, depending on the type of identifier @var{identifier}.
@var{scope} is the scope specifier (@pxref{Scope Specifiers}).

@table @asis
@item 0
Undefined name
@item 1
Local macro name
@item 2
Thread macro name
@item 3
Built-in function name
@item 4
Thread name
@item 5
Effector class name
@item 6
Effector instance name
@item 7
Communication channel name
@end table
@end table

@node Expression Type, Token Extraction, Get Identifier Information, Built-in Functions
@section Judgment of the type of the expression
@cindex Judgment of the type of the expression

@table @t
@item @r{BI:} type(@var{expr})
@findex type
Returns one of the following strings, based on the type of the expression @var{expr}.

@table @t
@item "i"
Integer
@item "r"
Rational type
@item "f"
Floating-point type
@item "s"
string
@item "a"
array
@item "t"
Token string type
@end table
@end table

@node Token Extraction, Error Handling, Expression Type, Built-in Functions
@section Token extraction
@cindex Token extraction

@table @t
@item @r{BI:} nth_token(@r{[}@var{scope}@r{]}@var{macro-name}, @var{n})
@findex nth_token

Return a token from the token string associated with the variable or function type macro @var{macro-name}.
Returns the @var{n}th token. For example, when @code{x = 'y = 1'},
@code{nth_token(x,1)} returns @code{y}, @code{nth_token(x,3)} returns @code{1} respectively.
If @var{n} exceeds the number of tokens in the token string, an empty token is returned.
@end table

@node Error Handling, Debugging, Token Extraction, Built-in Functions
@section Error handling
@cindex Error handling

@table @t
@item @r{BI:} error(@var{format}, @var{expr}, @dots{})
@findex error
Outputs a message to the standard error output, and then exit the compiler,
in the same way as an error is detected by the compiler.
The arguments  form the contents of the error message,
The format is the same as the @code{printf}. A newline character is added at the end of output.

@item @r{BI:} warn(@var{format}, @var{expr}, @dots{})
@findex warn
Output a message to the standard error output,in the same manner as a warning is issued by the compiler.
Argument is the contents of the warning message, this is the same format as @code{printf}.
Finally a newline character is added at the end of output.

@item @r{BI:} exit(@var{exit-status})
@findex exit
@cindex Termination status
Suspends the compilation immediately.
The integer @var{exit-status} will be the exit status of the compiler process
returned to the operating system.
If interupted by @code{exit}, an output MIDI file is not generated.
@end table

@node Debugging,  , Error Handling, Built-in Functions
@section Functions for debugging
@cindex debug

@table @t
@item @r{BI:} dumpdef(@r{[}@var{scope}@r{]}@var{identifier})
@findex dumpdef
Displays the definition of identifier @var{identifier}.
@var{scope} is a scope specifier (@pxref{Scope Specifiers}).

@item @r{BI:} dumpdict(@r{[}@var{string} @r{[}, @r{[}@var{thread-path}@r{]}@var{thread-name}@r{]})
@findex dumpdict
Displays the contents of the identifier dictionary.
@var{string} is a sequence of letters which determine what type of identifiers to display as described below.
If omitted, @t{"lm"} is assumed, meaning display local macro names and thread macros.
If there is a given thread name in @var{thread-name}, display only the identifiers in this thread.
If not specified, display identifiers in all threads.
 The thread name can also have a @var{thread-path} attached, as well.

@table @t
@item "l"
Local macro names
@item "m"
Thread macro names
@item "b"
Built-in function names
@item "t"
Thread names
@item "e"
Effector class names
@item "i"
Effector instance name
@item "c"
Communication channel names
@item "s"
Display statistics about the hash of the dictionary.
@end table

@item @r{BI:} trace(@var{level})
@findex trace
Set the trace level to @var{level}.
When the trace level is 1, when the call of the function type macro has been made,
Its arguments and deployment results are displayed. When the trace level is 2,
It in addition to the call of the variable type macro, appears deployment result.
When the trace level is 3, the result of argument expansions are also displayed.

@item @r{BI:} showeffs()
@findex showeffs
Display information about effector instances attached in the current thread.
@end table

@c --------------------------------------------------------------------
@node Effectors, Communication, Built-in Functions, Top
@chapter Effectors
@cindex Effector
@cindex action

An @dfn{Effector} is a software module that can gather statistics and/or
modify or generate new events, by calling an @dfn{action} for each event generating command.
The effector is named after the effects units commonly found in audio or MIDI
equipment, where the input is processed to give a new type of output.

@menu
* Overview of Effectors::       Effector Overview. Glossary of terms.
* Event Types::                 How to Write an event code for the event type
* Defining Effectors::          How to define the effector
* Event Actions::               Describing actions for the events
* Attaching Effectors::         How to attach the effector to a thread
* Changing Valid Flags::        Operation of effector valid flags
* Changing Through Bits::       Operation of through bit
* Undefining Effectors::        Cancellation of effector definition
* Effector Examples::           Examples of some of the effectors
* Predefined Effectors::        Pre-defined effectors (effector library)
* Virtual Controllers and Effectors::  How to define the meaning of the virtual controller
@end menu

@node Overview of Effectors, Event Types, Effectors, Effectors
@section Effector Overview

Before describing the commands used to manipulate effectors, relevant terms and
concepts will be discussed.

@menu
* Effector Class::              Effector definitions and effector class
* Effector Instance::           Attach, instance of an effector
* Effector Chain::              Attaching multiple effectors
* Inheritance of Attachment::   passing attached effectors to child threads
* Through Bits::                The through bit
* Effector Valid Flags::        The effector valid flag.
@end menu

@node Effector Class, Effector Instance, Overview of Effectors, Overview of Effectors
@subsection Effector definitions and effector class
@cindex Effector class

To use effectors, first you must define the effector, telling the compiler
which types of event to process, and what actions to carry out.
Effector definition is done by the @code{defeff} command.
The result of an effector definition is a data structure called the @dfn{Effector class},
which packages together all information about all events and actions the
effector processes and acts upon. It's known by it's effector class name.

@node Effector Instance, Effector Chain, Effector Class, Overview of Effectors
@subsection Attach and effector instances
@cindex Effector instance
@cindex attach
@cindex Effector thread
@cindex Detach

In order to actually operate the effector, and the effector is defined,
you need to @dfn{attach} it to the thread.
If you do attach, a data structure called the @dfn{Effector instance}
is created. Against effector instance,
you can give it an effector instance name if necessary.
Each effector instance will have an event buffer for storing events,with its own thread called the @dfn{Effector thread}.
The parent thread of the effector thread is the thread when you attach the effector.
The thread name of the effector thread is the same as the effector instance name.
When an effector instance name is not given, it becomes an unnamed thread.

When you attach the effector to a thread, events that are generated in the thread
appear to be stored in the event buffer present in the effector instance.
However, not all events are stored, only those that the through bits and
effector valid flags allow.

When a thread you have attached an effector to disappears,
a process called @dfn{Detach} of effector is carried out.
This detach, in the event buffer
Action is called for all of the events that had been stored.
In this case, the command in the action will be executed in the effector thread.

The following example defines an effector to add a note an octave above the current note,,
when the effector is attached.

@example
/* Effector definition */
defeff(octaver) @{    // octaver Effector class name.
   /* Action for note events */
   case(note) @{
      note(n+=12)&   // add a note an octave above
   @}
@}

/* Effector attach */
octaver()

/* Execution of the note command */
C D E                // These are played in octaves.
@end example

@noindent
When the C, D, and E note commands are executed above, they are stored in the
event buffer of the @code{octaver} effector instance.
When the compiler completes, and the root thread is ended, this causes any
effectors to be detached, which causes all actions to be run for events in effector buffers.
In other words, the three notes above are played in octaves.
If the placement of the effector's attachment is modified as follows, what happens?

@example
C @{octaver() D@} E
@end example

@noindent
The result will be that only the D is played in octaves.
	In this case, the attachment of the @code{octaver} effector instance
	will be governed by the thread grouping commands (@pxref{Grouping}).
Thus, only the D note will be placed into the event buffer of the @code{octaver} effector instance.
Once the thread created by the grouping commands has ended, the @code{octaver}
effector is detached and it's action is carried out,
causing the D note to be played in octaves. The E remains uneffected because it is outside the thread where the effector was active.
This example makes sense even if written using the modifier, as below.

@example
C D(octaver()) E
@end example

@node Effector Chain, Inheritance of Attachment, Effector Instance, Overview of Effectors
@subsection Attaching and Detaching Multiple Effectors
@cindex Attaching multiple effectors
@cindex Detaching effectors

You can attach multiple effectors relative to one thread.
In this case, effectors will be detached in the reverse order of attachment to the thread.
Here are some more details on how this works.
When you generate an event  when multiple effectors are attached, the event
will first be placed into the buffer of the last effector that was attached.
And, when a thread has disappeared, the actions of the most recently attached
effector  will be applied to each event.
The resulting events will then be placed into the event buffer of the next most recent effector in attachment order.
When all actions are finally carried out, and the effector is detached, this process now repeats for the next effector.
This process is repeated for all of the effectors that have been attached.

The final effector to be detached, that is, the first effector to be attached,
is called the @dfn{End effector}.
In the PMML startup file (@pxref{Start-up}) an end effector called @code{$smfout} is attached.
The @code{$smfout} effector writes events to a standard MIDI file.
as a result, PMML outputs a standard midi file, all thanks to the termination of this effector.
This means that you can change the effector that is attached in the startup
file, so that, for instance, MIDI events can be written as text instead of to an SMF.

Effectors attached in the current thread can be displayed using the
@code{showeffs} built-in function ()@pxref{Debugging}).

Below is an example of two effectors being attached, @code{octaver} and @code{rand_velocity}.

@example
/* Effector to add a random number of + -10 to velocity */
defeff(rand_velocity) @{
   case(note) @{
      v += irand(-10,10)
   @}
@}

/* Effector attach */
rand_velocity()
octaver()      // Effector defined in the previous section

/* Execution of note commands */
C D E          // These notes are played in octaves,
               // and in addition, have a random velocity of plus/minus 10 added.
@end example

@noindent
Because @code{octaver} was the last effector attached, the C, D and E note
events are first placed in the event buffer of @code{octaver}.
When the compilation process finishes, first, the detach processing of @code{octaver} takes place.
In other words, the events, with an octave added are placed into the event buffer,
along with the original event, which will be stored in the event buffer of @code{rand_velocity}.
Then, when the detach of @code {rand_velocity} is performed, each event has a random number added to it's velocity.
As a result, the event is placed in the event buffer of the end effector,
which results in the final output of a standard midi file being produced.

Note that the order in which you attach effectors is significant.
When the order of the @code{octaver} and @code{rand_velocity} effectors in the example above are reversed,
notes are first given random velocities, and then transformed into octaves,
meaning that the random velocities will be the same for both notes in the octave.

@node Inheritance of Attachment, Through Bits, Effector Chain, Overview of Effectors
@subsection Propogation of atached effectors to child threads
@cindex Propogation of attachment

The List of effectors that are attached  are managed for each thread.
When a new thread is created with the thread generation commands, the registers of the parent thread are copied to the new child.
In addition, the list of attached effectors are also copied.
Therefore effectors that are attached to the parent thread will also be active in the new thread.
However, only effectors that are newly atached in this child thread are detached
when the thread ends, effectors in the parent thread are not detached.

For example, in the following, the @code{volup} effector 
is attached to a parent thread which, in the middle of it's execution, generates a new child thread.
This effector remains valid even after the child thread ends.

@example
/* Effector to multiply volume by 1.5. */
defeff(volup) @{
   case(ctrl(7)) @{
      val *= 1.5
   @}
@}

/* Effector attach */
volup()

/* The execution of the commands */
vol(50)      // becomes vol(75) with effector attached
C D 
@{            // New thread is created
  octaver()  // volup and octaver are now both attached
  E          // Played in octaves.
  vol(80)    // Becomes vol(120) with effector attached
  F          // Played in octaves
@}            // octaver is detached, only volup is attached, as in the previous state
G            // Not played in octaves
vol(50)      // Becomes vol(75) with effector attached
             // Finally volup is detached.
@end example

@node Through Bits, Effector Valid Flags, Inheritance of Attachment, Overview of Effectors
@subsection Through bit
@cindex Through bit
@cindex Events through bit
@cindex Channel through bit

An effector has a bit vector which records whether  an event is processed or
passed through, in each instance, called the @dfn{Through bit}.
There are two types of threw bit.

@table @asis
@item Events through bit
This presents one bit for each type of event.
If this bit is 1, the appropriate type of event passes through the effector,
So will not be affected by the effector.
For control change, and for each controller number
Another bit is assigned. Also, note-on and note-off also
It has become another bit.

@item Channel through bit
This presents one bit for each MIDI channel.
If this bit is 1, the corresponding channel of  events will pass through the effector,
So they will not be affected by the effector.
This is used in order to apply the effector only for a particular channel.
@end table

Events that pass through the effector, because of either through bit being 1 above,
are not placed in the event buffer of the effector instance.
This, of course means that the actions are not applied to these events.

For events which are channel independent, such as exclusive events, the channel
through bit will have no effect. in other words, only the events through bit will determine if these vents pass through or not.

When an effector is attached, that is, when an instance is generated, the event
through bits for the event types in the action description are set to 0. the
rest are set to 1.
For example, in the case of the previous section's @code{octaver} effector, note-on and note-off
Events through bit is set to 0, while all the rest are 1.
Therefore, events such as control changes will not be present in the buffer of the attached @code{octaver} effector.
When first attached, all channel through bits will be set to 0.

You can change the through bits to any value after the effector is attached.

@node Effector Valid Flags,  , Through Bits, Overview of Effectors
@subsection Effector valid flag
@cindex Effector valid flag

The valid flag is used to temporarily disable the effector.
Each effector instance of each thread has a bit assigned called the @dfn{valid flag}.
If this flag is set to 0 within a thread where an effector instance is attached,
no events will be placed into the event buffer, therefore, event processing will not take place.
You can change the valid flag by using the @code{disable} and @code{enable} commands.

@node Event Types, Defining Effectors, Overview of Effectors, Effectors
@section Event type names and their event codes
@cindex Event type name
@cindex Event code

The Event type name is the name that represents the type of event (alone or set thereof).
In addition, the event code is a representation of each type of event as an integer. These are,
used in the effector definition and threw bit changes.
Below are the event type names, along with the associated code and meaning of each.

@table @t
@item note_on
Note-on event. Event code 403 (0x193).
@item note_off
Note-off event. Event code 402 (0x192).
@item note
Both note-on and note-off.
@item ctrl@r{[}(@var{number-list-0-255})@r{]}
Expanded control change events.
Event code from 0 to 255 (0xff).
@item bend
Pitch bend event. Event code 128 (0x80)
.@item kp
Key pressure event. Event code 129 (0x81).
@item cpr
Channel pressure event. Event code 130 (0x82).
@item prog
Program change event. Event code 131 (0x83).
@item tempo
Tempo setting event. Event code 192 (0xc0).
@item excl
Exclusive events. Event code 400 (0x190).
@item arbit
Any message events. Event code 401 (0x191).
@item meta@r{[}(@var{number-list-0-127})@r{]}
Meta-event except for the tempo setting. Event codes from 256 (0x100) to 383 (0x17f).
@item seqno
Sequence number events. Event code 256 (0x100).
@item text@r{[}(@var{number-list-1-15})@r{]}
Text events. Event codes from 257 (0x101) to 271 (0x10f).
@item smpte
SMPTE offset event. Event code 340 (0x154).
@item timesig
time signature  setting event. Event code 344 (0x158).
@item keysig
Key signature event. Event code 345 (0x159).
@item all
All kinds of events.
@end table

@noindent
In the above, @var{number-list-m-n} can be used when when specifying the controller number and meta-event type number.
You can separate numbers by a comma.
You can also specify @samp{@var{x}-@var{y}} to specify all numbers in a given range.
For example, @samp{ctrl(1,7-9)} Means control changes 1, 7, 8 and 9.
The Number should be @var{m} or more, up to and including @var{n}.
Although it is not possible to use an expression in number, a macro call is possible.
If you omit the number list, it would mean "all".
For example, @samp{ctrl} means all of the extended control changes.

Several common controller numbers have been defined as standard variable type macros.
by using these, your code will be clearer than if direct control numbers were used.
These include @code{Mod}, @code{Breath}, @code{Foot},
@code{Pmtime}, @code{Vol}, @code{Pan}, @code{Expr}, @code{Bend},
@code{Kp}, @code{Cpr}, @code{Vmag}, @code{Tempo}, @code{Ped}, @code{Pm}
and @code{Sped}. For example,
instead of writing @code{ctrl(7)}, you can write @code{ctrl(Vol)}.
See the @ref{Control-Change Events} for the meaning of each macro name.

Both continuous and single control change events belong to the same event code.

In a standard MIDI file, a tempo event is treated as a meta event, however, in
PMML, it is considered to be part of the set of extended controller events.
Because of this, you cannot use @code{meta(0x51)} to specify tempo setting
events in PMML, use the dedicated tempo macros instead.

You can convert from the event type name to the event code by using the following macro instruction.

@table @t
@item @r{MD:} ecode(@var{event-type})
@findex ecode
@end table

@noindent
@code{ecode} returns the event code for the event type name @var{event-type}.
@var{event-type} must represent a single event type.

@node Defining Effectors, Event Actions, Event Types, Effectors
@section Defining effectors
@cindex Definition of effector
@findex defeff
@cindex @code{init} action definition section
@cindex @code{detach} action definition section
@cindex @code{case} action definition section
@cindex @code{wrap} action definition section
@cindex Effector flag

The definition of an effector is done with the @code{defeff} command.

@table @t
@item @r{C:} defeff(@r{[}@var{scope}@r{]}@var{class-name} @r{[}, @var{arg-spec} @r{[}, @var{flags}@r{]]}) @{ @var{actions} @}
@end table

@noindent
@var{class-name} is the effector class name of the effector to be defined.
If you omit the scope specification @var{scope}, @var{class-name} is
registered in the current thread's identifier dictionary.
You can specify another thread's dictionary to add to with the @var{scope} specification
(@pxref{Scope Specifiers}).
However @samp{local::} can not be specified.
If you give an effector class name that is already defined, it will be redefined.
However, an error will result if another type of identifier with the same name is defined.

The Argument specification @var{arg-spec} is a specification of the arguments
that can be passed when you attach this effector. It is in the same format as
the argument specification string in @code{def} (@pxref{Argument Spec}).
The Arguments that were passed during the attach can be referenced in actions.
The methods of referencing arguments are the same as for a function-like macro (@pxref{Argument Substitution}).

@var{flags} is an integer called the effector flag,
where each bit has the following meaning.

@table @asis
@item 0th bit
This bit determines how to sort events that takes place just prior to detach.
To show these bits,
the standard macro called @code{MergeTracks} is defined as 0x01.

When this bit is 0, will be multiplied by the time the order sorted by track.
The order in which they are called the action,
First all events lined up in order of time of track 1,
Then all events lined up in order of time of track 2, @dots{}.
Same time events will be rearranged according to the event priority (@pxref{Priority}).
Same case priority, generated the order is kept.

If this bit is set to 1 (ie
if you give the @samp{MergeTracks} as effector flag),
Regardless of the track number for all events in the event buffer
Time order sort will be multiplied.
Treatment of the same time the event is the same as above.
The order in which they are called the action is the time order of events,
Track number will be mixed.

@item The first bit
When this bit is 1, just prior to detach,
Continuous control change events in the event buffer
will be expanded to the individual control change events.
It should be noted that, in order to show this bit, the standard macro called @code{ExpandCtrl}
is defined as 0x02.
@end table

@noindent
@var{flags} is set to 0 if it is omitted.
It should not be set to values other than those listed above.

In the @code{defeff} command, the @var{actions} portion describes the processing the effector carries out.
This part can have at most one each of the @code{init} action definition section,
@code{detach} action definition section, @code{wrap} action definition section,
and can consist of any number of @code{case} action definition sections.
Action definition sections other than @code{case} may be described in any order,
with no loss of meaning. However, @code{case} ording is important, as described below.
The Formats and their meanings for each action definition section is as follows.

@table @t
@item init @{ @var{command} @dots{} @}
@itemx attach @{ @var{command} @dots{} @}
@code{init} Is an action definition section.
The command string @var{command}@dots{} is called the @code{init} action,
which will be executed when the effector is attached.
The @code{init} action describes the initialization relating to the effector.
The meaning does not change by replacing the @code{init} with @code{attach}.
In reference to @code{t} register in @code{init} action
the time is obtained when it is attached.

@item detach @{ @var{command} @dots{} @}
@code{detach} is the action definition section.
The Command string @var{command}@dots{} is called the @code{detach} action.
Prior to the processing of each event when the effector is detached, It is done when you have set the effector flag.
It will be executed immediately after the time of the order sorting and continuous control change deployment.
In reference to the @code{t} register in the @code{detach} action,
the time is obtained when you detach.

@item case(@var{event-type}, @dots{}) @{ @var{command} @dots{} @}
@code{case} Is an action definition section.
The command string @var{command}@dots{} is called an event action,
which runs for each event type indicated by the event type name @var{event-type} (@pxref{Event Types}).
The Event type name can also be multiple types separated by commas.
Note, when two or more actions exist for the same event type,  only the first action found in the source is run.
See the next section for a description  of the various event actions.

@item wrap @{ @var{command} @dots{} @}
@code{wrap} Is an action definition section.
The command string @var{command}@dots{}is called the @code{wrap} action,
which runs after all event processing has been finished.
For example, you can describe the process as to output the event of total result.
@end table

@node Event Actions, Attaching Effectors, Defining Effectors, Effectors
@section Event Actions
@cindex Event Actions
@findex reject
@findex etype
@findex val
@findex ctype

An event action is a command string to be executed for each event.

Before each action is called, some of the registers shown below (registers of the effector thread)
and the variable type macros (thread macros in the effector thread ), will be set.
Which registers or macros are set depends on the type of event.

@table @asis
@item @code{t} register
Time at which the event occurs.
@item @code{tk} register
Track number
@item @code{ch} register
MIDI channel number
@item @code{n} register
Note number
@item @code{v} register
Velocity
@item @code{nv} register
Note-off velocity
@item @code{do} register
Time difference of note-on and note-off
@item @code{dp} register
Always 0
@item @code{etype} macro
Event code (@pxref{Event Types})
@item @code{val} Macro
For extended control change events, the control value.
For exclusive or any message events, an array of data.
In the case of meta-events, data value (integer, string or array).
@item @code{ctype} macro
In the case of a continuous control change event,
this will have 1 for the @code{ctrl_to}, 2 for the @code{ctrl_cto} or 3 for the @code{ctrl_pt} events.
0 for a normal control change.
@end table

It should be noted, the @code{dt} register, when attached, is set to 0
(@pxref{Attaching Effectors}).

Within the action, you can also run any kind of command.
You can adjust registers of the current event being processed, or run another event generation command, to generate a new event.
You can see the arguments given at the time of attach, using an argument reference that begins with @samp{$} in the action.

When the execution of the actions have been completed, and the events from the event buffer
The same type of event is automatically output.
If the action is empty, then the events from the event buffer will be output as is.
If you simply change the registers for an event in an action, a new event with these new register values is output.
If you want to suppress the automatic output of the event, in the action,
run the following command, @code{reject}.
You can use @code{reject} if you want to output different types of events from those being processed in the current events buffer.

@table @t
@item @r{C:} reject
@end table

@noindent
The behavior of actions for each event type is as follows.

@subheading In the case of note events
@findex REST

When the type of the event from the event buffer is note-on / off,
the vehavior of the action will vary depending on if the argument to @code{case}
is @code{note}, @code{note_on} or @code{note_off}.

In the case of @code{case(note)}, one action is called for the pair of note-on
and note-off events. If sorting by time is in effect, events are sorted by the
note-on time. This sets the following registers/macros.
@code{t}, @code{tk}, @code{ch}, @code{n}, @code{v}, @code{nv}, 
@code{do}, @code{dp} and @code{etype}.
@code{t} is the time of the note-on. The note-off time can be calculated by (@code{t}+ @code{du}).
At the end of action processing, Both note-on and note-off events will be output.
If you change the registers/macros, it will be reflected in the two events that are output.
If you use the value of a rest, using the standard macro @code{REST} as the
value of @code{n}, set to 0x80000000, the event output is suppressed.

On the other hand, in the case of @code{case(note_on)} or @code{case(note_off)},
Actions will be executed for each of the note-on or note-off events.
This Sets the following registers/macros.
@code{t}, @code{tk}, @code{ch}, @code{n}, @code{v} (note-on only),
@code{nv} (note-off only),
and @code{etype}. The @code{do} and @code{dp} registers are not set.
When action processing is complete, the one event of note-on or note-off will be output. registers/macro updates within the action are valid.
If you change the @code{n} register to @code{REST}, the output of events are suppressed.

Note that you would use @code{case(note_on, note_off)} and @code{case(note)} for different things.
In the former case, two separate actions are called for each of the note-on and
note-off events of the pair, while only one action is called in the latter case.
 
 @subheading For extended control changes

This covers both single and continuous extended control change events in the event buffer.
This Sets the following Registers / macros.
@code{t}, @code{tk}, @code{ch} (when control number is 192 or more, undefined
value), @code{n} (key pressure only), @code{etype}, @code {val} and @code{ctype}.
@code{etype} holds the controller number.
In order to modify the event, on the @code{ctype} other
Which register / macro also be changed
It works. If you change the @code{etype}, it is is changing the controller number
You can you but, control change other than the event code (ie 256 or more)
It is not possible to change.
Similarly, the @code{ch} and @code{n}
If you change the referenced control change that is, these
You need to set the register to the correct value.

Among the actions for the control change, in addition to the normal commands,
You can run the following commands.

@table @t
@item @r{C:} ctrl_any(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_any
@end table

@c helpme: Yes, this is english, but needs improving.
@c raw google translation here as placeholder.
@code{ctrl_any}, the events from the event buffer
If it was a control change not continuous, and @code{ctrl} command
I will act exactly the same. Event from the event buffer
If it is a continuous control change, in accordance with its type,
@code{ctrl_to}, @code{ctrl_pt}, of the @code{ctrl_cto}
I will work the same as any.
@code{ctrl_to} and @code{ctrl_cto} value to be specified in the third argument subsequent commands
For, the same as the value that the event has from the event buffer is assumed.

@subheading In the case of exclusive

This covers exclusive, or any message events in the event buffer.
The @code{t}, @code{tk}, @code{etype} and @code{val} registers/macro are set.
@code{val} will be an array of message data. In @code{excl} command
If that generated the exclusive event, at the end of this sequence,
0xf7 has not been added. In the case of @code{excl2} or @code{arbit} events,
the data array specified by the argument is left as is.
To correct the event, you can modify the @code{t}, @code{tk} and @code{val} values.
 
@subheading In the case of meta-events

If the event from the event buffer is a meta-event,
@code{t}, @code{tk}, @code{etype} and @code{val} will be set.
@code{etype} minus 256 is the meta-event type number.
@code{val} is:
If you specify a sequence number event by @code{case(seqno)}, an integer,
a text event with @code{case(text(@dots{}))} becomes a string,
in the case of other meta events, or if @code{case(meta(@dots{}))} refers to the
two event types above, it will be an array of data.
To modify the event, you can change the values of @code{t}, @code{tk}, and @code {val}.
However, you can not change the type of @code{val}.

@subheading Summary

The table below summarizes the registers/macros that are set in each event type.
@code{rw} indicates a value that is set and is possible to change,
while @code{ro} represents a value that is set, but cannot be changed.

@example
Event Type  |   t   tk  ch   n   v  nv  do/dp  etype  val  ctype
------------+----------------------------------------------------
note        |   rw  rw  rw  rw  rw  rw    rw    ro         
note_on     |   rw  rw  rw  rw  rw              ro         
note_off    |   rw  rw  rw  rw      rw          ro         
ctrl        |   rw  rw (rw)(rw)                 rw    rw    ro 
excl,arbit  |   rw  rw                          ro    rw    
meta        |   rw  rw                          ro    rw   
@end example

@node Attaching Effectors, Changing Valid Flags, Event Actions, Effectors
@section Attaching effectors
@cindex attaching effectors
@findex attach

You can attach an effector in the following two ways.

@table @t
@item @r{C:} @r{[}@var{scope}@r{]}@var{class-name}(@var{argument}, @dots{})
@item @r{C:} attach(@r{[}@var{scope}@r{]}@var{class-name}(@var{argument}, @dots{}), @var{instance-name} @r{[}, @var{enable}@r{]})
@end table

@var{class-name} Is the class name of the effector to attach.
@var{class-name} assumes the current thread or identifier dictionary of its ancestors thread
and if it is registered, you can omit the scope specifier @var{scope}.
Otherwise you need the scope specification (@pxref{Scope Specifiers}).

@var{argument} are the arguments to pass to the action.

In The case of the first format, an anonymous effector instance  is created.
In the case of the second form, @var{instance-name} is the name of the effector
instance that will be created. You can use this to distinguish between two
instances of an effector class with different parameters, for example.
@var{instance-name} will be registered to a dictionary in the current thread.
You can not put a scope specification for the instance name.

@var{Enable} in the second form is the initial value of the effector valid flag.
You can specify 0 or 1. If omitted, or in the case of the first format,
The initial value of the effector valid flag is set to 1.

Although an effector thread is created when the effector is attached, the
@code{dt} register is not copied over, and set to 0.
The values of the other registers of the current thread will be carried over.

@node Changing Valid Flags, Changing Through Bits, Attaching Effectors, Effectors
@section Changing effector valid flags
@cindex changing effector valid flags
@findex enable
@findex disable

@code{enable} sets The effector valid flag (@pxref{Effector Valid Flags}),
and @code{disable} resets the flag.

@table @t
@item @r{C:} enable(@r{[}@var{scope}@r{]}@var{effector})
@item @r{C:} disable(@r{[}@var{scope}@r{]}@var{effector})
@end table

@var{effector} can either be an effector instance name, or effector class name.
In the case of an effector class name, the setting of the valid flag is carried out
among the effectors that are attached to the current thread, for all instances that belong to the specified effector class.
In the case of the instance name, the valid flag is changed for only the specified instance of the effector,
in the current thread or identifier dictionary of its ancestors threads.
And if it is registered, you can omit the scope specification @var{scope}.
Otherwise you need the scope specification (@pxref{Scope Specifiers}).

You can set the valid flag for an effector instance using only the effector
instance name, as follows.

@table @t
@item @r{C:} @r{[}@var{scope}@r{]}@var{instance-name}
This is the same as @code{enable(@r{[}@var{scope}@r{]}@var{instance-name})}.
@end table

It is much faster to change the effector valid flag, than it is to detach and
reatach the same effector.
Therefore, when using the same effector in a number of different locations,
it is better to set the valid flag to 1 when an effector is needed, and reset it
to 0 when not.

The effector valid flag is present in each thread of each effector instance.
Therefore, if the flag is changed in a child thread, it will return to its
original state when the thread ends. See the example below.

@example
octave()    // Attaching the octave effector
C D E 
@{ disable(octave) F G @}    // octave not applied to F and G notes
A          // A added to octave buffer.
@end example

@node Changing Through Bits, Undefining Effectors, Changing Valid Flags, Effectors
@section Changing threw bits
@cindex Changing threw bits

The commands that allow you to change the effector through bits (@pxref{Through Bits})
are as follows. The @var{effector} first argument of each command can either be an
effector class name or effector instance name.
Also these commands can be in the @code{init} action of the effector definition.
In that case, @var{effector} can be empty, meaning set through bits for this
effector being defined.

If @var{effector} is an effector class name, the through bits are changed for
all instances that belong to the specified effector class, Among the effectors
that are attached to the current thread.
 When an instance name is given, the through bits are only changed for that particular effector instance.
If @var{effector} is omitted, changes are made to the currently attached 
effectors in the thread.

@table @t
@item @r{C:} set_thru_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex set_thru_etypes
set the specified event types through bits to 1, leaving the rest at 0.
See the @ref{Event Types} for the event type.

@item @r{C:} set_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex set_eff_etypes
Set the specified event type's through bits to 0, while leaving the rest set to 1.

@item @r{C:} add_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex add_eff_etypes
Change the event through bit of the specified event type to 0,
the rest are left intact.

@item @r{C:} del_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex del_eff_etypes
Change the event through bit of the specified event type to 1,
The rest are left intact.

@item @r{C:} set_thru_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex set_thru_chs
Sets the channel through bit For a given MIDI channel to 1, and then change the rest to 0.
You can specify the MIDI channel numbers in a given range with @samp{-}.
You can not use expressions in the channel number, but macro calls are possible.

@item @r{C:} set_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex set_eff_chs
For a given MIDI channel, the channel through bit is set to 0, and then change the rest to 1.

@item @r{C:} add_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex add_eff_chs
For a given MIDI channel, change the channel through bit to 0, and the rest are left intact.

@item @r{C:} del_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex del_eff_chs
For a given MIDI channel, change the channel through bit to 1, and the rest are left intact.
@end table

As mentioned in @ref{Through Bits}, when you attach an effectOr, those events
that have actions associated with them have their event through bits set to 0.
Those with nothing associated have them set to 1.
If you change the through bits for actions from 0 to 1, those events are deleted
from the event buffer.

The example below is an effector to remove certain types of events.

@example
/* Effector to remove the types of events as an argument */
defeff(reject_events) @{ 
  init @{
    set_eff_etypes()($@@)
  @}
  case(all) @{  
    reject
  @}
@}

reject_events(excl, arbit) // Remove all exclusive events
@end example

@noindent
In the example above,

@example
  case(all) @{  
    reject
  @}
@end example

@noindent
This will work in the same way, even if the above was not included,
however, it makes the effector logic easier to understand.

To make an  effector to extract the events of a specific MIDI channel,
As shown below, in addition to setting the channel through bit,
you must set the through bit of events that use a midi channel number to 0 with
@code{set_eff_etypes}. If @code{set_eff_etypes} is not used, the through bit is set unconditionally for all event types.
Thus, channel through bits will no longer have any meaning.

@example
/* Effector to remove events other than those on channel 1. */
defeff(chan1only) @{
  init @{
    set_thru_chs()(1)
    set_eff_etypes()(note, ctrl(0-191))
  @}
@}
@end example

@node Undefining Effectors, Effector Examples, Changing Through Bits, Effectors
@section Undefining effectors
@cindex undefining effectors
@findex undef

The @code{undef} macro command to cancel a macro definition, can also be used in
order to cancel an effector definition.

@table @t
@item @r{MD:} undef(@r{[}@var{scope}@r{]}@var{effector})
@end table

@var{scope} is the scope specification.
It can be omitted to use the current scope (@pxref{Scope Specifiers}).
@var{effector} Is the class name or instance name of the effector.
In the case of the class name, effector definition is canceled.
In the case of the instance name, the effector instance changes to instances of anonymous.
It is not possible to detach the effector with @code{undef}.

@node Effector Examples, Predefined Effectors, Undefining Effectors, Effectors
@section Effector Definition Examples
@cindex Effector Definition Examples

@subheading Time Stretcher
@cindex Time Stretcher

This effector scales the time of events, based on the difference between the current event and the time of attach.
The magnification is specified in the argument when the effector is attached.

@example
defeff(time_stretch, "n") @{
  init @{
    $attach_time = t
  @}
  case(all) @{
    t = (t - $attach_time) * $1 + $attach_time
  @}
@}
@end example

@subheading Arpeggio effector
@cindex Arpeggio effector

When you attach this effector, each constituent note of a chord is played with
a temporal displacement. The argument specifies the amount of shift time.
Notice how the check is made to determine if the new note is played at the same
time as the previous note or not.

@example
defeff(arpeggio, "r") @{
  init @{
    $previous_time = -1u
  @}
  case(note) @{
    if( $previous_time != t ) @{
       $delay = 0
    @} else @{
       $delay += $1
    @}
    $previous_time = t
    t += $delay
    du -= $delay
  @}
@}
@end example

@subheading Effector to perform thinning of events
@cindex Events thinning of

This effector can reduce MIDI communication by removing controller values with the same value
in a certain amount of time. This example shows this being applied to volume
control, where control values that have a difference equal to or greater than
the argument are kept.
To Delete controllers, the @code{reject} command is used.
@c helpme: unsure how to translate this paragraph.
なお、このエフェクタは１つのトラックには１つのMIDIチャネル
しか含まれていないことを仮定してます。

@example
defeff(thin_volume, "n") @{
  init @{
    $prev_val = -10000
  @}
  case(ctrl(Vol)) @{
    if( abs(val - $prev_val) >= $1 ) @{ 
       $prev_val = val
    @} else @{
      reject
    @}
  @}
@}
@end example

@node Predefined Effectors, Virtual Controllers and Effectors, Effector Examples, Effectors
@section Pre-defined effectors
@cindex Pre-defined effectors
@cindex Built-in effectors
@cindex Standard effectors

There are two types of predefined effector classes listed below.
Effector classes that are built-in to the compiler, denoted by @samp{BE:}.
Effector classes defined in the startup file, denoted by @samp{SE:} 

translator's note: As a temporary placeholder, the original Japanese 
text of the manual is included below, however, english documentation for 
all effectors denoted by @samp{SE:} can be found in the library files 
@samp{_effs.pml} and @samp{_roll.pml}. English text resumes with the 
@code{$smfout} effector description. 

@table @t
@item @r{SE:} modify_notes(@var{command} @dots{})
@findex modify_notes
各音符に対してイベントアクション @var{command} @dots{} を適用すること
によって、音符の属性などを修正します。
例えば、 @code{modify_notes(v+=20)} は各音符のベロシティを 20 増やし、
@code{modify_notes(du*=0.8)} は各音符の持続時間を 80% に削減します。

@item @r{SE:} add_notes(@var{command} @dots{}, @var{command} @dots{}, @dots{})
@findex add_notes
各音符に対して新しい音符群を追加します。
追加する各音符について１つの引数を指定し、そこには
追加する音符に対する修飾子の内容を書きます。
例えば、@code{add_notes(n+=12 v-=20)} は各音符に対してベロシティを 20 減じた
オクターブ上の音を追加し、
@code{add_notes(n+=4, n+=7)} は各音符を基音とする長三和音を構成します。

@item @r{SE:} modify_ctrl(@var{ctrl-num}, @var{command} @dots{})
@findex modify_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベントに
対してイベントアクション @var{command} @dots{} を適用します。
例えば、@code{modify_ctrl(7, val*=1.2)} は、連続コントロールチェンジを
含む各ボリュームコントロールに対して、そのコントロール値を 1.2 倍します。

@item @r{SE:} sel_events(@var{event-type}, @dots{})
@findex sel_events
指定されたイベント種別のイベントだけを残して、あとを削除します。
イベント種別については @ref{Event Types} を御覧下さい。

@item @r{SE:} rej_events(@var{event-type}, @dots{})
@findex rej_events
指定されたイベント種別のイベントを削除します。
例えば、@code{rej_events(excl)} はエクスクルーシブイベントを取り除きます。

@item @r{SE:} sel_chs(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex sel_chs
指定されたMIDIチャネル以外のイベントを削除します。
MIDIチャネルに関係のないイベントは削除されません。
MIDIチャネルの指定法は @code{thru_chs} コマンドと
同じです(@pxref{Changing Through Bits})。

@item @r{SE:} rej_chs(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex rej_chs
指定されたMIDIチャネルのイベントを削除します。
MIDIチャネルの指定法は @code{thru_chs} コマンドと
同じです(@pxref{Changing Through Bits})。

@item @r{SE:} tr_chs(@var{from1}, @var{to1}, @var{from2}, @var{to2}, @dots{})
@findex tr_chs
MIDIチャネルの置換を行います。
イベント中のMIDIチャネル @var{fromX} は @var{toX}（@var{X} = 1, 2, @dots{}) に
置き換えられます。

@item @r{SE:} remap_chs(@var{ch1}, @var{ch2}, @dots{}, @var{ch16})
@findex remap_chs
MIDIチャネルの一斉置換を行います。
イベント中のMIDIチャネル @var{X} は @var{X} 番めの引数で示される
MIDIチャネルに置き換わります。

@item @r{SE:} tr_prog(@var{from1}, @var{to1}, @var{from2}, @var{to2}, @dots{})
@findex tr_prog
プログラムチェンジのイベントに対してプログラム番号の置換を行います。
プログラム番号 @var{fromX} は @var{toX}（@var{X} = 1, 2, @dots{}) に
置き換えられます。

@item @r{SE:} tstretch(@var{rate})
@findex tstretch
アタッチしたときの時刻の基準として、
そこから各イベントまでの時間差を @var{rate} 倍に引き延ばします。

@item @r{SE:} swing(@var{period}, @var{percentage})
@findex swing
アタッチしたときの時刻から始まる周期 @var{period} の各時間区間について、
周期を２等分した時刻が周期の @var{percentage} パーセントの時刻に移るように
線形の時間変換を行います。
例えば、@code{swing(q,75)} は２つの８分音符が付点8分音符と16分音符に
なるように時間変換を行い、@code{swing(h,66)} は２つの４分音符が
三連符のうちの４分音符と８分音符になるように時間変換を行います（
66/100 は 1/3 に一致しませんので、正確には三連符ではありません。
正確な三連符が必要なときは
有理数を用いて @code{swing(h, 200u/3))} と指定します。）

@item @r{SE:} arp(@var{delay-step})
@findex arp
和音がアルペジオで演奏されるように、
ノートオン時刻が同一の音符のそれぞれに対して、
0, @var{delay-step}, @var{delay-step} * 2, @var{delay-step} * 3, @dots{}
という値をノートオン時刻へ加えます。
ノートオフ時刻は変わりません。
例えば、@code{arp(s)} をアタッチした状態で @code{[c e g]} を演奏すると、
E音は16分音符の長さ、G音は８分音符の長さだけ遅れて発音されます。
アルペジオ演奏の順序を逆にしたい場合には、@code{[g e c]} のように
和音を逆順で書きます。

@item @r{SE:} rand_vel(@var{amplitude})
@itemx @r{SE:} fgrand_vel(@var{amplitude})
@findex rand_vel
@findex fgrand_vel
各音符のベロシティに、@minus{}@var{amplitude} から @var{amplitude} までの
範囲にある乱数を加えます。
@code{rand_vel} は白色雑音、
@code{fgrand_vel} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。

@item @r{SE:} rand_ntime(@var{amplitude})
@itemx @r{SE:} fgrand_ntime(@var{amplitude})
@findex rand_ntime
@findex fgrand_ntime
各音符のノートオンとノートオフの時刻に対して
@minus{}@var{amplitude} から @var{amplitude} までの範囲の乱数を加えます。
@code{rand_ntime} は白色雑音、
@code{fgrand_ntime} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。
コントロールチェンジなど他のイベントの時刻はそのままですので、
このエフェクタによって各音符の属性が変わってしまう可能性があります。

@item @r{SE:} rand_ctrl(@var{ctrl-num}, @var{amplitude})
@itemx @r{SE:} fgrand_ctrl(@var{ctrl-num}, @var{amplitude})
@findex rand_ctrl
@findex fgrand_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベント
に対して、そのコントロール値に
@minus{}@var{amplitude} から @var{amplitude} までの範囲の乱数を加えます。
連続コントロールチェンジの場合には、
個々のコントロールチェンジイベントに直されてから乱数が加えられます。
@code{rand_ctrl} は白色雑音、
@code{fgrand_ctrl} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。

@item @r{SE:} dump()
@findex dump
イベントの内容をテキストとして出力します。

@item @r{SE:} auto_accent(@var{period}, @var{accent1}, @var{accent2}, @dots{})
@findex auto_accent
音符に一定のリズムにしたがって自動的にアクセントをつけます。
アタッチしたときの時刻から始まる
周期 @var{period} ごとに区切った時間区間を考え、
各音符について、それがある時間区間の先頭から発音が始まっている場合、
或は１つ前の時間区間の先頭以外で発音されいてそれが次の時間区画まで
持続している場合（これはシンコペーションの場合に相当する）に
その音符のベロシティーを増加させます。
増加されるベロシティーの大きさは第２引数以降で表され、
２つ以上指定されている場合には、各時間区画ごとに巡回的にそれらが
使用されます。
例えば、@code{auto_accent(h,40,20)} は 4/4 拍子における各小節の
１拍目にある音符のベロシティーを 40 増やし、３拍目にある音符の
ベロシティーを 20 増やします。

@item @r{SE:} roll(@var{assignments})
@findex roll
パーカッションでのロール奏法やストリングスでのトレモロ奏法を実現するように
音符を短い音符の列に分割します。和音の場合は、
分割された短い音符のそれぞれがすべての音を含む和音になります。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item speed = @var{speed}
分割された音符間の間隔を指定します。
デフォルト値は @code{z} つまり32分音符です。

@item attack = @var{velocity-increment}
最初の音符だけに特別に与えられるベロシティー増加値を指定します。
デフォルト値は 30 です。

@item decay = @var{decay-factor}
ベロシティーの減衰率を指定します。
分割された各音符のベロシティーは１つ前の音符のベロシティーに
この減衰率を乗じたものになります。デフォルト値は 0.9 です。

@item sustain = @var{sustain-level}
ベロシティーの下限値を指定します。
ベロシティーが減衰して @var{sustain-level} 以下になった場合には、
@var{sustain-level} にベロシティーが修正されます。
@var{sustain-level} が 0 の場合は、
次項の @var{relative-sustain-level} によって下限値が決定されます。 
@var{sustain-level} のデフォルトは 0 です。

@item rsustain = @var{relative-sustain-level}
ベロシティーの下限値を元の音符のベロシティーに対する相対値で
指定します。すなわち、元の音符のベロシティーにこの値を乗じたものが、
下限値として使用されます。この指定が有効なのは、
前項の @var{sustain-level} が 0 のときだけです。
@var{relative-sustain-level} のデフォルトは 0.7 です。

@end table

@noindent
上のデフォルト値はそれぞれ @code{roll_speed}, @code{roll_attach},
@code{roll_decay}, @code{roll_sustain}, @code{roll_rsustain} という
グローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@noindent
@code{roll} の使用例:

@table @code
@item roll()
すべてデフォルトの設定で音符を分割します。
@item roll(speed=z/2)
分割の間隔を64分音符にして音符を分割します。
@item roll(attack=0 decay=0)
一定のベロシティで音符を分割します。
@end table

@item @r{SE:} tremolo(@var{assignments})
@findex tremolo
ピアノやマリンバにおけるトレモロ奏法を実現するように
音符を短い音符の列に分割します。和音の場合は、その構成音が２つのグループ
に分けられ、各グループが交互に演奏されます。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item speed = @var{speed}
@itemx attack = @var{velocity-increment}
@itemx decay = @var{decay-factor}
@itemx sustain = @var{sustain-level}
@itemx rsustain = @var{relative-sustain-level}
これらの意味は上記の @code{roll} エフェクタと同じです。
ただしデフォルト値は異なり、
@code{speed=z attack=0 decay=1.0 sustain=0 rsustain=1.0} です。

@item group = @var{number-of-notes}
これは和音の構成音をグループ分けするときの分け方を決定します。
交互に演奏される音符群のうち先に演奏される方を第１グループ、
後から演奏される方を第２グループとしたとき、
和音の構成音のうち最後の @var{number-of-notes} 個が第２グループになり、
残りが第１グループになります。
デフォルトの @var{number-of-notes} の値は 1 です。      
例えば、デフォルトの設定では @samp{[C E G]} は 
@samp{[C E] G [C E] G @dots{}} と演奏されますが、@code{group} を 2 に
設定すれば @samp{C [E G] C [E G] @dots{}} と演奏されるようになります。
@end table

@noindent
上のデフォルト値はそれぞれ @code{tremolo_speed}, @code{tremolo_attach}, 
@code{tremolo_decay}, @code{tremolo_sustain}, @code{tremolo_rsustain},
@code{tremolo_group} というグローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@item @r{SE:} thin_ctrl(@var{ctrl-num}, @var{value-step})
@findex thin_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベント
に対して、隣合うコントロール値の差が @var{value-step} 以上になるように
イベントを間引きます。

@item @r{SE:} quantize(@var{step} @r{[}, @var{assignments}@r{]})
@findex quantize
アタッチしたときの時刻を基準として計った
各イベントの時刻を、@var{step} の倍数に
なる（あるはそれに近づく）ように修正します。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item etype = '@var{event-type}, @dots{}'
時刻修正を行うイベントの種類を指定します。
イベント種別名(@pxref{Event Types})のリストをシングルクオートで囲んで
下さい。
デフォルト値は @code{'note'} です。

@item strength = @var{strength}
時刻修正の強さを指定します。
この値が 100 であると、結果として得られる時刻が
ちょうど @var{step} の倍数になるように、時刻に修正値が加えられます。
100 未満の場合は、その修正値が @var{strength}% に軽減されます。
デフォルト値は 100 です。

@item window = @var{window-width}
時刻修正が適用される範囲を指定します。
時刻修正は、修正前時刻とそれに最も近い @var{step} の倍数との差が
@var{step} * @var{window-width}/100 未満であるときだけ行われ、
それ以外の場合はもとの時刻が保たれます。
デフォルト値は 100 です。

@item keepdur = 0 または 1
@code{keepdur} が 0 のときは、ノートオフイベントについても
ノートオンイベントと同じようにして時刻修正が行われます。
@code{keepdur} が 1 のときは、
音符の持続時間が変わらないようにノートオフイベントの時刻を
ノートオン時刻に合わせて修正します。
デフォルト値は 1 です。
@end table

@noindent
例えば、すべての種類のイベントに対して16分音符でのクオンタイズをかける
には @code{quantize(s, etype='all')} とします。
上のデフォルト値はそれぞれ @code{quantize_etype}, @code{quantize_strength}, 
@code{quantize_window}, @code{quantize_keepdur} という
グローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@item @r{BE:} $smfout(@var{filename}, @var{resolution}, @var{format}, @var{R}, @var{d}, @var{n}, @var{chmask}, @var{trklist} @r{[}, @var{begin}@r{[}, @var{end}@r{]]})
@findex $smfout
Writes an event to a standard MIDI file.
This effector It is attached in the startup file, as the terminating effector (@pxref{Effector Chain}).
@var{filename} is a MIDI file name,
If you omit the extension @samp{.mid} it is assumed and added.
@var{resolution} and @var{format} set the resolution and format of the MIDI file.
@var{resolution} can also specify 0 to allow the maximum resolution to be used,
from the following choices. Specification in the source text, or the maximum
resolution of MIDI files read with the @code{load} or the @code{loadtrk} commands.
If none of these are given, the resolution is set to 480.
It is also possible to set @var{format} to @minus{}1.
In this case, if only one track of events are generated, produce format 0 output, otherwise format 1.
@c helpme: unsure how to translate this sentence.
@var{R}, @var{d}, @var{n} はいずれも
0 または 1 の整数であり、1 のときそれぞれ @samp{-R}, @samp{-d}, 
@samp{-n} オプションを指定したのと同じ効果が得られます(@pxref{Options})。
@var{chmask} is the value of the channel through bit, as a 16-bit integer where
The least significant bit corresponds to MIDI channel 1.
@var{trklist}, @var{begin}, @var{end} can be strings, equivalent to the
@samp{-T}, @samp{-f} and @samp{-t} command line options
(@pxref{Options}).
An empty string has the same effect as not specifying these options.
@end table

@node Virtual Controllers and Effectors,  , Predefined Effectors, Effectors
@section Virtual controllers and effectors
@cindex Virtual controllers and effectors

By utilizing the effector, the user can freely define the meaning of a virtual controller (@pxref{Virtual Control Change}).
For example, the following virtual controller number 200 is defined to control
the master volume using an exclusive message.
The @code{msvol_handler} effector performs processing to replace controller
number 200 with exclusive events that control a master volume setting. Because a
virtual control event is used, it becomes possible to handle the master volume just as any other controller would be handled.
For example, as shown in the last line, you can continuously change the master
volume with a continuous control change event.

@example
defeff(msvol_handler, "", ExpandCtrl) @{
  case(ctrl(200)) @{ 
    excl(#(0x7f,0x7f,0x04,0x01,0x00,val))
    reject        // Delete the original event
  @}
@}

msvol_handler()   // Attach the effector

ctrl(200, 100)    // Set the master volume to 100
E D C 
ctrl_to(200, 0, 15u, 1)   // Decrescendo using master volume
@end example

@noindent
The @code{ExpandCtrl}effector flag is required. If this is not present,
if a continuous control change is used, only the points of the control curve
are converted to exclusive events, and not the full range of values.

@c --------------------------------------------------------------------
@node Communication, Reading MIDI files, Effectors, Top
@chapter Inter-thread communication
@cindex Inter-thread communication

@c Helpme: This is quite an advanced feature, so I am leaving
@c this entire chapter untranslated at present. Help definitely welcome!
Translator's note: Due to this being a fairly advanced feature of PMML, this 
draft of the translation will leave the original Japanese text as is.

PMMLはメッセージパッシングによるスレッド間通信の機能を持っています。
この機能は、実際の合奏において指揮と演奏者間、或は演奏者どうしで
行われる様々な情報交換を模倣するために利用できます。
例えば、あるスレッドにおいて、同じパターンを繰り返し演奏していて、
別のスレッドからの合図が送られて来たらコーダへ飛ぶというときに、
スレッド間通信は役立ちます。

@menu
* Overview of ITC::             スレッド間通信の概要。
                                メッセージ、通信チャネル、シグナルとは？
* Sending Messages::            メッセージを送る signal コマンド  
* Receiving Messages::          メッセージを受け取る wait コマンド 
* Alternation::                 複数の通信チャネルの監視。メッセージ待ちの
                                間に別の処理をする方法。  
* Destroying Channels::         通信チャネルの破壊方法
@end menu

@node Overview of ITC, Sending Messages, Communication, Communication
@section スレッド間通信の概要
@cindex メッセージ
@cindex 通信チャネル
@cindex シグナル

スレッド間で交換されるデータは @dfn{メッセージ} と呼ばれます。
メッセージの型にはPMMLにおけるすべてのデータ型が使えます。
また、メッセージは空でも構いません。
空のメッセージは @dfn{シグナル} と呼ばれ、
スレッド間の同期を行うために利用されます。
なお、@ref{Wait for Child Threads} で述べられている
子スレッドの実行終了待ちコマンドも簡単なスレッド間同期を
実現しますので、それで機能的に十分であればそちらを使った方が
少ない計算量で済みます。

メッセージは @dfn{通信チャネル} と呼ばれる媒体を介して転送されます。
通信チャネルは無限長のメッセージキューを持ち、従って、送り手が待たされる
ことは一切ありません。
１つの通信チャネルに対して複数のスレッドがメッセージを
送出しても構いません。
通信チャネルは通信チャネル名という名前を持ちます。
通信チャネル名は常にグローバルです。つまり必ずルートスレッドの
識別子辞書に登録されます。

通信はすべてブロードキャスト通信です。
したがって、通信チャネルに送られたメッセージは自分を含むすべての
スレッドに対して届きます。
各スレッドはその届いたメッセージを
必ずしも受け取る必要はありません。
つまり、無視しても構いません。

メッセージの送出は @code{signal} コマンド、
受取は @code{wait} コマンドによって行います。
複数の通信チャネルを継続的に監視し、
もしそのどれかにメッセージが到着していればそれを受け取り、
さもなければ別の処理を行う @code{alt} コマンドも用意されています。
通信チャネルはこれらのコマンドのうち一番最初に実行されたものによって
作成されます。@code{undef} コマンドによって明示的に破壊されない限り、
一度作られた通信チャネルはコンパイルが終了するまで残ります。

@node Sending Messages, Receiving Messages, Overview of ITC, Communication
@section メッセージの送出
@cindex メッセージの送出
@findex signal

@code{signal} コマンドはメッセージをブロードキャストします。

@table @t
@item @r{C:} signal(@var{channel} @r{[}, @var{message}@r{]})
@end table

@var{channel} は通信チャネル名であり、同名の通信チャネルが無いときには
新たな通信チャネルが作成されます。
@var{message} は任意の型の式であり、送出するメッセージの内容を意味します。
@var{message} を省略すると内容が空のメッセージ、
つまりシグナルが送出されます。
送られるメッセージには送出時刻（@code{signal} を実行した
時の @code{t} レジスタの値）を示すタイムスタンプが記録されます。

@code{signal} コマンドがブロックする、つまり @code{signal} コマンド
によって @code{t} レジスタの値が増加することはありません。

@node Receiving Messages, Alternation, Sending Messages, Communication
@section メッセージの受け取り
@cindex メッセージの受け取り
@findex wait

@code{wait} コマンドはメッセージが到着するのを待って受けとります。

@table @t
@item @r{C:} wait(@var{channel} @r{[}, @r{[}@var{scope}@r{]}@var{macro-name}@r{]})
@end table

@var{channel} は通信チャネル名であり、同名の通信チャネルが無いときには
新たな通信チャネルが作成されます。
@var{macro-name} と @var{scope} はメッセージを受けとるための
変数型マクロの名前とその通用範囲指定です。
受け取るメッセージが空（シグナル）の場合、
@var{macro-name} を指定してはいけません。
逆に、空でないメッセージのときに @var{macro-name} を省略することは可能
であり、この場合でもメッセージを受け取られますが、その内容は捨てられます。

@code{wait} コマンドは、通信チャネル @var{channel} にメッセージが
既に到着していれば待たずにそれを受けとりますが、もしまだメッセージが
到着していない場合には到着するのを待って受けとります。
すなわち、@code{wait} コマンド実行後の @code{t} レジスタの値は、
実行前の @code{t} レジスタの値と到着したメッセージのタイムスタンプの
うちの最大値になります。受け取ったメッセージは
次のような代入コマンドを実行した場合と全く同じようにして変数マクロに格納
されます。

@example
@r{[}@var{scope}@r{]}@var{macro-name} = @r{メッセージの内容}
@end example

@code{signal} によってメッセージはブロードキャストされますので、
あるスレッドにおいて @code{wait} によってメッセージを受け取り、
その後に別のスレッドで @code{wait} を実行すると、やはり
同じメッセージを受けとることになります。
しかし、これには例外があります。
@samp{&} を伴わないグルーピングコマンド(@pxref{Grouping})または
@samp{&} を伴わない和音コマンド(@pxref{Chords})によって生成された
子スレッドは、その親スレッドと同一視され、もし子スレッドでメッセージを
受け取っても親スレッドが受け取ったものとみなされます。
下の例２を参照してください。
なお、@samp{&} つきのグルーピングコマンドや和音コマンドの場合は
この例外規定は適用されず、別なスレッドだと見なされます。

修飾子またはエフェクタアクションの中で @code{wait} コマンドを使用することは
できません。

@subsubheading @code{wait} の使用例１

@example
defthread(t1,t2,t3)

t1 @{
  C
  signal($e, "hello") // 通信チャネル $e に "hello" という文字列を送る
  D E
  signal($e)          // 通信チャネル $e にシグナルを送る
  F
@}

t2 @{
  wait($e, msg)
  print(msg)
       @print{} hello
  F                   // このF音はt1スレッドのD音と同時に発音される。
  wait($e)
@}

t3 @{
  G A 
  wait($e, msg)       // この wait は待たずにメッセージを受け取る
  print(msg)
       @print{} hello
  wait($e)
  C                   // このC音はt1スレッドのF音と同時に発音される。
@}
@end example

@subsubheading @code{wait} の使用例２

@example
defthread(t1,t2,t3)

t1 @{
  signal($e, 1)
  signal($e, 2)
@}

t2 @{
  C 
  /* 
   * 下の wait は t2 スレッドとは独立にメッセージを受け取る。
   */
  @{ E wait($e, msg) @}&   // msg は 1 になる
  /* 
   * 下の wait は t2 スレッドがメッセージを受け取ったと見なされる。
   */
  @{ G wait($e, msg) @}    // msg は 1 になる
  /* 
   * 下の wait は既に上の wait によって１つメッセージを受け取られて
   * いるので、２番目のメッセージを受け取る。
   */
  wait($e, msg)          // msg は 2 になる
@}
@end example

@node Alternation, Destroying Channels, Receiving Messages, Communication
@section 複数の通信チャネルの監視
@cindex 複数の通信チャネルの監視
@cindex 選択待機
@cindex 代替
@findex alt

@code{alt} コマンドは、複数の通信チャネルを継続的に監視し、
もしそのどれかにメッセージが到着していればそれを受け取り、
さもなければ別の処理を行います。

@table @t
@item @r{C:} alt @{ @var{guard} @dots{} @}
@end table

@noindent
ここでガード @var{guard} は次の２種類のうちのいずれかです。
１つの @code{alt} は任意個のガードを取ることができます。

@table @t
@item case(@var{channel} @r{[}, @r{[}@var{scope}@r{]}@var{macro-name}@r{]}) @{ @var{command} @dots{} @} 
このガードは通信チャネルガードと呼ばれ、
通信チャネル @var{channel} にメッセージが
到着したときに、@code{wait} コマンドと
全く同じようしてメッセージを受けとり、
さらにコマンド列 @var{command} @dots{} を実行するという働きがあります。
 
@item default @{ @var{command} @dots{} @}
このガードは @code{default} ガードと呼ばれ、
メッセージを受けとれる通信チャネルガードが無いときに
コマンド列 @var{command} @dots{} を実行する働きがあります。
@end table

@code{alt} は以下に述べる処理を無限に繰り返します。
まず、@code{alt} は通信チャネルガードに示されている
各通信チャネルに対して、現時刻（@code{t} レジスタの値）以前の
タイムスタンプを持ったメッセージが到着しているかどうかを調べます。
到着している場合には、そのメッセージを @code{wait} コマンドと
全く同じようにして受けとり、さらに対応するガード中のコマンド列を実行します。
複数の通信チャネルガードに到着している場合には、
その中で最小のタイムスタンプを持っているメッセージが選ばれ、
それに対応するガードが実行されます。
タイムスタンプの値が同じ場合は先に書かれたガードが優先します。
現時刻以前のタイムスタンプを持ったメッセージが到着していない場合は、
@code{default} ガードがあればそのコマンド列を実行し、
無ければメッセージが到着するまで待つか、あるいは既に到着している
メッセージがあるのであれば @code{t} レジスタを
タイムスタンプのうちの最小値まで進めます。

@code{alt} コマンドはそれ自身でループの機能を持っている点に
注意して下さい。
@code{alt} コマンドを終了させるためには、ガード中のコマンド列の
中で @code{break} (@pxref{Break Command})を実行します。
なお、コンパイル処理の最後になっても @code{alt} がメッセージ到着
待ち状態になっている場合には、
警告が発せられるとともに @code{alt} コマンドは強制終了されられます。

@code{default} ガードのコマンド列は、@code{break} を実行する場合を
除き、必ず @code{t} レジスタを前進させるように書いて下さい。
そうでないと、一旦 @code{default} ガード
が実行されると、永久に @code{default} ガードが繰り返されることに
なります。

@code{wait} コマンドの場合と同じように、
@samp{&} を伴わないグルーピングコマンド(@pxref{Grouping})または
@samp{&} を伴わない和音コマンド(@pxref{Chords})によって生成された
子スレッドは、その親スレッドと同一視され、
もし子スレッドが @code{alt} によって
メッセージを受け取っても親スレッドが受け取ったものとみなされます。

修飾子またはエフェクタアクションの中で @code{alt} コマンドを使用することは
できません。

@subsubheading @code{alt} コマンドの使用例

@example
defthread(melody,base)

melody @{
  q G A B A h G q F E
  q E D C _B
  signal(the_end)   // the_end チャネルにシグナルを送る
  w C
@}

base @{
  alt @{ 
    case(the_end) @{
      break       // シグナルが到着したら alt を終了する
    @}
    default @{
      q G2 G3     // シグナルが到着するまで G2 G3 というパターンを
                  // 繰り返し演奏する
    @}
  @}
  w C2
@}
@end example

@node Destroying Channels,  , Alternation, Communication
@section 通信チャネルの破壊
@cindex 通信チャネルの破壊
@findex undef

マクロ定義を取り消すための @code{undef} マクロ指令は、
通信チャネルを破壊し、それに使われているメモリ
を解放する目的にも使用できます。

@table @t
@item @r{MD:} undef(@var{channel})
@end table

@code{undef} によって通信チャネル @var{channel} が破壊できるのは、
その通信チャネルに対して @code{wait} または @code{alt} を実行途中の
スレッドがない時だけに限られます。

メッセージを送信した側のスレッドで @code{undef} を実行することは、
メッセージが受け取られる前に通信チャネルを破壊してしまう可能性があるため、
現実的ではありません。
受信側のスレッドにおいてメッセージの受信が完了した後
で @code{undef} を実行する必要があります。
メッセージを２つ以上のスレッドで受けている場合には、
その受信の順番が不定ですから、@code{undef} によって安全にチャネルを
破壊する方法はありません。

@c --------------------------------------------------------------------
@node Reading MIDI files, Concept Index, Communication, Top
@chapter Reading standard MIDI files

In PMML, you can read the contents of a standard MIDI file into the event buffer.
the read events, and events generated by the event generation commands in response to effector processing will be placed together, and can be written to a new midi file.
You can also use this feature to modify existing midi files, or simply process them with PMML effectors.

@menu
* Load Command::                Read the entire MIDI file
* Loadtrk Command::             Read only one track
* Closing MIDI Files::          Closing MIDI files
* Get MIDI File Info::          Obtaining MIDI file info, such as number of tracks
@end menu

@node Load Command, Loadtrk Command, Reading MIDI files, Reading MIDI files
@section Reading of MIDI files
@cindex Reading of MIDI files
@findex load

@code{load} reads all of the tracks of a MIDI file into the event buffer.

@table @t
@item @r{C:} load(@var{filename}) @r{[}&@r{]}
@end table

@var{filename} is the file name of the standard MIDI file to be read,
the extension can be omitted in the case of @samp{.mid}.
Any resolution of MIDI file can be read if the value is positive.
A MIDI file with a negative resolution value cannot be read.

Each track of the MIDI file will be read into it's corresponding track number of the event buffer.
The value of the @code{tk} register is not referenced.

The time of each event that is placed into the event buffer will automatically have the value of (@code{t} + @code{dt}) added.
That is, playing the loaded song starts from the time of the (@code{t} + @code{dt}) registers.

If the @samp{&} option is not included,
After the end of the MIDI file, the value of the @code{t} register is set to the
playing time of the end of the longest track.
If the @samp{&} option is included, the value of @code{t} is left unchanged.

Each note on / off or key pressure event you read from a file has it's note
number added to by the value of the @code{tp} register, which is stored in the event buffer.
Thus, if the value of the @code{tp} register is anything other than 0, songs
that are read in with the @code{load} command are transposed.

Also, files read in with @code{load} will have there events processed by the
effectors that are attached to the thread.
In other words, MIDI files loaded with @code{load} can be processed by effectors,
as long as they allow the events with their effector through bit settings.

@node Loadtrk Command, Closing MIDI Files, Load Command, Reading MIDI files
@section Read only one track
@findex loadtrk

@code{loadtrk} reads only one track into the event buffer from a specified MIDI file.

@table @t
@item loadtrk(@var{filename}, @var{track-num}) @r{[}&@r{]}
@end table

The Track number @var{track-num} is the track number of the MIDI file.
The loaded events are placed into the track indicated by the @code{tk} register
For other arguments, they are the same as the @code{load} command.

If the Input file is a destructive (no backtracking) device, such as the receiving end of a pipe,
when you run @code{loadtrk} multiple times for the same file,
If you do not run the @code{loadtrk} in order from the smallest track number,
seeking in the file is impossible, so an error will result.

@node Closing MIDI Files, Get MIDI File Info, Loadtrk Command, Reading MIDI files
@section Closing the file
@cindex Close of MIDI files
@findex close

The @code{close} command will close the standard MIDI files that are open.

@table @t
@item close(@var{filename})
@end table

When you use the @code{loadtrk}, @code{ntrk}, @code{format} or @code{resolution} commands
with a new file, the file remains open after the command has finished executing,
to reduce processing time if the same file is requested later.
The @code{close} command is intended to close the file,
If you want to open a file beyond the file limit that can be open at the same time
(@pxref{Limitations}).
The @var{filename} can specify the same file name as when it is open.

@noindent
Note: You should not be running the @code{close} command for files opened by the @code{load} command,
Because  they are closed automatically.

@node Get MIDI File Info,  , Closing MIDI Files, Reading MIDI files
@section Acquisition of MIDI file information
@cindex Acquisition of MIDI file information

The following built-in functions are available to obtain information about the MIDI file.
In the file name that you specify in each command,
the extension can be omitted in the case of @samp{.mid}.

@table @t
@item ntrk(@var{filename})
Returns the number of tracks included in the specified standard MIDI file in @var{filename}.

@item format(@var{filename})
 Returns an integer (0, 1, or 2) that represents the format of the specified
 standard MIDI file @var{filename}.

@item resolution(@var{filename})
Returns the resolution of the specified standard MIDI file @var{filename}.
@end table

@c --------------------------------------------------------------------
@node Concept Index, Command and Macro Index, Reading MIDI files, Top
@unnumbered Concept index
@printindex cp

@c --------------------------------------------------------------------
@node Command and Macro Index,  , Concept Index, Top
@unnumbered Command and macro index
@printindex fn

@c --------------------------------------------------------------------
@summarycontents
@contents

@bye
