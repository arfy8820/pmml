\input texinfo.tex   @c -*-texinfo-*-
@setfilename pmml
@settitle PMML User's Manual

@finalout

@ifinfo
ＰＭＭＬユーザーズ・マニュアル

Copyright 1997,1998 (C)  Satoshi Nishimura
@end ifinfo

@c HTMLへ変換するには
@c   texi2html -split_chapter pmml.texi
@c を実行。
@c 第2,5,6,7,8,10章の章番号が変わった時には Simple Examples の中のタグに
@c 入っている章番号も変更する必要がある。

@ifinfo
@clear html
@end ifinfo

@titlepage
@title PMML User's manual

@ifclear html
@subtitle For the PMML interpreter Release 0.2
@author Satoshi Nishimura

@page 
@vskip 0pt plus 1filll
Copyright 1997,1998 (C) by Satoshi Nishimura
@sp 2
本マニュアルによって発生したいかなる損失についても
著作者は責任を負わないものとします。
@sp 2
PMMLおよびそのコンパイラの仕様は予告なく変更されることがあります。
@end ifclear
@ifset html
@author For the PMML interpreter Release 0.2
@author Last change: @today{}
@author Copyright 1997,1998 (C)  Satoshi Nishimura
@author 本マニュアルによって発生したいかなる損失についても著作者は責任を負わないものとします。
@author PMMLおよびそのコンパイラの仕様は予告なく変更されることがあります。
@end ifset


@end titlepage

@node Top, Overview, (dir), (dir)

@ifinfo
@top PMML

PMML(Practical Music Macro Language)は
コンピュータによるMIDI楽器の自動演奏を目的とした音楽記述言語です。
PMMLのソースファイルはPMMLコンパイラによって標準MIDIファイルへ
変換できます。本マニュアルは、PMMLの言語仕様とコンパイラ使用法の
両方について述べています。

PMMLに関する御意見・御感想・バグレポート等は @samp{nisim@@u-aizu.ac.jp} まで
お寄せ下さい。

本マニュアルによって発生したいかなる損失についても
著作者は責任を負わないものとします。

PMMLおよびそのコンパイラの仕様は予告なく変更されることがあります。
@end ifinfo

@menu
* Overview::                    PMMLの概要
* Basic Concepts::              マニュアル理解に必要な基本用語の解説 
* Simple Examples::             短いPMMLソースファイルの例 
* Compiler::                    コンパイラの起動方法、コマンド行オプション 
* Lexical Rules::               字句規則（コメント、定数の表記法など） 
* Data Types and Expressions::  データ型、式、演算子について
* Basic Commands::              基本的な音楽要素（音符、休符、和音など）の記述 
* Event Generating Commands::   コントロールチェンジ、プログラムチェンジ、
                                ピッチベンド、アフタータッチ、エクスクルーシブ
                                メッセージ、メタイベントを生成するコマンド
* Macros::                      マクロの定義と呼びだし
* Control Structures::          条件分岐と繰り返し
* Arrays::                      配列の操作法
* Built-in Functions::          組み込み関数 
* Effectors::                   エフェクタの使用法 
* Communication::               スレッド間通信と同期 
* Reading MIDI files::          標準MIDIファイルを読み込む方法 
* Concept Index::               概念索引               
* Command and Macro Index::     コマンド、マクロ索引 

 --- The Detailed Node Listing ---

基本概念

* MIDI Channels::               MIDIチャネルとは？ 
* Events::                      イベントとは？ 
* Tracks::                      トラックとは？ 
* Commands::                    コマンド、マクロ指令、組み込み関数とは？
* Glyphs::                      マニュアルで使用する記号の説明 

簡単なソースコードの例

* Single Part Example::         単一パートの例
* Multi Part Example::          複数パートの例 

上のソーステキストに関連する項目

* Rational Constants::          q, i など有理数定数の説明
* Pitch Constants::             ^D, G など音高定数の説明
* Note Command::                音符コマンドの説明
* Comments::                    // などコメントの記述法
* Changing Registers::          ^ _ などオクターブコマンドの説明

上のソーステキストに関連する項目

* Meta Events::                 tempo, timesig の説明
* Threads::                     スレッドの概念説明
* Creating Named Threads::      newtrack などスレッド生成の説明
* Register Sets::               ch, o, v などレジスタの説明
* Changing Registers::          ch=1 などレジスタの変更法
* Control-Change Events::       prog, vol などコントロール系コマンドの説明
* Switching Threads::           スレッド切り替えの方法
* Loops::                       繰り返しのコマンドの説明
* For Command::                 for コマンドについて
* Grouping::                    @{ ... @} の説明
* Note Duration::               dr=30 の説明
* If Command::                  if コマンドについて
* Operators::                   == など演算子の説明
* Continuous Control Change::   vol_to など連続コントロールチェンジの説明
* Chords::                      [ ... ] という和音コマンドの説明

コンパイラの起動

* Synopsis::                    PMMLコンパイラの起動方法
* Options::                     コマンド行オプションの説明        
* Start-up::                    コンパイラ起動時の処理について
* Output Process::              コンパイラ終了時の処理について 
* Output File::                 出力ファイルについて        
* Environment::                 環境変数        
* One Liner::                   ワンライナー（１行コマンド）の例        
* Limitations::                 コンパイラの制限事項        

出力処理

* Priority::                    イベント優先度                  
* Note Collision::              ノート衝突時の処理 

出力ファイルについて

* Output File Name::            出力ファイルのファイル名 
* Output Format::               出力ファイルのフォーマット 
* Output Resolution::           出力ファイルの分解能

字句規則

* Space Characters::            空白文字の意味 
* Comments::                    コメントの書き方 
* Integers::                    整数定数 
* Floating-Point Constants::    浮動小数点定数
* Pitch Constants::             音の高さを表す定数  
* Rational Constants::          有理数定数
* Strings::                     文字列定数 
* Identifiers::                 識別子（名前）の規則 
* Accents::                     アクセント記号 
* Time Shifters::               時刻シフト記号 
* Tokens::                      トークンの全種類のリスト 

データ型と式

* Data Types::                  PMMLの６つのデータ型について 
* Expressions::                 PMMLの式とは？
* Token-list Constants::        トークン列定数の書き方 
* Array Constants::             配列定数の書き方 
* Logical Values::              論理値の定義 
* Operators::                   すべての演算子とその意味の説明
* Type Conversion::             暗黙の型変換に関する規則 

基本的なコマンド

* Registers::                   レジスタの役割とその変更方法 
* Note Command::                音符コマンド 
* Note Length::                 音価（ステップタイム）の指定方法 
* Note Duration::               音の持続時間（ゲートタイム）の指定方法  
* Key::                         調と臨時記号について 
* Threads::                     スレッドの概念とその生成、切り替えの方法
                                和音、複数パートを記述する方法
* Modifiers::                   音符属性を一時的に変更する修飾子の説明 
* No Operation::                何もしないコマンド 

レジスタとその変更

* Register Sets::               全レジスタの一覧 
* Pseudo Registers::            疑似レジスタの一覧
* Changing Registers::          レジスタの値を変更する方法

スレッドとその関連コマンド

* Grouping::                    名前なしスレッドの生成し、一時的なレジスタの
                                変更を実現するグルーピングコマンドの説明
* Chords::                      和音の表現方法              
* Creating Named Threads::      名前つきスレッドの生成法  
* Switching Threads::           スレッドの切り替え方法 
* Wait for Child Threads::      スレッド間の時刻合わせを行うには？  
* Deleting Named Threads::      名前つきスレッドの消去法  

イベント生成コマンド

* Note Events::                 ノートオン、ノートオフの単独生成 
* Virtual Control Change::      仮想と拡張コントロールチェンジとは？ 
* Velocity Magnifier::          ベロシティー拡大率について 
* Control-Change Events::       コントロールチェンジ、プログラムチェンジ、
                                ピッチベンド、アフタータッチ、テンポ変更など
* Continuous Control Change::   連続的にコントロール値を変化させる方法  
* Exclusive Events::            エクスクルーシブと任意メッセージ 
* Meta Events::                 メタイベントの生成法。拍子設定、調の設定、
                                マーカーの挿入、曲名タイトルの挿入を含む。

マクロ

* Types of Macros::             マクロの分類
                                変数型マクロと関数型マクロの違い
* Calling Macros::              マクロの呼び出し方法      
* Defining Variable Macros::    変数型マクロの定義方法 
* Defining Function Macros::    関数型マクロの定義方法 
* Macro Examples::              関数型マクロの例 
* Local Macros::                ローカルマクロの使用法 
* Scope Rules::                 マクロの通用範囲に関する規則 
* Scope Specifiers::            名前の通用範囲を明示的に指定する方法 
* Macro Directive::             マクロ指令を実行できるのはどの位置か？
* Eval Macro Directive::        式の強制評価 
* Evalstr Macro Directive::     文字列のソーステキストとしての評価 
* Undefining Macros::           マクロ定義の取り消し法 
* Examine Empty Token Lists::   トークン列が空かどうか判定するには？ 
* File Inclusion::              他のソースファイルの読み込み 

関数型マクロの定義

* Argument Substitution::       マクロの引数を参照するには？
* Argument Spec::               引数仕様文字列の書き方 

制御構造

* Conditionals::                条件分岐のためのコマンド 
* Loops::                       繰り返しのためのコマンド 

条件分岐のためのコマンド

* If Command::                  条件によって異なるトークン列を選択する
* Switch Command::              多重分岐 

繰り返しのためのコマンド

* Repeat Command::              指定回数だけ繰り返す 
* While Command::               条件が満たされている間繰り返す
* For Command::                 カウンタの値を変えながら繰り返す 
* Foreach Command::             配列の各要素について繰り返す  
* Break Command::               ループからの抜け出し  

配列の操作

* Array Subscripting::          要素参照の方法。添字の書き方。
* Array Size::                  配列の大きさを得る方法 
* Array Expansion::             配列を引数リストに展開する方法
* Duplicating Arrays::          配列を複製する方法 
* Element Replication::         同じ要素を持った配列を初期化する方法 
* Resizing Arrays::             配列に要素を追加、削除する方法 

組み込み関数

* Message Output Functions::    メッセージの出力。print, printf など。 
* Math Functions::              算術関数。abs, sin など。 
* Random Number Generators::    乱数を生成する関数
* Numerical Type Conversion::   数値間での型変換を行う関数
* String Functions::            文字列処理を行う関数 
* Get Identifier Information::  識別子の種類や定義状態を調べる関数 
* Expression Type::             式の型を調べる type 関数
* Token Extraction::            n番目のトークンを得る nth_token 関数 
* Error Handling::              エラー処理のための関数
* Debugging::                   デバッグのためのサポート関数 

エフェクタ 

* Overview of Effectors::       エフェクタの概要。用語の解説。 
* Event Types::                 イベント種別の記述方法とイベントコード
* Defining Effectors::          エフェクタの定義方法 
* Event Actions::               イベントに対するアクションの記述方法 
* Attaching Effectors::         エフェクタをスレッドにアタッチする方法
* Changing Valid Flags::        エフェクタ有効フラグの操作
* Changing Through Bits::       スルービットの操作 
* Undefining Effectors::        エフェクタ定義の取り消し 
* Effector Examples::           いくつかのエフェクタの例 
* Predefined Effectors::        既定義エフェクタ（エフェクタライブラリ）
* Virtual Controllers and Effectors::  仮想コントローラの意味を定義する方法 

エフェクタの概要

* Effector Class::              エフェクタ定義とエフェクタクラス 
* Effector Instance::           エフェクタのアタッチとエフェクタインスタンス 
* Effector Chain::              複数のエフェクタのアタッチ 
* Inheritance of Attachment::   アタッチされたエフェクタリストの引き継ぎ 
* Through Bits::                スルービットとは？ 
* Effector Valid Flags::        エフェクタ有効フラグとは？ 

スレッド間通信

* Overview of ITC::             スレッド間通信の概要。
                                メッセージ、通信チャネル、シグナルとは？
* Sending Messages::            メッセージを送る signal コマンド  
* Receiving Messages::          メッセージを受け取る wait コマンド 
* Alternation::                 複数の通信チャネルの監視。メッセージ待ちの
                                間に別の処理をする方法。  
* Destroying Channels::         通信チャネルの破壊方法

標準MIDIファイルの読み込み

* Load Command::                MIDIファイル全体の読み込み 
* Loadtrk Command::             1つのトラックだけの読み込み 
* Closing MIDI Files::          MIDIファイルのクローズ 
* Get MIDI File Info::          MIDIファイルのトラック数などを得る方法 
@end menu

@c --------------------------------------------------------------------
@node Overview, Basic Concepts, Top, Top
@chapter PMMLの概要
@cindex PMMLの概要

PMML(Practical Music Macro Language)は
コンピュータによるMIDI楽器の自動演奏を目的とした音楽記述言語です。
音高、音の長さ等を直接テキスト中に記述する直接記述方式と、
アルゴリズムに従って楽曲合成を行う間接記述方式の両方をサポートしています。
更に、このいずれかの方法で記述された音楽に対して、
例えばクオンタイズ処理のようなイベント単位での処理を施すことが可能です。
PMMLではそのようなイベント処理手順をテキスト中に記述することができます。

PMMLのソースファイルはPMMLコンパイラによって標準MIDIファイルへ
変換できます。標準MIDIファイルは多くのシーケンサー／プレーヤーに
共通のファイル形式であり、
それらを利用することによって記述した音楽を実際に演奏することができます。
PMMLコンパイラは、format 0, 1, 2 のどの標準MIDIファイルでも生成
することができます。PMMLコンパイラは何度も修正しながら
コンパイル及び演奏を繰り返すことを想定して、
十分高速にコンパイルが行えるように設計されています。

PMMLの主な特徴は以下の通りです。

@enumerate
@item
MML(Music Macro Language)に似た直接記述機能を持っています。
MMLと比較すると、ベロシティーやタイミングの細かい調整がしやすい、
和音の記述が簡単である、複数の音符のグルーピングが可能である
といった利点があります。
なお、MMLとの直接的な互換性はありません。

@item
エクスクルーシブを含む標準MIDIファイルにおけるすべての種類のイベント
を記述することができます。

@item
連続的に変化するコントロールチェンジを生成することがきます。
変化の形状としては、直線の他に自由曲線を利用したものがあります。

@item
強力なマクロ機能を備えています。引数つきマクロや、
あるマクロの展開中にだけ有効なローカルマクロも用意されています。
マクロは共通するフレーズや伴奏パターンを記述するために便利です。

@item
C言語に似た制御構文(@code{if}, @code{while}, @code{for} など)を持っています。

@item
C言語に似た演算子があり、これによって整数演算、有理数演算、
浮動小数点演算、文字列演算が可能です。
また、可変長の配列もサポートされています。

@item 
エフェクタと呼ばれるイベント処理を施すためのモジュールが用意
されています。エフェクタを利用することによって、
例えば曲のある一部分に含まれる全ての音符についてその１オクターブ上の音を
自動的に追加するといったことが容易に実現できます。

@item 
@code{load} というコマンドにより標準MIDIファイルを読み込むことができます。
また、読み込んだ曲に対してエフェクタを適用することもできます。
この機能を使えば、PMMLコンパイラを標準MIDIファイル間の変換ツール
(例えば、format 1 から 0 への変換、分解能の変更、チャネルの再割り当て等)
として利用することができます。
@end enumerate

@c --------------------------------------------------------------------
@node Basic Concepts, Simple Examples, Overview, Top
@chapter 基本概念

@menu
* MIDI Channels::               MIDIチャネルとは？ 
* Events::                      イベントとは？ 
* Tracks::                      トラックとは？ 
* Commands::                    コマンド、マクロ指令、組み込み関数とは？
* Glyphs::                      マニュアルで使用する記号の説明 
@end menu

@ifset html
<A NAME="MIDICH"></A>
@end ifset
@node MIDI Channels, Events, Basic Concepts, Basic Concepts
@section MIDIチャネル
@cindex MIDIチャネルの概念
@cindex チャネルの概念

MIDIチャネルとは、１本のMIDIケーブルによって複数の楽器をコントロール
するために考え出された概念です（ここで楽器と呼んでいるのは、
単一の音色を持ったシンセサイザのことであって、
多くのMIDI音源は１台で複数の楽器の役割を果たしています）。
同じケーブルを通るメッセージがそれぞれどの楽器へ向けられたものかを
区別できるようにするため、各楽器に対して 1 から 16 までの
MIDIチャネル番号を割り振り、伝送されるメッセージの各々に対して
そのチャネル番号を付加しています。

単一のチャネルを使って高さの違う複数の音を同時に鳴らすことはできますが、
この場合はすべてが同じ音色になります。
音色の異なる音を同時に鳴らしたいときには、チャネル番号を別にしなければ
なりません。また更に、ボリューム、ピッチベンド、パンポットなどの制御値も
チャネルごとの指定になりますので、同時に鳴る音のそれぞれについて
これらを別の値に設定したい場合には、例え音色が同じであってもチャネルを
別にする必要があります。

PMMLでは特に指定のない限りすべてチャネル１を使用する設定になって
いますので、上で述べたようにチャネル番号を１以外に設定する必要が
あるときは、チャネル番号を明示的に指定する必要が
あります(@pxref{Registers})。

なお、PMMLにはMIDIチャネルとは全く別の概念に通信チャネルというものが
あります(@pxref{Communication})。にもかかわらず、
混乱する恐れのないときは`MIDI'や`通信'を省略して単に`チャネル'と
だけ書くことがありますので注意して下さい。

@node Events, Tracks, MIDI Channels, Basic Concepts
@section イベント
@cindex イベントの概念
@cindex メタイベント

自動演奏を行うためのシナリオはイベントの列として表現されます。
各イベントは、その発生時刻と、その時刻に何を行うか（例えばMIDI
メッセージを送るなど）を情報として持っています。

PMMLが内部で使用するイベントの種類は、
標準MIDIファイルの仕様で定義されているすべての種類のイベントに、
若干のPMML独自のイベントを追加したものです。標準MIDIファイルで
定義されているイベントには以下の種類があります。

@itemize @bullet
@item
MIDIイベント
@itemize @minus
@item
ノートオン 
@item
ノートオフ
@item
キープレッシャー（キーアフタータッチ）
@item
コントロールチェンジ
@item
プログラムチェンジ
@item
チャネルプレッシャー（チャネルアフタータッチ）
@item
ピッチベンド
@end itemize

@item 
システムエクスクルーシブイベント
@itemize @minus
@item
エクスクルーシブ
@item
任意メッセージ
@end itemize

@item 
メタイベント
@itemize @minus
@item
シーケンス番号
@item 
テキストイベント
@item
トラックの終り
@item
テンポ指定
@item
SMPTEオフセット
@item
拍子イベント
@item
調号イベント
@item
その他のメタイベント
@end itemize
@end itemize

PMML独自のイベントは次の通りです。

@itemize @bullet
@item
仮想コントロールチェンジ (@pxref{Virtual Control Change}) @*
このイベントはエフェクタへデータを受け渡すために利用されます。

@item
連続コントロールチェンジ (@pxref{Continuous Control Change}) @*
このイベントは折れ線や曲線に沿ったコントロールチェンジのコマンドを
実行したときに、折れ線や曲線の各節点に対して生成されます。
@end itemize

@node Tracks, Commands, Events, Basic Concepts
@section トラック
@cindex トラックの概念

トラックはイベントを入れるための格納庫です。
PMMLでは複数のトラックを使用することができます。
出力ファイルとして format 2 と呼ばれる特殊な形式を指定しない限り、
すべてのトラックは並行に演奏されます。つまり、同じ時刻を持ったイベントは
それがどのトラックに置かれていようと、同じ時刻に発効されます。

通常、イベントをいくつかのトラックに分けて格納しますが、
これには２つの利点があります。
１つはトラックごとに演奏をするかしないか（つまりミュートするか）を
後になって決定できる点です。
PMMLコンパイラによって標準MIDIファイルを作成するときに
演奏するトラックを限定することもできますし、
多くの標準MIDIファイルのプレーヤは、演奏中に演奏かミュートかの
切替えを行うことができます。
もう一つの利点は、コンピュータが複数のMIDIインターフェースを備えている
場合に、トラックごとに使用するインターフェース変えることが
できる点です（ただし、プレーヤがそのような機能を持っている場合に
限ります）。１つのインターフェースだけでは 16 までのMIDIチャネルしか扱えず、
従って同時に使用できる音色数は高々 16 までですが、
複数のインターフェースを使用すればこのような問題は解決できます。

出力の標準MIDIファイルとして format 1（PMMLコンパイラのデフォルト設定）を
選択した場合、ファイル中でもイベントはトラックごとに区分けされており、
したがって、どのイベントをどのトラックへ格納したかという情報は
そのままファイルにも残ります。
しかし format 0 を選択した場合は、ファイルに出力する際にすべての
トラックが１つに併合されます。このため、上で述べたような演奏中の
ミュート切り替えやインターフェースの振り分けはできません。
しかし、PMMLコンパイラによって標準MIDIファイルを作成するときに
演奏するトラックを限定することは、format 0 の場合でもできますので、
トラックを分けておくメリットは十分にあります。

トラックは１から始まる番号で番号付けされています。
トラック１（最初のトラック）はコンダクタトラックと呼ばれ、
テンポ設定、拍子設定、SMPTEオフセット、及びシーケンス番号のイベントは
このトラックに格納しなければなりません。トラック１には
この他に曲のタイトルを示したテキストイベントなどが置かれますが、
ノートオン、ノートオフなどのMIDIイベントは置かない習慣です。

どのトラックにどのMIDIチャネルのイベントを格納するかは
全くユーザの自由です。１つのトラックに複数のMIDIチャネルのイベントを
混在させても構いませんし、同じチャネルのイベントを２つ以上の
トラックに分けて格納しても構いません。最も一般的なのは、
各インターフェース、各チャネルごとに１つのトラックを割り当てる方式です。
しかし、ピアノの右手と左手のような場合は同じチャネルであっても
２つのトラックに分けた方が便利かもしれません。

@node Commands, Glyphs, Tracks, Basic Concepts
@section コマンド
@cindex コマンド
@cindex 通常コマンド(normal command)
@cindex マクロ指令(macro directive)
@cindex 組み込み関数(built-in function)
@cindex 標準マクロ(standard macro)

PMMLのソーステキストはコマンドの列から成り立っています。
コマンドには例えば音符を生成するコマンド、マクロを定義するコマンドなど
様々なものがあります。

コマンドは、@dfn{通常コマンド}、@dfn{マクロ指令}、@dfn{組み込み関数} の
３つに分類されます。
通常コマンドには、音符コマンドなどイベントを生成するコマンドや、音の長さを
指定するコマンドなどが含まれています。通常コマンドは本マニュアルに
おいて @samp{C:} という記号で示されています。
マクロ指令はマクロ処理に関係したコマンドであり、
式の途中でも使用できるという点が
通常コマンドと異なります(@pxref{Macro Directive})。
マクロ指令は、本文中において @samp{MD:} という記号で示されています。
組み込み関数は、算術関数やメッセージ出力などのコマンドを含み、
マクロ指令と同様に式の途中でも使用できます。マクロ指令との違いは、
ユーザが意味を再定義できる点です(@pxref{Built-in Functions})。
組み込み関数は、本文中において @samp{BI:} という
記号で示されています。

コマンドに良く似たものに @dfn{標準マクロ} というものがあります。
これはコンパイラ起動時に読み込まれる
スタートアップファイル(@pxref{Start-up})の中で定義されているマクロを
意味します。標準マクロは、本文中において @samp{SM:} という記号で示され
ています。

@node Glyphs,  , Commands, Basic Concepts
@section マニュアル中の記号
@cindex @expansion{}
@cindex @print{}
@cindex C: 
@cindex MD: 
@cindex BI: 
@cindex SM: 
@cindex BE: 
@cindex SE: 

@table @asis
@item @code{t}, @code{tb}, @code{dt}, @code{n}, etc.
レジスタの値を表します。例えば次のような使い方をします。
@quotation
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch} になります。
@end quotation

@item @expansion{}
マクロの展開結果を表します。

@item @print{}
@code{print} や @code{printf} によって出力されるメッセージを表します。

@item C: 
一般コマンドを表します(@pxref{Commands})。

@item MD: 
マクロ指令を表します(@pxref{Commands})。

@item BI: 
組み込み関数を表します(@pxref{Commands})。

@item SM: 
標準マクロを表します(@pxref{Commands})。

@item BE: 
組み込みエフェクタを表します(@pxref{Predefined Effectors})。

@item SE: 
標準エフェクタを表します(@pxref{Predefined Effectors})。
@end table

@c --------------------------------------------------------------------
@node Simple Examples, Compiler, Basic Concepts, Top
@chapter 簡単なソースコードの例

@menu
* Single Part Example::         単一パートの例
* Multi Part Example::          複数パートの例 
@end menu

@node Single Part Example, Multi Part Example, Simple Examples, Simple Examples
@section 単一パートの例

次の示したものは、バッハのメヌエットの冒頭部分を
右手パートだけについて記述した１つの完全なPMMLソースコードです。

@ifclear html
@example
q ^D i G A B ^C     // q, i などは音の長さの指定、^D, G などが音符。 
q ^D G G      
^ q E i C D E F#    // ^ _ はオクターブの up と down。音符に
q G _ G G           // くっつけて書くとその音符だけ、離して
^C i ^D ^C B A      // 書くと以後の音符のオクターブが上下する。
q B i ^C B A G 
q F# i G A B G  
h. A                // h. は付点２分音符
@end example
@end ifclear
@iftex
@ifset html
@ifhtml
<PRE>
<A HREF="pmml_5.html#NOTELEN">q</A> <A HREF="pmml_5.html#PITCH">^D</A> i G A B ^C  q ^D G G      <A HREF="pmml_5.html#COMM">//</A> q,iなどは音の長さの指定、D,Gなどが音符。 
<A HREF="pmml_7.html#OCTAVEUP">^</A> q E i C D E F<A HREF="pmml_5.html#ACCIDENTAL">#</A>  q G <A HREF="pmml_7.html#OCTAVEDOWN">_</A> G G    // ^ _ はオクターブの up と down。音符に
                               // くっつけて書くとその音符だけ、離して
                               // 書くと以後の音符のオクターブが上下する。
^C i ^D ^C B A  q B i ^C B A G 
q F# i G A B G  <A HREF="pmml_5.html#DOTNOTE">h.</A> A           // h. は付点２分音符
</PRE>
@end ifhtml
@end ifset
@end iftex

上のソーステキストをPMMLコンパイラに与えると、
MIDIチャネル１だけを使ってメヌエットを演奏する標準MIDIファイルが
生成されます。

@ifinfo
@subsubheading 上のソーステキストに関連する項目

@menu
* Rational Constants::          q, i など有理数定数の説明
* Pitch Constants::             ^D, G など音高定数の説明
* Note Command::                音符コマンドの説明
* Comments::                    // などコメントの記述法
* Changing Registers::          ^ _ などオクターブコマンドの説明
@end menu
@end ifinfo

@iftex
@page
@end iftex
@node Multi Part Example,  , Single Part Example, Simple Examples
@section 複数パートの例

次のPMMLソースコードは、前節のソースコードに左手パートを追加し、
さらに少し表情づけを行った例です。

@ifclear html
@example
tempo(160)                        // テンポ設定
timesig(3,4)                      // 拍子設定

newtrack(righthand) @{             // 右手パート用のスレッド生成
  ch=1 o=4 v=90 prog(69) vol(80)  // 右手パートの初期化
  /* 上の初期化部は、MIDIチャネルを1、オクターブを4、ベロシティを80、*/
  /* プログラム番号を69(オーボエ)、ボリュームを80に設定している。    */
@}
newtrack(lefthand) @{              // 左手パート用のスレッド生成
  ch=2 o=3 v=80 prog(1) vol(80)   // 左手パートの初期化
@}

righthand @{                       // 右手パートの記述
  for($i,1,2) @{                   // 2回繰り返し
    q ^D i G A B ^C  q ^D @{dr=30 G G@}
    ^ q E i C D E F#  q G++ _ @{dr=30 G G@}
    ^C i ^D ^C B A  q B i ^C B A G
    if( $i == 1 ) @{               // 繰り返しの1回目
      q F# i G A B G  h. A
    @} else @{                      // 繰り返しの2回目
      vol(80)
      q A i B A G F#  h. G
      vol_to(30)                  // デクレッシェンド
    @}   
  @}
@}

lefthand @{                        // 左手パートの記述
  h. [@{h G q A@} B ^D] B           // 和音の表現 
  ^C B 
  A G 
  q ^D B G  ^D i D ^C B A
  h B q A  q G B G 
  h. ^C  q B i ^C B A G
  h A q F#  h G q B
  q ^C ^D D  h G q _G
@}
@end example
@end ifclear
@iftex
@ifset html
@ifhtml
<PRE>
<A HREF="pmml_8.html#TEMPO">tempo(160)</A>                        // テンポ設定
<A HREF="pmml_8.html#TIMESIG">timesig(3,4)</A>                      // 拍子設定

<A HREF="pmml_7.html#NEWTRACK">newtrack</A>(righthand) {             // 右手パート用の<A HREF="pmml_7.html#THREAD">スレッド</A>生成
  <A HREF="pmml_7.html#CHREG">ch</A> <A HREF="pmml_7.html#REGASSIGN">=</A>1 <A HREF="pmml_7.html#OREG">o</A>=4 <A HREF="pmml_7.html#VREG">v</A>=90 <A HREF="pmml_8.html#PROG">prog</A>(69) <A HREF="pmml_8.html#VOL">vol</A>(80)  // 右手パートの初期化
  /* 上の初期化部は、<A HREF="pmml_2.html#MIDICH">MIDIチャネル</A>を1、オクターブを4、ベロシティを80、*/
  /* プログラム番号を69(オーボエ)、ボリュームを80に設定している。    */
}
newtrack(lefthand) {              // 左手パート用のスレッド生成
  ch=2 o=3 v=80 prog(1) vol(80)   // 左手パートの初期化
}

<A HREF="pmml_7.html#TSWITCH">righthand</A> {                       // 右手パートの記述
  <A HREF="pmml_10.html#FOR">for</A>($i,1,2) {                   // 2回<A HREF="pmml_10.html#REPEAT">繰り返し</A>
    q ^D i G A B ^C  q ^D <A HREF="pmml_7.html#GROUPING">{</A> <A HREF="pmml_7.html#DURATION">dr=30</A> G G}
    ^ q E i C D E F#  q G<A HREF="pmml_5.html#ACCENT">++</A> _ {dr=30 G G}
    ^C i ^D ^C B A  q B i ^C B A G
    <A HREF="pmml_10.html#IF">if</A>( $i <A HREF="pmml_6.html#OPR">==</A> 1 ) {               // 繰り返しの1回目
      q F# i G A B G  h. A
    } else {                      // 繰り返しの2回目
      vol(80)
      q A i B A G F#  h. G
      <A HREF="pmml_8.html#CCONT">vol_to</A>(30)                  // デクレッシェンド
    }   
  }
}

lefthand {                        // 左手パートの記述
  h. <A HREF="pmml_7.html#CHORD">[</A> <A HREF="pmml_7.html#CHORDSEQ">{</A>h G q A} B ^D] B           // 和音の表現 
  ^C B 
  A G 
  q ^D B G  ^D i D ^C B A
  h B q A  q G B G 
  h. ^C  q B i ^C B A G
  h A q F#  h G q B
  q ^C ^D D  h G q _G
}
</PRE>
@end ifhtml
@end ifset
@end iftex

@ifinfo
@subsubheading 上のソーステキストに関連する項目

@menu
* Meta Events::                 tempo, timesig の説明
* Threads::                     スレッドの概念説明
* Creating Named Threads::      newtrack などスレッド生成の説明
* Register Sets::               ch, o, v などレジスタの説明
* Changing Registers::          ch=1 などレジスタの変更法
* Control-Change Events::       prog, vol などコントロール系コマンドの説明
* Switching Threads::           スレッド切り替えの方法
* Loops::                       繰り返しのコマンドの説明
* For Command::                 for コマンドについて
* Grouping::                    @{ ... @} の説明
* Note Duration::               dr=30 の説明
* If Command::                  if コマンドについて
* Operators::                   == など演算子の説明
* Continuous Control Change::   vol_to など連続コントロールチェンジの説明
* Chords::                      [ ... ] という和音コマンドの説明
@end menu
@end ifinfo

@c --------------------------------------------------------------------
@node Compiler, Lexical Rules, Simple Examples, Top
@chapter コンパイラの起動

PMMLのソースファイルはPMMLコンパイラによって標準MIDIファイルへ
変換されます。標準MIDIファイルは多くのシーケンサー／プレーヤーに
共通のファイル形式であり、
それらを利用することによって記述した音楽を実際に演奏することができます。
PMMLコンパイラは、format 0, 1, 2 のどの標準MIDIファイルでも生成
することができます。

@menu
* Synopsis::                    PMMLコンパイラの起動方法
* Options::                     コマンド行オプションの説明        
* Start-up::                    コンパイラ起動時の処理について
* Output Process::              コンパイラ終了時の処理について 
* Output File::                 出力ファイルについて        
* Environment::                 環境変数        
* One Liner::                   ワンライナー（１行コマンド）の例        
* Limitations::                 コンパイラの制限事項        
@end menu

@node Synopsis, Options, Compiler, Compiler
@section コマンド形式
@cindex PMMLコンパイラの起動
@cindex コンパイラの起動
@cindex 標準入力
@cindex 終了ステータス

PMMLコンパイラを起動するには、コマンド行から
次のように入力します。

@example
pmml @r{[}@var{options}@r{]} @r{[}@var{srcfile}@r{]}
@end example

@var{srcfile} はPMMLソースファイルの名前です。
ファイル名の拡張子が @samp{.pml} である場合には、
それを省略できます。@var{srcfile} が @samp{-} の場合は、
標準入力からソーステキストを読み込みます。

生成される出力MIDIファイルのファイル名は、特に指定のない限り、
ソースファイル名の拡張子を @samp{.mid} に変更したものに
なります(@pxref{Output File Name})。
なお、ソーステキストの終わりまでに1つもイベントが生成されなかった場合には、
出力MIDIファイルは生成されません。このときには警告メッセージが出力されます。

PMMLコンパイラが終了したときいＯＳに返される終了ステータスは、
正常に終了したとき 0、エラーによる異常終了したとき 1、
ヘルプメッセージのみを出力したとき 2、そして
イベントが無いため出力ファイルが生成されなかったとき 3 になります。

@node Options, Start-up, Synopsis, Compiler
@section コマンド行オプション
@cindex オプション
@cindex コマンド行オプション

コンパイラ起動時に指定可能なオプションは以下の通りです。
オプションとその引数の間にはスペースがあってもなくても構いません。
引数をとらないオプションについては、
@samp{-np} のように2つ以上のオプションをまとめて指定することができます。

@table @code
@item -0
@itemx -1
@itemx -2
出力MIDIファイルのフォーマットを指定します。
@samp{-0} はformat 0（単一シーケンス単一トラック）、
@samp{-1} はformat 1（単一シーケンス複数トラック）、
そして @samp{-2} はformat 2（複数シーケンス単一トラック）を意味します。
@samp{-0} が指定された時はすべてのトラックが1つにマージされて出力されます。
これらのオプション指定が無い場合は、
format 0または1になります(@pxref{Output Format})。

@item -c @var{channel}@r{[}-@var{channel}@r{]},@dots{}
指定されたMIDIチャネルだけについてイベントを出力します。
例えば @samp{-c 1-3,6} のように指定すると、
チャネル 1,2,3,6 だけが出力されます。
@var{channel} に負の数を指定すると、その絶対値のチャネル番号を除いた
他のチャネルが出力されます。正の数と負の数の両方を指定したときには、
正の数で指定されたチャネルの集合から、負の数で指定されたチャネルを集合を
差し引いた分に対してイベント出力が行われます。
エクスクルーシブとメタイベントは、
このオプションとは無関係に常に出力されます。

@item -d
イベントの無い空のトラックを削除して、
それ以降のトラックを順に前に詰めます。
ソーステキスト中にイベント出力の記述がないトラックだけでなく、
演奏範囲やチャネル番号の限定の結果空になったトラックや、
@samp{-T} オプションで範囲外に指定されたトラックも削除されます。

@item -e @var{PMML-srctext}
@var{PMML-srctext} をソースファイルの内容だと見なして、
その中にあるコマンドを実行をします。
このオプションが指定されているとき、
@var{srcfile} は無くても構いません。

@item -f @var{songpos}
@var{sonpos} の位置から演奏を開始します。
曲の途中からの演奏でも先頭から演奏したのと同じ条件になるように、
開始位置以前にあるイベントのうち開始位置以降の演奏に影響を与える可能性のある
ものは、生成されるファイルの先頭においてまとめて出力されます。

@var{songpos} の指定には次の4通りがあります。

@table @asis
@item (1) @code{@var{measure}@r{[}:@var{ticks}@r{]}}
小節番号が @var{measure} である小節の先頭（@samp{-t} オプションの
場合は小節の終り）を意味します。
小節番号は１から始まり、小節の途中に拍子設定イベントがある場合には
そこから新しい小節が始まっていると見なして数えます。
@var{ticks} の指定がある場合には、小節の先頭（終り）からさらに
(@var{ticks} / 480 * ４分音符の長さ)だけずれた位置を意味します。
@var{ticks} は負でも構いません。

@item (2) @code{/@var{marker}@r{[}/@r{]}}
@var{marker} と一致するマーカーイベント（種別番号が６のメタイベント）の
位置を意味します。マーカーイベントはトラック１に含まれている
必要があります。@var{marker} を囲む区切り文字 @samp{/} は @samp{:} でもよく、
また、末尾の区切り文字は省略できます。

@item (3) @code{/@var{marker}/+@var{measure}@r{[}:@var{ticks}@r{]}}
@var{marker} と一致するマーカーイベントの位置よりも未来にある、
@var{measure} 番目の小節区切りの位置を意味します。
@var{ticks} の指定がある場合には、そこからさらに
(@var{ticks} / 480 * ４分音符の長さ)だけずれた位置を意味します。
@var{marker} を囲む @samp{/} は @samp{:} でも構いません。

@item (4) @code{/@var{marker}/-@var{measure}@r{[}:@var{ticks}@r{]}}
@var{marker} と一致するマーカーイベントの位置よりも過去にある、
@var{measure} 番目の小節区切りの位置を意味します。
その他については(3)と同じです。
@end table

小節番号 @var{measure} は０または負でも構いません。
この場合は、ブランクの小節が曲の先頭に追加されます。

出力ファイルが format 2 の場合、このオプションは正しく働きません。

@item -h
ヘルプメッセージを出力して、即座に終了します。

@item -i @var{startup-file}
コンパイラ起動時に読み込まれるスタートアップファイルを
@var{startup-file} で示されるファイルに変更します(@pxref{Start-up})。
@var{startup-file} の拡張子が @samp{.pml} である場合には、それを省略できます。
ファイルを見つけるときには検索パス(@pxref{Environment})が参照されます。

@item -l @var{SMF}
@code{load} コマンドを実行するのと同じようにして、
@var{SMF} で示される標準MIDIファイルをイベントバッファに読み込みます。
このオプションは @samp{-e load("@var{SMF}")} と等価です。
@var{SMF} の拡張子が @samp{.mid} である場合には、それを省略できます。
このオプションが指定されているとき、@var{srcfile} は無くても構いません。

@item -n
ノート衝突におけるノートイベントの修正を行いません(@pxref{Note Collision})。

@item -o @var{SMF}
出力される標準MIDIファイルのファイル名を指定します。
拡張子を省略すると @samp{.mid} が補われます。
@var{SMF} に @samp{-} を指定したときは、標準出力に出力されます。

@item -p
優先度によるイベントのソートを行いません(@pxref{Priority})。

@item -q
このオプションが指定されていると、
スタートアップファイルを読み込みません。

@item -r @var{resolution}
出力MIDIファイルの分解能を、４分音符当たり @var{resolution} ティックに
設定します(@pxref{Output Resolution})。

@item -t @var{songpos}
@var{songpos} で演奏を中断します。
@var{songpos} において発音中のノートがあれば、
それを止めるようにノートオフイベントが補われます。

@var{songpos} の書式については @samp{-f} オプションの項を御覧下さい。

出力ファイルが format 2 の場合、このオプションは正しく働きません。

@item -w
すべての警告出力を抑制します。

@item -F @var{header-file}
@var{header-file} で示されるPMMLソースファイルを
@var{srcfile}（主ソースファイル）より先に読み込み、その中のコマンドを
実行します。
このオプションは @samp{-e include("@var{header-file}")} と等価であり、
@var{srcfile} と併せて２つ以上のソースファイルを読み込みたい時や、
@samp{-e} または @samp{-l} オプションで指定されるコマンドより先に
@var{header-file} 中のコマンドを実行したい時に使用します。
@var{PMML-file} の拡張子が @samp{.pml} である場合には、それを省略できます。
ファイルを見つけるときには検索パス(@pxref{Environment})が参照されます。
このオプションが指定されているとき、@var{srcfile} は無くても構いません。

@item -I @var{directory}
ディレクトリ @var{directory} をファイル検索パス(@pxref{Environment})
の先頭に追加します。ファイルの検索順序は、まず @samp{-I} オプションで
指定されたディレクトリ、その後で環境変数 @code{PMMLPATH} あるいは
インストール時に設定された検索パス中のディレクトリの順になります。

@item -R
MIDIファイルを出力するときに
ランニングステータスルールを適用しないようにします。
ランニングステータスルールをサポートしていないシーケンサ／プレーヤ用に
MIDIファイルを生成する場合に使用します。
このオプションを指定すると、若干MIDIファイルが長くなりますが、
演奏自体に影響はありません。

@item -T @var{track}@r{[}-@var{track}@r{]},@dots{}
指定されたトラックだけを出力します。
例えば @samp{-T 1-3,6} のように指定すると、
トラック 1,2,3,6 だけが出力されます。
@var{track} に負の数を指定すると、その絶対値のトラック番号を除いた
他のトラックが出力されます。正の数と負の数の両方を指定したときには、
正の数で指定されたトラックの集合から、負の数で指定されたトラックを集合を
差し引いた分に対して出力が行われます。

トラックを番号ではなくトラック名で指定することもできます。
@var{track} に @samp{/} または @samp{:} で囲まれた文字列を指定すると、
その文字列と一致するトラック名イベント（種別番号が３のメタイベント）を
含んだトラックを表すことができます。
番号の場合と同様に、@samp{/} または @samp{:} の前に @samp{-} を置くと
そのトラックを除く意味になります。
@samp{-T} オプション全体が @samp{/} または @samp{:} で終る場合、
その最後の文字は省略できます。

出力MIDIファイルがformat 0の場合でも、
内部ではイベントが生成された時の @code{tk} レジスタの値ごとに
トラックは別になっていますので、
@samp{-T} オプションによるトラックの選択が可能です。

出力MIDIファイルのフォーマットが０または１である場合には、
トラック１（コンダクタトラック）は、@var{track} の指定がなくても
出力されます。従って、@samp{-T 3} と指定するとトラック１とトラック３が
出力されます。トラック１を出力したくない場合には、
トラック番号に @samp{-1} を含めます。
例えば @samp{-T -1,3} と指定すればトラック３だけが出力されます。

指定外のトラックは、@samp{-d} オプションが指定されない限り、
空トラックとして残ります。
@end table

@node Start-up, Output Process, Options, Compiler
@section スタートアップについて
@cindex スタートアップ
@cindex スタートアップファイル
@cindex pmml.pml
@cindex %@{

コンパイラが起動されると、まず次の順番で
ソーステキストが読み込まれます。

@enumerate
@item 
ソースファイルのコメントを除いた一番先頭に @samp{%@{} という
記号列があれば、そこから対応する @samp{@}} までの間にある
コマンドが実行されます。これはソースファイルの中から
出力ファイルのフォーマット(@pxref{Output Format})や
分解能(@pxref{Output Resolution})を指定するために利用されます。

@item 
スタートアップファイルが読み込まれます。
スタートアップファイルの名前は、@samp{-i} オプションが
指定されていればその引数、そうでなけばPMMLコンパイラの実行ファイル名
の拡張子を @samp{.pml} に変更したもの（通常は @file{pmml.pml}）に
なります。@samp{-q} オプションが指定されている時は読み込まれません。

@item
コマンド行に @samp{-e}、@samp{-l}、または @samp{-F} オプションが
指定されていれば、それが実行されます。
これらのオプションは複数指定してもよく、実行の順番は指定された順番になります。
@end enumerate

これらに次いで、ソースファイルの残りの部分の実行が開始されます。

@node Output Process, Output File, Start-up, Compiler
@section 出力処理

すべてのコマンド実行を終えた時点において、生成されたすべてのイベントは
メモリ上のイベントバッファにトラックごとに分けて格納されています。
PMMLコンパイラは、その後に出力処理と呼ばれる一連の処理を
バッファ内のイベントに対して実行します。
そして最後に処理後のイベントを出力ファイルへ書き出します。

以下が出力処理の内容です。

@enumerate
@item
@samp{-T} オプションが指定されている場合には、出力する必要のないトラックを
クリアします。

@item 
トラック毎に、イベントを時刻と以下で述べる優先度によってソートします。

@item
@samp{-f} または @samp{-t} オプションが指定されている場合は、
演奏範囲外のイベントで範囲内の演奏には影響を与えないものを削除します。
また、@code{end} コマンド(@pxref{Meta Events})によって生成された
トラックの終りを示すイベントがある場合には、それより後のイベントも
削除します。

@item
連続コントロールチェンジイベントを、通常のコントロールチェンジイベントの列に
展開します。

@item
下で述べるようにノート衝突時の処理を行います。

@item
出力ファイルが format 0 の場合は、すべてのトラックを１つに併合します。

@item
時刻０にテンポ設定や拍子設定のイベントを欠いている場合には、
それらを補います。テンポは120拍/分、拍子は4/4に設定されます。

@item
ベロシティー拡大率(@pxref{Velocity Magnifier})の処理を行います。

@item
イベントの時刻を有理数からティック数へ変換します。
このときティックの端数は切捨てられます。
また更に、コントロールチェンジのコントロール値をすべて整数へ変換します。
これは丸めによって最も近い整数に変換されます。
@end enumerate

上の処理のうち 3, 4, 5 は同時に並行して行われますが、
それ以外の処理は上に示した順序で逐次的に行われます。

@menu
* Priority::                    イベント優先度                  
* Note Collision::              ノート衝突時の処理 
@end menu

@node Priority, Note Collision, Output Process, Output Process
@subsection イベント優先度
@cindex イベント優先度
@cindex イベントソート
@cindex -p オプション

イベントはその種類ごとに優先度が割り当てられており、
イベントがソートされるとき、
同一時刻のイベントは、優先度の高いものから先に出力されるように
並べ変えられます。時刻も優先度も同じイベントどうしについては、
生成された順番が保たれます。

イベントの優先度は以下のように定められています。

@display
1 (最低) キープレッシャー、チャネルプレッシャー
2        ノートオン、持続時間が０である音符のノートオフ
3        コントロールチェンジ、テンポ設定、エクスクルーシブ
4        テンポ設定以外のメタイベント
5 (最高) 持続時間が０でない音符のノートオフ 
@end display

コマンド行において @samp{-p} オプションが指定されている場合には、
どの種類のイベントも同じ優先度を持っていると見なしてソートが行われます。

@node Note Collision,  , Priority, Output Process
@subsection ノート衝突時の処理
@cindex ノート衝突
@cindex -n オプション
@cindex リトリガ

同一トラックの同一チャネルにおいて、
同じノート番号を持つ２つ以上のノートが重なって演奏された場合、
音の持続期間が本来の長さより短くなってしまうという不都合を生じます。
例えば２つのノートが重なり、
ノートオン、ノートオン、ノートオフ、ノートオフという
という順番でMIDI楽器にメッセージが送られた場合、
本来は後のノートオフまで音が持続するべきですが、
実際は前のノートオフによって音が消されてしまいます。
PMMLコンパイラではこのような問題を回避するため、
ファイル出力部において、次のような処理を行っています。

@enumerate
@item
既に発音中のキーに対してノートオンイベントが到着した場合には、
リトリガ（一旦ノートオフしてからすぐにノートオンすること）を行うように
直前にノートオフイベントを追加します。

@item
２重以上に発音されているキー、或は発音されていないキーに対して
ノートオフイベントが到着した場合にはそれを削除します。

@item
オールノートオフのイベントは、キーごとのノートオフイベントに
置き換えられ、更に上の削除の条件がキーごとに適用されます。

@item
曲の最後においてノートオンのままになっているキーがあれば、
それに対してノートオフイベントを補います（この処理は
ノート衝突の回避を目的としたものではありません）。
@end enumerate

コマンド行において @samp{-n} オプションが指定されている場合には、
上で述べた処理はすべて行われません。	

@node Output File, Environment, Output Process, Compiler
@section 出力ファイルについて
@cindex 出力ファイル

出力の標準MIDIファイルはソーステキストの終わりまでに1つ以上のイベント
が生成された場合にだけ作成されます。
出力ファイルの諸条件は次の通りです。

@menu
* Output File Name::            出力ファイルのファイル名 
* Output Format::               出力ファイルのフォーマット 
* Output Resolution::           出力ファイルの分解能
@end menu

@node Output File Name, Output Format, Output File, Output File
@subsection 出力ファイルのファイル名
@cindex 出力ファイルのファイル名
@cindex out.mid

出力ファイルのファイル名は、次のようにして決められます。

@enumerate
@item
コマンド行に @samp{-o} オプションがあれば、その引数。

@item
入力が標準入力であったり、@samp{-e}、@samp{-l}、@samp{-F} オプションが
使用されているときで入力ソースファイルがない時は、@file{out.mid}。

@item
そうでない場合、入力ソースファイル名の拡張子を @samp{.mid} に変更したもの。
@end enumerate

@node Output Format, Output Resolution, Output File Name, Output File
@subsection 出力ファイルのフォーマット
@cindex 出力ファイルのフォーマット
@findex $format

出力ファイルのフォーマットは、次のようにして決められます。

@enumerate
@item
コマンド行に @samp{-0}, @samp{-1} または @samp{-2}
オプションが指定されていれば、それが有効になる。

@item
そうでない場合、
ソースファイル先頭において @samp{%@{} から @samp{@}} の
間に @code{$format} が定義されていれば、その値。

@item
そうでない場合、最終的に第１トラックだけにしかイベントが
生成されなかったときは、format 0。

@item
そうでない場合、format 1。
@end enumerate

@node Output Resolution,  , Output Format, Output File
@subsection 出力ファイルの分解能
@cindex 出力ファイルの分解能
@findex $resolution

４分音符あたりのティック数によって定義される出力ファイルの分解能は、
次のようにして決められます。

@enumerate
@item
コマンド行に @samp{-r} オプションが指定されていれば、その引数の値。

@item
そうでない場合、
ソースファイル先頭において @samp{%@{} から @samp{@}} の
間に @code{$resolution} が定義されていれば、その値。

@item
そうでない場合、
ソーステキストの終わりまでに @code{load} または @code{loadtrk} コマンドが
実行されていれば、読んだMIDIファイルの分解能の最大値。

@item
そうでない場合、４分音符あたり480ティック。
@end enumerate

@node Environment, One Liner, Output File, Compiler
@section 環境変数
@cindex 環境変数
@cindex PMMLPATH
@cindex ファイル検索パス
@cindex 検索パス
@cindex LANG
@cindex エラーメッセージ

PMMLコンパイラは次の環境変数を参照します。 

@table @code
@item PMMLPATH
@code{include} マクロ指令によってファイルを読み込むとき、
スタートアップファイルを読み込むとき、及び @samp{-F} オプションで
ファイルを読み込むときに参照されるファイルの検索パスです。
検索するディレクトリをセミコロン @samp{;} で区切って並べます。
検索は並べた順番で行なわれます。
DOSでの使用の場合、ディレクトリにドライブ名を
含めることができます。
@code{PMMLPATH} が定義されていない場合は、
インストール時に指定されたデフォルトの検索パスが有効になります。
なお、@samp{-I} オプションによって検索パスにディレクトリを
追加することが可能です(@pxref{Options})。

@item LANG
この環境変数が定義されていて、かつその値の先頭が @samp{ja} で始まっていれば、
エラー、警告、及びヘルプのメッセージが日本語で表示されます。
@end table

@node One Liner, Limitations, Environment, Compiler
@section ワンライナー
@cindex ワンライナー
@cindex フォーマット変換
@cindex 分解能の変換
@cindex 標準MIDIファイルの連結
@cindex 標準MIDIファイルの併合

ここではソースファイルを用いずにコマンド行だけで動作を記述できる
いくつかの有用な例を紹介します。
例の中で用いられているシングルクオートはUnixシェルのメタ文字です。
DOS環境の場合にはこれらを取り除いて実行して下さい。

@table @code
@item pmml -0 -l @var{format1SMF}
すべてのトラックを併合することによって、
format 1 の標準MIDIファイル @var{format1SMF} を format 0 へ変換します。
出力ファイルは @file{out.mid} になります。

@item pmml -i f0tof1 -l @var{format0SMF} 
format 0 の標準MIDIファイル @var{format0SMF} を format 1 へ変換します。
出力ファイルでは、トラック１にテンポ情報、トラック２に
エクスクルーシブメッセージ、トラック３から18には各チャネルのメッセージが
置かれます。

@item pmml -r120 -np -l @var{SMF}
標準MIDIファイル @var{SMF} の分解能を４分音符あたり120ティックへ変換します。
@var{SMF} は format 0 と format 1 のどちらでも構いません。
@samp{-np} オプションは、イベントの修正や順序変更を避けるためのものです。

@item pmml -c2 -l @var{SMF} 
標準MIDIファイル @var{SMF} の中からMIDIチャネル２に関するイベント
だけ（正確にはそれとエクスクルーシブ及びメタイベント）を抜き出します。

@item pmml -f12 -t13 @var{SMF}
標準MIDIファイル @var{SMF} の第12小節から第13小節までを抜き出します。

@item pmml -l @var{SMF1} -l @var{SMF2}
２つの標準MIDIファイルを、まず @var{SMF1} の曲が演奏され、それから
@var{SMF2} の曲が演奏されるように連結します。

@item pmml -l @var{SMF1} -e'&' -l @var{SMF2}
２つの標準MIDIファイルを、両方の曲が並行して演奏されるように併合します。

@item pmml -e 'dump()' -l @var{SMF}
標準MIDIファイル @var{SMF} の内容をテキストにして表示します。

@item pmml -e 'quantize(s)' -l @var{SMF}
標準MIDIファイル @var{SMF} 中のノートイベントの時刻に対して、16分音符間隔で
クオンタイズをかけます(@pxref{Predefined Effectors})。
@end table 

@node Limitations,  , One Liner, Compiler
@section 制限事項
@cindex 曲の全長
@cindex エフェクタの最大数
@cindex ノート衝突における制限
@cindex ファイル数の制限

@table @asis
@item アタッチできるエフェクタの数
現在のコンパイラでは、1つのスレッドにアタッチできるエフェクタの
数は最大31個に制限されています。

@item 曲の全長　　　　
曲の全長は最大で４分音符131068個分に制限されています。
この値は1分間に120拍のテンポの場合、約18時間に相当します。

@item ノート衝突の処理
同一トラック同一チャネルの1つのキーに対して、
ノートオフすることなく256以上のノートオンが発せられた
場合には、ノートの衝突回避が正しく行われません。

@item 同時にオープンできるファイル数
@code{loadtrk} コマンド、または @code{ntrk}、@code{format}、@code{resolution}
各組み込み関数によって同時にオープンできるMIDIファイル数は最大で16です。
@end table

@c --------------------------------------------------------------------
@node Lexical Rules, Data Types and Expressions, Compiler, Top
@chapter 字句規則

@menu
* Space Characters::            空白文字の意味 
* Comments::                    コメントの書き方 
* Integers::                    整数定数 
* Floating-Point Constants::    浮動小数点定数
* Pitch Constants::             音の高さを表す定数  
* Rational Constants::          有理数定数
* Strings::                     文字列定数 
* Identifiers::                 識別子（名前）の規則 
* Accents::                     アクセント記号 
* Time Shifters::               時刻シフト記号 
* Tokens::                      トークンの全種類のリスト 
@end menu

@node Space Characters, Comments, Lexical Rules, Lexical Rules
@section 空白文字
スペース、タブ、改行の３つはどれも空白文字として同等に扱われ、
テキストの任意の位置に自由に挿入することができます。
ただし、1つのトークンの途中（すなわち、
識別子や予約語の途中、或は @samp{+=} のように2つ以上の連続した文字によって
意味をなす記号列の間）には挿入できません。

@ifset html
<A NAME="COMM"></A>
@end ifset
@node Comments, Integers, Space Characters, Lexical Rules
@section コメント
コメントの書式には次の２種類があります。
これらが混在していても構いません。

@table @code
@item /* @r{@dots{}} */
@samp{/*} から @samp{*/} までの文字列（改行を含んでいても良い）が
コメントとみなされます。空白文字を挿入できる場所ならばどこでも
コメントを挿入することができます。C言語のコメントと異なり、
下の例のようにネストが可能です。

@example
/*
 c d e /* f */
 c  この部分もまだコメントです。
 */
@end example

@item // @r{@dots{}}
@samp{//} から行の終りまでがコメントとみなされます。
上の形式と同様、空白文字を挿入できる場所ならばどこでも挿入可能です。
@end table

@node Integers, Floating-Point Constants, Comments, Lexical Rules
@section 整数定数
@cindex 整数定数
@cindex 10進定数
@cindex 16進定数

整数定数の表記法には10進と16進の2通りがあります。
10進の場合、数字の列がそのまま定数になります。
16進の場合、先頭に @samp{0x} または @samp{0X} をつけます。10から15に対応する
AからFの文字は、大文字、小文字のどちらでも構いません。

@node Floating-Point Constants, Pitch Constants, Integers, Lexical Rules
@section 浮動小数点定数
@cindex 浮動小数点定数

浮動小数点定数は、整数部を表す数字の列、小数点、
小数部を表す数字の列、@code{e} または @code{E}、指数の符号、
指数を表す数字の列が順に並んだものです。
整数部と小数部のどちらか一方は省略可です。
また、小数点か @code{e} または @code{E} 以降の
どちらか一方はなくても構いません。指数の符号は常に省略可能です。

@ifset html
<A NAME="PITCH"></A>
@end ifset
@node Pitch Constants, Rational Constants, Floating-Point Constants, Lexical Rules
@section 音高定数
@cindex 音高定数(pitch constants)
@cindex 臨時記号
@cindex 音名
@cindex オクターブの指定
@cindex 相対オクターブ指定
@cindex シャープ
@cindex フラット
@cindex ナチュラル
@findex a
@findex b
@findex c
@findex d
@findex e
@findex f
@findex g
@findex r
@findex ^
@findex _

音高定数はMIDIノート番号を音名(C,D,Eなど)で表現するための定数です。
音高定数はそれ単独で音符または休符を生成するコマンドにもなりますし、
また式の中でMIDIノート番号を与える整数定数として使用することもできます。

音高定数のフォーマットは以下の通りです。

@example
@r{[}@var{octave-adjusters}@r{]}@var{pitchname}@r{[}@var{accidentals}@r{][}@var{octave}@r{]}
@end example

@noindent
ただし、

@display
@var{octave-adjusters} := @samp{^ _} のいずれかからなる記号列
@var{pitchname} := @samp{a b c d e f g r A B C D E F G R} のいずれか
@var{accidentals} := @samp{# b %} のいずれかからなる記号列
@var{octave} := [@code{-}]@var{integer}
@end display

音名 @var{pitchname} は @code{a} から @code{g} の文字で指定します。
大文字、小文字のどちらでも良く、両者に意味の違いはありません。
アメリカ式音名を採用していますので、
@code{b} は @code{a} の一全音上になります(ドイツ式のように半音上では
ありません)。また、@code{H} は音名として使用できません。
@var{pitchname} が @code{r} または @code{R} の場合には休符を意味し、
定数値として 0x80000000 (これは休符を表す
特別なノート番号です)を与えます。

@ifset html
<A NAME="ACCIDENTAL"></A>
@end ifset
臨時記号 @var{accidentals} は
シャープが @samp{#}、フラットが @samp{b}（小文字に限る）、
ナチュラルが @samp{%} です。
シャープはMIDIノート番号を１増やし、
フラットはMIDIノート番号を１減らします。
シャープ及びフラットを複数個指定するとその個数だけMIDIノート番号が
増減されます。
@var{accidentals} が無い場合には、
@code{key} レジスタで示される調に従って暗黙のシャープやフラットが
仮定され、それによってMIDIノート番号が決定されます(@pxref{Key})。
ナチュラルは、自動的に付けられるシャープ／フラットを取り消すのに使われます。

@var{octave} はオクターブの高さを表し、@code{C4}が中央C
（MIDIノート番号 60）に対応しています。
@var{octave} は負の数でも構いません(例: @code{C-1})。
@var{octave} を省略した場合には、@code{o} レジスタの値が使われます。

相対オクターブ指定 @var{octave-adjusters} は
上の規則によって得られたオクターブをさらに増減させます。
@samp{^} によって１オクターブ上がり、@samp{_} によって
１オクターブ下がります。複数個続ければその数だけオクターブが上下します。

@code{tp} レジスタ(@pxref{Register Sets})の値は、音高定数の値に
影響を与えます。すなわち、音高定数の定数値は上の規則によって得られる
MIDIノート番号に @code{tp} レジスタの値を加えたものになります。
ただし、休符の場合は @code{tp} レジスタの値によらず常に 0x80000000
となります。

音高定数はその中に空白文字を含めることはできません。
例えば、@samp{C-1} を @samp{C - 1} と書いたり、
@samp{^C} を @samp{^ C} と書いたりすることはできません。
もし仮にこのように書いた場合には別の意味になります。

@subsubheading 音高定数の例

@example
C4 D#5 a bb Dbb ^E% __c D#-1
@end example

@ifset html
<A NAME="NOTELEN"></A>
@end ifset
@node Rational Constants, Strings, Pitch Constants, Lexical Rules
@section 有理数定数
@cindex 有理数定数(rational constant)
@cindex 長さ記号

有理数定数は有理数を表現するための定数です。
PMMLでは、どんな連符の長さも正確に表すことができるように、
時間を表すのに有理数（分数）表現を使っています。
例えば、4/4 拍子における全音符の長さは有理数の 1 で表現され、
４分音符の長さは 1/4 という分数で表されます。

有理数定数はそれ単独で音価（ステップタイム）を指定する
コマンドにもなりますし、また他の定数と同じようにして
式の中で使うことができます。

有理数定数の形式は以下の通りです。

@example
@r{[}@var{multiplier}@r{]}@var{lengthname}@r{[}@var{dots}@r{]}
@end example

@noindent
ただし、

@display
@var{lengthname} := @samp{w h q i s z u W H Q I S Z U} のいずれか
@var{dots} := @samp{.} の列
@end display
@findex w
@findex h
@findex q
@findex i
@findex s
@findex z
@findex u

@noindent
長さ記号 @var{lengthname} のそれぞれの意味は次の通りです。

@table @asis
@item @samp{w} または @samp{W}
全音符/休符 (@b{w}hole)。値は 1。
@item @samp{h} または @samp{H}
２分音符/休符 (@b{h}alf)。値は 1/2。
@item @samp{q} または @samp{Q}
４分音符/休符 (@b{q}uarter)。値は 1/4。
@item @samp{i} または @samp{I}
８分音符/休符 (e@b{i}ghth)。値は 1/8。
@item @samp{s} または @samp{S}
16分音符/休符 (@b{s}ixteenth)。値は 1/16。
@item @samp{z} または @samp{Z}
32分音符/休符 (ドイツ語で @b{z}weiunddreissigstel)。値は 1/32。
@item @samp{u} または @samp{U}
ティック。値は 1/1920 （つまり４分音符の480分の１）。
@end table

@noindent
長さ記号 @var{lengthname} は大文字でも小文字でも良く、
両者に意味の差はありません。

@var{multiplier} は、整数または浮動小数点の定数であり、
これを置くともとの値と @var{multiplier} との積が実際の値になります。

@display
@code{2w}   = 2
@code{1.5q} = 3/8
@code{.5z}  = 1/64
@end display

@ifset html
<A NAME="DOTNOTE"></A>
@end ifset
長さ記号の後にピリオドをつけると、付点音符/休符の意味になり、
その個数によってもとの値の 1.5, 1.75, 1.875, @dots{}, 
(1 + 1/2 + 1/4 + @dots{} + 1/(2 ** n)) 倍になります。

@display
@code{q.}  = 1/4 * 1.5 = 3/8
@code{h..} = 1/2 * 1.75 = 7/8
@code{2q.} = 2 * 1/4 * 1.5 = 3/4
@end display

長さ記号のうちの @samp{u} はティック数によって
時間を指定する場合に用いられます。
ここでのティックは常に４分音符の480分の１の長さを意味し、
出力される標準MIDIファイルでのティックとは必ずしも一致しません。
例えば、出力ファイルの分解能が 120 である場合には、
@samp{4u} が出力ファイル上の１ティックに相当します。

連符の表現方法については @ref{Note Length} を御覧下さい。

@node Strings, Identifiers, Rational Constants, Lexical Rules
@section 文字列定数
@cindex 文字列定数
@cindex ダブルクオート(")
@cindex バックスラッシュ・シーケンス

ダブルクオート @samp{"} で囲んだ文字列が文字列定数になります。
文字列定数の中で特殊文字を表すために次のバックスラッシュ・シーケンスを
使うことができます。

@table @asis
@item @code{\n}
改行
@item @code{\t}
水平タブ
@item @code{\v}
垂直タブ
@item @code{\b}
後退
@item @code{\r}
復帰
@item @code{\f}
改ページ
@item @code{\a}
ベル
@item @code{\\}
バックスラッシュ
@item @code{\"}
ダブルクオート
@item @code{\@var{ooo}}
任意のコードの文字 (@var{ooo} は3桁以内の8進数)
@item @code{\x@var{hh}}
任意のコードの文字 (@var{hh} は2桁以内の16進数)
@item 行末の @samp{\}
改行
@end table

@node Identifiers, Accents, Strings, Lexical Rules
@section 識別子
@cindex 識別子
@cindex 名前
@cindex 予約語
@cindex キーワード

マクロ名、スレッド名、エフェクタ名、通信チャネル名に
使用される名前を識別子と呼びます。
PMMLの識別子は次の2種類のうちのいずれかです。

@itemize @bullet
@item
英字または漢字で始まる英字、数字、下線 @samp{_}、または漢字の列
@item
1つのドル記号 @samp{$} に英字、数字、下線 @samp{_}、または漢字の列を続けたもの
@end itemize

@noindent
上の2種類の間に意味上の区別はありません。

音名や長さ記号とは異なり、大文字と小文字は違う文字として区別されます。
識別子に文字数の制限はありません。
漢字を識別子に含める場合、漢字コードはEUCまたはShift-JISである
必要があります。

次に挙げる語は予約されているため識別子として使用できません。
表中の @samp{b*[0-9]*} は0個以上の @code{b} に続けて更に0個以上の
数字が続くことを意味し、例えば
@code{Ab*[0-9]*} は @code{A}, @code{Ab}, @code{A2}, @dots{Ab2} などを
意味します。

@example
Ab*[0-9]*       Bb*[0-9]*       Cb*[0-9]*       Db*[0-9]*       Eb*[0-9]*
Fb*[0-9]*       Gb*[0-9]*       H               I               Q
Rb*[0-9]*       S               U               W               Z
ab*[0-9]*       ac              add_eff_chs     add_eff_etypes  all
alt             append          arbit           attach          bb*[0-9]*
bend            break           case            cb*[0-9]*       ch
close           cpr             ctrl            ctrl_any        ctrl_cto
ctrl_pt         ctrl_to         db*[0-9]*       def             default
defeff          defthread       del_eff_chs     del_eff_etypes  detach
disable         do              dp              dr              dt
du              eb*[0-9]*       ecode           edef            else
elsif           enable          end             eval            evalstr
excl            excl2           fb*[0-9]*       for             foreach
gb*[0-9]*       gr              gt              h               i
if              include         init            insert          key
keysig          kp              l               load            loadtrk
local           meta            n               note            note_off
note_on         null            nv              o               prog
q               rb*[0-9]*       reject          repeat          rt
s               seqno           set_eff_chs     set_eff_etypes  set_thru_chs
set_thru_etypes sh              shift           shl             shr
signal          smpte           switch          t               tb
tempo           text            timesig         tk              tp
u               undef           v               w               wait
while           wrap            xor             z               
@end example

上に示すようにPMMLの予約語は数が多く、またかなり短いもの
（例えば @code{i} など）も含まれているため、使用する時には注意が必要です。
先頭にドル記号をつければ、確実に予約語を避けることができます。

必ずしも守る必要はありませんが、変数型マクロにはドル記号を
つけて、関数型マクロやスレッド名にはドル記号をつけないというルールで
プログラムを書くと、わかりやすいプログラムになります。

@subsubheading 識別子の例

@example
id x $i under_score p5c $_z 演奏回数
@end example

@subsubheading 識別子の反例

@example
_id i$ a db 
@end example

@ifset html
<A NAME="ACCENT"></A>
@end ifset
@node Accents, Time Shifters, Identifiers, Lexical Rules
@section アクセント記号
@cindex アクセント記号(accents)
@findex ++
@findex --

アクセント記号は音符のベロシティーを加減するために
使われます(@pxref{Modifiers}, @ref{Changing Registers})。
利用できるアクセント記号と、それによるベロシティーの増加値を
下に示します。@samp{ac} は @code{ac} レジスタの値を
意味しています(@pxref{Registers})。
 
@table @asis
@item @code{+.}
@code{ac} * 0.5 (@t{ac}=16 のときは 8)

@item @code{++}
@code{ac} (@t{ac}=16 のときは 16)

@item @code{++.}
@code{ac} * 1.5 (@t{ac}=16 のときは 24)

@item @code{+++}
@code{ac} * 2 (@t{ac}=16 のときは 32)

@item 2つ以上の@samp{+}の列
@code{ac} * (@samp{+}の数 @minus{} 1)

@item 1つ以上の@samp{+}の列に@samp{.}を続けたもの
@code{ac} * (@samp{+}の数 @minus{} 0.5)

@item @code{-.}
@minus{}@code{ac} * 0.5 (@t{ac}=16 のときは @minus{}8)

@item @code{--}
@minus{}@code{ac} (@t{ac}=16 のときは @minus{}16)

@item @code{--.}
@minus{}@code{ac} * 1.5 (@t{ac}=16 のときは @minus{}24)

@item @code{---}
@minus{}@code{ac} * 2 (@t{ac}=16 のときは @minus{}32)

@item 2つ以上の@samp{-}の列
@minus{}@code{ac} * (@samp{-}の数 @minus{} 1)

@item 1つ以上の@samp{-}の列に@samp{.}を続けたもの
@minus{}@code{ac} * (@samp{-}の数 @minus{} 0.5)
@end table

@node Time Shifters, Tokens, Accents, Lexical Rules
@section 時刻シフト記号
@cindex 時刻シフト記号(time shifter)
@findex >>
@findex <<

時刻シフト記号はイベントの発生時刻を前後にずらすために
用いられます(@pxref{Modifiers}, @ref{Changing Registers})。
利用できる時刻シフト記号と、それによる時刻の増加値を
下に示します。@samp{sh} は @code{sh} レジスタの値を
意味しています(@pxref{Registers})。
 
@table @asis
@item @code{>.}
@code{sh} * 0.5 (@t{sh}=1/32 のときは 1/64)

@item @code{>>}
@code{sh} (@t{sh}=1/32 のときは 1/32)

@item @code{>>.}
@code{sh} * 1.5 (@t{sh}=1/32 のときは 3/64)

@item @code{>>>}
@code{sh} * 2 (@t{sh}=1/32 のときは 1/16)

@item 2つ以上の@samp{>}の列
@code{sh} * (@samp{>}の数 @minus{} 1)

@item 1つ以上の@samp{>}の列に@samp{.}を続けたもの
@code{sh} * (@samp{>}の数 @minus{} 0.5)

@item @code{<.}
@minus{}@code{sh} * 0.5 (@t{sh}=1/32 のときは @minus{}1/64)

@item @code{<<}
@minus{}@code{sh} (@t{sh}=1/32 のときは @minus{}1/32)

@item @code{<<.}
@minus{}@code{sh} * 1.5 (@t{sh}=1/32 のときは @minus{}3/64)

@item @code{<<<}
@minus{}@code{sh} * 2 (@t{sh}=1/32 のときは @minus{}1/16)

@item 2つ以上の@samp{<}の列
@minus{}@code{sh} * (@samp{<}の数 @minus{} 1)

@item 1つ以上の@samp{<}の列に@samp{.}を続けたもの
@minus{}@code{sh} * (@samp{<}の数 @minus{} 0.5)
@end table

@node Tokens,  , Time Shifters, Lexical Rules
@section トークン
@cindex トークン 

入力ソーステキストを字句解析部によってトークンへ分解されます。
トークンには以下の種類があります。

@itemize @bullet
@item 
整数定数
@item
浮動小数点定数
@item
文字列定数
@item
識別子
@item
音高定数 (相対オクターブ指定も含めて1つのトークンとして扱われます)
@item
有理数定数
@item
予約語
@item
オクターブ上下記号(@code{^}, @code{^^}, @code{^^^}, @dots{},
@code{_}, @code{__}, @code{___}, @dots{})
@item
時刻シフト記号(@code{>.}, @code{>>}, @code{>>.}, @dots{},
@code{<.}, @code{<<}, @code{<<.}, @dots{})
@item
アクセント記号(@code{+.}, @code{++}, @code{++.}, @dots{},
@code{-.}, @code{--}, @code{--.}, @dots{})
@item
その他の複合記号(@code{>=}, @code{<=}, @code{&&}, @code{||},
@code{==}, @code{!=}, @code{+=}, @code{-=}, @code{*=}, @code{/=},
@code{%=}, @code{shl=}, @code{shr=}, @code{&=}, @code{xor=},
@code{|=}, @code{::}, @code{%@{}, @code{===}, @code{..}, @code{...})
@item
単独の記号(@code{+}, @code{@{}, @code{=} など)
@end itemize

@c --------------------------------------------------------------------
@node Data Types and Expressions, Basic Commands, Lexical Rules, Top
@chapter データ型と式

@menu
* Data Types::                  PMMLの６つのデータ型について 
* Expressions::                 PMMLの式とは？
* Token-list Constants::        トークン列定数の書き方 
* Array Constants::             配列定数の書き方 
* Logical Values::              論理値の定義 
* Operators::                   すべての演算子とその意味の説明
* Type Conversion::             暗黙の型変換に関する規則 
@end menu

@node Data Types, Expressions, Data Types and Expressions, Data Types and Expressions
@section データ型
@cindex データ型
@cindex 整数型
@cindex 浮動小数点型
@cindex 有理数型
@cindex 文字列型
@cindex トークン列型
@cindex 配列型

PMMLで扱えるデータの型には以下の６つがあります。

@itemize @bullet
@item
整数型 @*
32ビットの符号つき整数です。

@item
浮動小数点型 @*
倍精度(64ビット)の浮動小数点型です。

@item
有理数型 @*
PMMLの有理数は a + b / c という帯分数の形で表現されています。
a は @minus{}32768 から 32767 までの整数、
b は 0 から 16383 までの整数、c は 1 から 16383 までの整数です。
b は c 未満という関係が必ず成り立っています。
有理数は主に時間を表すために使われます。

@item
文字列型 @*
可変長の文字列がサポートされています。
文字列の長さに制限はありません。

@item 
トークン列型 @*
0個以上のトークンの列です。

@item
配列型 @*
配列は0個以上の要素データを集めたものです。
各要素データのデータ型はここに挙げられている６種類のどれでも良く、
要素毎にデータ型が異なっていても構いません。
配列の要素がまた配列であることも可能であり、
これによって２次元以上の配列を構成することができます。

配列の要素数に上限はありません。
また、既にある配列の要素数を動的に増減することができます。

配列の各要素は１から始まる添字によってランダムにアクセスすることができます。
アクセスにかかる時間は配列の要素数や添字の大きさとは関係なく一定です。
@end itemize

@node Expressions, Token-list Constants, Data Types, Data Types and Expressions
@section 式
@cindex 式
@cindex 一次式

式とは、次に挙げる一次式(primary expression)のいずれか、
または、それらを演算子によって結合したものです。
式の型は6つのデータ型のうちのいずれかになります。

@noindent
一次式とそのデータ型

@display
整数定数 (整数型)
浮動小数点定数 (浮動小数点型)
有理数定数 (有理数型)
音高定数 (整数型)
レジスタ (レジスタにより整数型または有理数型)
文字列定数 (文字列型)
トークン列定数 (トークン列型)
配列定数 (配列型)
@end display

@node Token-list Constants, Array Constants, Expressions, Data Types and Expressions
@section トークン列定数

トークン列定数は、例えば @samp{$x = 'c4 d4'} というように代入演算子によって
マクロを定義する場合に利用されます。トークン列定数には次の
２種類の形式があります。

@table @t
@item '@var{token} @dots{}'
シングルクオートで囲んだ０個以上のトークンの列です。
シングルクオート内では
マクロ展開、引数置換、及びマクロ指令の評価は一切行われません。

@item `@var{token} @dots{}`
バッククオートで囲んだ０個以上のトークンの列です。
バッククオート内では引数置換と @code{eval} 及び @code{evalstr} マクロ指令の
評価だけは行われますが、マクロ展開及びこれ以外のマクロ指令の評価は
行われません。
@end table

@node Array Constants, Logical Values, Token-list Constants, Data Types and Expressions
@section 配列定数
@cindex 配列定数

配列定数のフォーマットは下の通りです。

@example
#(@var{EXPR}, @var{EXPR}, @dots{})
@end example

式 @var{EXPR} の型はどんな型でも構いません。
また、要素毎に型が異なっていても構いません。

@samp{#()} と記述すると、要素数０の配列を表現できます。

@subsubheading 配列定数の例

@example
#(1, 2, 3)
#("Mozart", 1756, "Salzburg")
#(c4+5, w*2)
#(#(1,0,0), #(0,1,0), #(0,0,1))
#(#("a", "b", "c"), #(2,3), #(0))
#('c4', 'e4', 'g4++', '[c2 c3]')
@end example

@node Logical Values, Operators, Array Constants, Data Types and Expressions
@section 論理値
@cindex 論理値
@cindex 真
@cindex 偽

@code{if} 及び @code{while} コマンドの条件式や、
論理演算子（@samp{!}、@samp{&&}、@samp{||}）
条件演算子（@samp{? :}）の演算数において、
式の値が``偽''と見なされるのは次の場合です。

@itemize @bullet
@item 
値が 0 の整数
@item 
値が 0.0 の浮動小数点数
@item 
値が 0 の有理数
@item 
空の文字列、つまり @samp{""}
@item 
空のトークン列、つまり @samp{''}
@item 
空の配列、つまり @samp{#()}
@end itemize

@noindent
これ以外の場合には``真''だと見なされます。

@ifset html
<A NAME="OPR"></A>
@end ifset
@node Operators, Type Conversion, Logical Values, Data Types and Expressions
@section 演算子
@cindex 演算子
@cindex 演算順位
@cindex オーバーフロー

PMMLにはC言語に類似した演算子が用意されています。
下に使用できる演算子の一覧を示します。
行頭の `[数字]' は演算順位を示し、この数字が高い演算子から先に
評価されます。
同じ演算順位の２項演算子が複数ある場合は、左にある方が先に評価されます。
演算優先順位は括弧 @samp{()} を使って変更可能です。

@table @asis
@item [13] @samp{[ ]}
配列の要素を取り出します(@pxref{Array Subscripting})。

@item [12] @samp{-} (単項)
符号反転を行います。整数、浮動小数点、有理数に対して使用可能です。

@item [12] @samp{!} (単項)
論理反転を行います。すなわち、
演算数が真(@pxref{Logical Values})ならば０、偽ならば１を結果として与えます。
すべてのデータ型に対して使用可能です。

@item [12] @samp{~} (単項)
ビット反転を行います。整数に対して使用可能です。

@item [12] @samp{#} (単項)
配列の要素数を与えます(@pxref{Array Size})。

@item [12] @samp{@@} (単項)
配列をコンマで区切ったトークン列に変換します(@pxref{Array Expansion})。

@item [11] @samp{*}
乗算を行います。整数、浮動小数点、有理数に対して使用可能です。

@item [11] @samp{/}
除算を行います。整数、浮動小数点、有理数に対して使用可能です。
整数どうしの除算では、結果も整数になります。
０での除算はエラーになります。

@item [11] @samp{%}
剰余算を行います。整数、浮動小数点、有理数に対して使用可能です。
整数の場合、演算数のどちらかが負であるときの結果は処理系に依存します。
浮動小数点または有理数の場合、X % Y の結果は、X を Y で割った商を
０の方向へ丸めた整数を n としたとき、X @minus{} n * Y です。
０での除算はエラーになります。

@item [10] @samp{+}
加算または文字列連結を行います。
整数、浮動小数点、有理数、そして文字列に対して使用可能です。

@item [10] @samp{-}
減算を行います。
整数、浮動小数点、有理数に対して使用可能です。

@item [ 9] @samp{shl}
左シフトを行います。
整数に対して使用可能です。

@item [ 9] @samp{shr}
右シフト（算術シフト）を行います。
整数に対して使用可能です。

@item [ 8] @samp{<}
@itemx [ 8] @samp{<=}
@itemx [ 8] @samp{>}
@itemx [ 8] @samp{>=}
大小比較を行い、結果として１(真の場合)または０(偽の場合)を与えます。
整数、浮動小数点、有理数、そして文字列に対して使用可能です。
文字列の場合は辞書的順序での比較になります。

@item [ 7] @samp{==}
@item [ 7] @samp{!=}
一致比較を行い、結果として１(真の場合)または０(偽の場合)を与えます。
すべてのデータ型に対して使用可能です。
整数、浮動小数点、有理数の間では、演算数どうしの型が異なっている場合、
型変換が行われた上で比較が行われます。それ以外の型で型が異なっている
場合は、"一致しない" と見なされます。
配列どうしの比較では、配列のネスト構造が同一で、かつすべての要素の値が
等しいときに限り、"一致する" と見なされます。

@item [ 6] @samp{&}
ビット論理積を求めます。整数に対して使用可能です。

@item [ 5] @samp{|}
ビット論理和を求めます。整数に対して使用可能です。

@item [ 4] @samp{xor}
ビット排他的論理和を求めます。整数に対して使用可能です。

@item [ 3] @samp{&&}
論理積を求めます。
すべてのデータ型に対して使用可能です。
C言語と異なり、第１演算数の真偽にかかわらず第２演算数は必ず評価されます。
従って、例えば @samp{if( defined($x) && $x == 3 )} という場合、
@code{$x} が定義されていないと第２演算数を評価した時に "Undefined macro" の
エラーになってしまいます。
C言語と同じように、第１演算数の真のときだけ第２演算数を評価
するためには、第２演算数を @samp{if( defined($x) && @{ $x == 3 @} )} の
ように、中括弧で囲みます。

@item [ 2] @samp{||}
論理和を求めます。
すべてのデータ型に対して使用可能です。
@samp{&&} と同様、第１演算数が偽のときだけ第２演算数を評価
するためには、第２演算数を中括弧で囲む必要があります。

@item [ 1] @samp{? :}
条件演算子と呼ばれ、第１演算数が真(@pxref{Logical Values})のときは第２演算数、
偽のときは第３演算数を結果として与えます。
演算数はどんなデータ型でも構いません。

C言語と異なり、第１演算数の真偽にかかわらず第２、３演算数は
両方とも評価されます。
C言語と同じように、第２、３演算数のどちらか一方だけを評価するためには、
@samp{if( defined($x) ? @{$x@} : @{10@} )}ように、
第２、３演算数を中括弧で囲む必要があります。

条件演算子がネストした場合は、右から評価が行わます。例えば
@samp{a ? b : c ? d : e} は @samp{a ? b : (c ? d : e)} と等価です。
@end table

@noindent
C言語との非互換性は以下の通りです。

@itemize @bullet
@item 
インクリメント演算子 @samp{++}、デクリメント演算子 @samp{--} は
ありません。

@item
シフト演算子は @samp{<<}, @samp{>>} ではなく @samp{shl}, @samp{shr} です。
@samp{$y = $x shl 2} のように使用します。

@item
ビットEX-OR演算子は @samp{^} ではなく @samp{xor} です。

@item
論理演算子（@samp{&&}, @samp{||}）及び条件演算子（@samp{? :}）では、
中括弧を使用しない限り、全演算数が常に評価されます（上記参照）。
@end itemize

@subheading オーバーフローについて

整数の算術演算では、オーバーフローのチェックは一切行われません。
有理数の算術演算において、分母がオーバーフローする場合（例えば
@samp{w/480 + w/481}という場合）は、警告が出力された後、
表現可能な最も近い分数に丸められます。
有理数の整数部に関してはオーバフローのチェックはありません。

@node Type Conversion,  , Operators, Data Types and Expressions
@section データ型の変換規則
@cindex データ型の変換規則
@cindex 型変換規則

整数、有理数、浮動小数点数の間では暗黙のうちに型変換が行われます。
ここではその変換規則について説明します。

型変換においては、浮動小数点型を最高位、次いで有理数型、
そして整数型を最低位と考えます。
２項演算で演算数の型が異なっている場合、そのうちでより高位の方の型に
まず統一されてから演算が行われ、結果もその型になります。

@subheading 低位から高位への変換

このような型変換は、式の演算が行われるとき、コマンドやマクロに
引数を渡すとき、及び有理数型レジスタに整数を代入するときに起こります。

@itemize @bullet
@item
整数型から浮動小数点型への変換は、等しい値へ変換されます。

@item
整数型から有理数型への変換は、整数をティック数だと見なし、
整数 1 が 1 ティック（1/1920）になるように変換されます。
例えば、整数 480 は有理数 1/4 へ変換されます。
ただし、乗除算（剰余算も含む）のときだけは例外で、
演算数の片方が整数でもう片方が
有理数のときには、整数の値をそのまま有理数だと見なして演算が
行われます。従って、例えば @samp{q*2} の結果は有理数 1/2 となり、
2 をティック数だと見なして 2/1920 と 1/2 の積をとるという
意味にはなりません。

@item
有理数型から浮動小数点型への変換は、ティック数への変換となります。
例えば、有理数 1/4 は 480.0 へ、1/13 は 147.692 へそれぞれ変換されます。
@end itemize

@subheading 高位から低位への変換

このような型変換は、レジスタに値を代入するとき、及びコマンドやマクロに
引数を渡すときに起こります。

@itemize @bullet
@item
浮動小数点型から整数型への変換は、
最も近い整数への丸め（いわゆる四捨五入）によって行われます。
C言語とは異なりますので注意して下さい。

@item
浮動小数点型から有理数型への変換は、浮動小数点数をテイック数と見なし、
表現可能な最も近い分数へ変換します。例えば、480.0 は 1/4 へ、
480.1 は 4801/19200 へそれぞれ変換されます。

@item
有理数型から整数への変換は、ティック数への変換となり、
最も近いティック数への丸めが行われます。
例えば、1/4 は 480 へ、1/13 は 148 へそれぞれ変換されます。
@end itemize

@c --------------------------------------------------------------------
@node Basic Commands, Event Generating Commands, Data Types and Expressions, Top
@chapter 基本的なコマンド

@menu
* Registers::                   レジスタの役割とその変更方法 
* Note Command::                音符コマンド 
* Note Length::                 音価（ステップタイム）の指定方法 
* Note Duration::               音の持続時間（ゲートタイム）の指定方法  
* Key::                         調と臨時記号について 
* Threads::                     スレッドの概念とその生成、切り替えの方法
                                和音、複数パートを記述する方法
* Modifiers::                   音符属性を一時的に変更する修飾子の説明 
* No Operation::                何もしないコマンド 
@end menu

@node Registers, Note Command, Basic Commands, Basic Commands
@section レジスタとその変更

レジスタはイベント生成のコマンドの実行に必要な情報を記憶します。
レジスタには有理数型と整数型があります。

@menu
* Register Sets::               全レジスタの一覧 
* Pseudo Registers::            疑似レジスタの一覧
* Changing Registers::          レジスタの値を変更する方法
@end menu

@node Register Sets, Pseudo Registers, Registers, Registers
@subsection レジスタ一覧
@cindex レジスタ

以下にPMMLの全レジスタの名前、その名前の由来、型、意味、及び初期値を示します。

@table @asis
@item @code{t} (@b{T}ime: 有理数型)
@findex t
現在の時刻を表します。この値を基準にして
イベント発生時刻（音符コマンドの場合はノートオンの時刻）が決定されます。
初期値は 0 です。

@item @code{tb} (@b{T}ime @b{B}ase: 有理数型)
@findex tb
@code{rt} 疑似レジスタ(@pxref{Pseudo Registers})で
相対時刻指定するときの基準時刻です。初期値は 0 です。

@item @code{dt} (@b{D}elta @b{T}ime: 有理数型)
@findex dt
イベント発生時刻の修正値です。
イベントが生成されるとき、その実際の時刻は (@code{t} + @code{dt}) に
なります。
音符コマンドの場合、ノートオフの時刻にもこのレジスタの値が加算されます。
初期値は 0 です。

@item @code{sh} (@b{SH}ift time: 有理数型)
@findex sh
時刻シフタ記号(@pxref{Time Shifters})によって増減される時間の
大きさの基準値です。初期値は 1/32 (32 分音符の長さ) です。

@item @code{l} (@b{L}ength: 有理数型)
@findex l
音価（ステップタイム、
すなわち音符コマンドによって前に進められる時間の大きさ）です。
初期値は 1/4 (４分音符の長さ) です。

@item @code{do} (@b{D}uration @b{O}ffset: 有理数型)
@findex do
音の持続時間（ゲートタイム、
すなわちノートオンからノートオフまでの時間）の
オフセット値です(@pxref{Note Duration})。
初期値は 0 です。

@item @code{dp} (@b{D}uration @b{P}ercentage: 整数型)
@findex dp
音の持続時間の音価に対する係数を百分率で
表したものです(@pxref{Note Duration})。
初期値は 100 です。

@item @code{tk} (@b{T}rac@b{K}: 整数型)
@findex tk
イベントが格納されるトラックのトラック番号です(@pxref{Tracks})。
初期値は出力ファイルが format-0 または format-1 の場合で 2、
format-2 の場合で 1 です。
 
@ifset html
<A NAME="CHREG"></A>
@end ifset
@item @code{ch} (@b{CH}annel: 整数型)
@findex ch
生成されるイベントのMIDIチャネル番号を表します(@pxref{MIDI Channels})。
初期値は 1 です。

@item @code{n} (@b{N}ote number: 整数型)
@findex n
生成されるノートオン／オフイベントまたはキーアフタータッチイベントの
ノート番号を表します。
このレジスタの値が 0x80000000 であるときは、音符コマンドによって
休符が生成されます。
初期値は 0x80000000 です。

@item @code{tp} (@b{T}rans@b{P}ose: 整数型)
@cindex 移調
@findex tp
音高定数の定数値に加算される値です。
また @code{load} および @code{loadtrk} コマンドで標準MIDIファイルを
読み込む際にも、各イベントのノート番号に加算されます。
移調を行うために利用できます。
初期値は 0 です。

@ifset html
<A NAME="OREG"></A>
@end ifset
@item @code{o} (@b{O}ctave: 整数型)
@findex o
オクターブを表します。
音高定数の定数値はこのレジスタの値に依存します(@pxref{Pitch Constants})。
初期値は 4 です。

@item @code{key} (@b{KEY}: 整数型)
@findex key
曲の調を表し、正の場合シャープの数、負の場合フラットの数を意味します。
詳しくは @ref{Key} の項を参照して下さい。
初期値は 0 です。

@ifset html
<A NAME="VREG"></A>
@end ifset
@item @code{v} (@b{V}elocity: 整数型)
@findex v
@cindex ベロシティー
生成されるノートオンイベントのベロシティーを示します。
初期値は 80 です。

@item @code{nv} (@b{N}ote-off @b{V}elocity: 整数型)
@findex nv
@cindex ノートオフベロシティー
生成されるノートオフイベントのベロシティーを示します。
このレジスタが負の場合には、
ノートオフメッセージの代わりにベロシティーが０のノートオンメッセージが
生成されるようになります（通常これはMIDIトラフィックを減少させる
効果があります）。
初期値は @minus{}1 です。
@end table

@node Pseudo Registers, Changing Registers, Register Sets, Registers
@subsection 疑似レジスタ
@cindex 疑似レジスタ
@findex rt
@findex du
@findex gt
@findex dr
@findex gr

疑似レジスタは、実際に記憶領域を占めるものではありませんが、
文法的にはレジスタと全く同様に扱われ、
レジスタと同じ方法によって値の参照や変更がが可能です。

@table @asis
@item @code{rt} (@b{R}elative @b{T}ime: 有理数型)
@code{tb} レジスタで表される時刻を基準とした現在の時刻です。
この疑似レジスタに値 @var{x} を代入すると、@code{t} レジスタに 
(@code{tb} + @var{x}) の値が代入されます。
この疑似レジスタを読み出すと、(@code{t} - @code{tb}) の値が得られます。

@item @code{du} (@b{DU}ration: 有理数型)
音の持続時間（ゲートタイム）を表します(@pxref{Note Duration})。
この疑似レジスタに値 @var{x} を代入すると、
@code{do} レジスタに @var{x} が代入され、
更に @code{dp} レジスタに 0 が代入されます。
この疑似レジスタを読み出すと、(@code{do} + @code{l} * @code{dp} / 100) 
の値が得られます。

@item @code{gt} (@b{G}ate @b{T}ime: 有理数型)
これは @code{du} 疑似レジスタの別名であり、それと全く同じ意味を持ちます。

@item @code{dr} (@b{D}uration @b{R}atio: 整数型)
音の持続時間（ゲートタイム）の
音価（ステップタイム）に対する百分率です(@pxref{Note Duration})。
この疑似レジスタに値 @var{x} を代入すると、
@code{dp} レジスタに @var{x} が代入され、
更に @code{do} レジスタに 0 が代入されます。
この疑似レジスタを読み出すと、@code{dp} レジスタの値が得られます。

@item @code{gr} (@b{G}ate time @b{R}atio: 整数型)
これは @code{dr} レジスタの別名であり、それと全く同じ意味を持ちます。
@end table

@node Changing Registers,  , Pseudo Registers, Registers
@subsection レジスタ内容の変更
@cindex レジスタ代入
@cindex 複合代入演算子
@cindex オクターブの指定
@cindex オクターブアップコマンド
@cindex オクターブダウンコマンド
@cindex アクセントコマンド
@cindex 時刻シフトコマンド

レジスタの内容を変更するためのコマンドには以下のものがあります。

@table @t
@ifset html
<A NAME="REGASSIGN"></A>
@end ifset
@item @r{C:} @var{reg} = @var{expr}
@findex =
@findex @var{reg} = @var{expr}
レジスタまたは疑似レジスタ @var{reg} に式 @var{expr} の値を代入します。

@item @r{C:} @var{reg} @var{op}= @var{expr}
@findex @var{op}= 
@findex @var{reg} @var{op}= @var{expr}
これは、

@example
@var{reg} = @var{reg} @var{op} @var{expr}
@end example

と等価です。@var{op} は次の演算子のうちのいずれかです。

@example
+ - * / % shl shr & xor |
@end example

@item @r{C:} @r{有理数定数で始まる式}
@findex 有理数定数で始まる式
このコマンドは @code{l} レジスタに式の値を代入します。
@ref{Note Length}を御覧下さい。

@ifset html
<A NAME="OCTAVEUP"></A>
@end ifset
@item @r{C:} ^@r{,} ^^@r{,} ^^^@r{, @dots{}}
@findex ^
これはオクターブアップコマンドと呼ばれ、記号の数だけ @code{o} レジスタを
増やします。

オクターブアップコマンドは、音高定数(@pxref{Pitch Constants})の
相対オクターブ指定と形式が同じであることに注意して下さい。
@samp{o=4 ^C D} のように @samp{^} の後にスペースを置かずに
直接音名を続けた場合には、@samp{^} はオクターブアップコマンドではなく、
音高定数の一部だと見なされます。この結果、
@samp{^C} によって @code{o} レジスタの値が変更されることはなく、
C音のオクターブは 5 ですがD音のオクターブは 4 のままです。
@samp{^} をオクターブコマンドだと認識させるためには、スペースを挿入して
@samp{o=4 ^ C D} のように記述する必要があります。こうすると、C音、D音の
オクターブはともに 5 になります。

@ifset html
<A NAME="OCTAVEDOWN"></A>
@end ifset
@item @r{C:} _@r{,} __@r{,} ___@r{, @dots{}}
@findex _
これはオクターブダウンコマンドと呼ばれ、記号の数だけ @code{o} レジスタを
減らします。上記のオクターブアップコマンドと同様の注意が必要です。

@item @r{C:} @var{accent}
@findex ++
@findex --
これはアクセントコマンドと呼ばれ、@code{v} レジスタに
アクセント記号 @var{accent} (@pxref{Accents}) で示される
ベロシティーの増減値を加算します。

アクセント記号が修飾子(@pxref{Modifiers})としての役割もあるという
点には、注意が必要です。
アクセント記号の直前に修飾子を伴うコマンドが存在する場合には、
それはアクセントコマンドではなく、直前のコマンドに対する修飾子だと
認識されてしまいます。強制的にアクセントコマンドだと認識させるには、
直前に @samp{;} を挿入します(@pxref{No Operation})。

@item @r{C:} @var{time-shifter}
@findex <<
@findex >>
これは時刻シフトコマンドと呼ばれ、@code{dt} レジスタに
時刻シフト記号 @var{time-shifter} (@pxref{Time Shifters}) で示される
時刻の増減値を加算します。

時刻シフト記号も、アクセント記号と同様、修飾子(@pxref{Modifiers})
としての役割もありますので、注意して下さい。

@item @r{SM:} fff
@itemx @r{SM:} ff
@itemx @r{SM:} forte
@itemx @r{SM:} mf
@itemx @r{SM:} mp
@itemx @r{SM:} p
@itemx @r{SM:} pp
@itemx @r{SM:} ppp
これらの標準マクロは @code{v} レジスタの値をそれぞれ
127, 110, 95, 80, 65, 50, 35, 20 に変更します。
例えば @code{v=95} と書く変わりに @code{forte} と書くことができます。
@end table

@node Note Command, Note Length, Registers, Basic Commands
@section 音符コマンド
@cindex 音符コマンド
@cindex 音符
@cindex 休符

音符コマンドは音符または休符を生成するコマンドです。
音符コマンドには２つの形式があります。

@table @t
@item @r{C:} @var{pitch-constant} @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@findex @var{pitch-constant}
音高定数 @var{pitch-constant} が @code{R} または @code{r} 以外のとき、
一組のノートオンイベントとノートオフイベントが生成されます。
その後、@code{t} レジスタに @code{l} レジスタの値が加算されます。
@var{pitch-constant} が @code{R} または @code{r} のときは
休符を表し、イベントは生成されませんが @code{t} レジスタは上と同じように
更新されます。

@var{modifiers} については @ref{Modifiers} を参照して下さい。
@samp{&} は時刻の前進させないという意味を持ち、
これがつけられたときには、@code{t} レジスタの値は更新されません。

生成されるイベントのMIDIノート番号は @var{pitch-constant} の
値になります。
MIDIチャネル番号は @code{ch} レジスタ、
格納先トラック番号は @code{tk} レジスタの値が使われます。
ノートオンイベントの時刻は (@code{t} + @code{dt}) の値、
ベロシティは @code{v} の値になります。
ノートオンイベントとノートオフイベントの時間間隔、すなわち
音の持続時間は (@code{do} + @code{l} * @code{dp} / 100) と 0 の
大きい方の値となります(@pxref{Note Duration})。
ノートオフイベントのノートオフベロシティは @code{nv} の値によって
決定されます。

音符コマンドの実行によって、@code{n} レジスタの値は @var{pitch-constant} の
値になります。
@ignore
また、@var{pitch-constant} に絶対オクターブ指定が使われて
いる場合（例えば, @code{C4}, @code{D#5} などのような場合）、
@code{o} レジスタの値はそのオクターブに変更されます。
@end ignore

@item @r{C:} note @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@cindex 式によるノート番号の指定
@findex note
この形式では、MIDIノート番号の決定に音高定数の値ではなく
@code{n} レジスタの値が使われます。すなわち、
@code{n} の値が生成されるイベントのMIDIノート番号になります。
それ以外の点については最初の形式
と同じです。この形式は、次のようにノート番号を式によって
指定するために主に利用されます。

@example
note(n=C4+1)

for($i,C4,B4) @{ note(n=$i) @}
@end example
@end table

@node Note Length, Note Duration, Note Command, Basic Commands
@section 音価（ステップタイム）の指定
@cindex 音価の指定
@cindex タイ
@cindex 連符
@cindex ステップタイムの指定

PMMLでは音符コマンドによって前に進められる時間の
大きさを @dfn{音価} あるいは @dfn{ステップタイム} と呼んでいます。
音価は @code{l} レジスタに記憶されています。

有理数定数で始まる式は、音価を指定する
（すなわち @code{l} レジスタに式の値をセットする）
コマンドとして認識されます。
簡単には、有理数定数だけ使って例えば @code{i} と書けば、
@code{l} レジスタに有理数の 1/8 が代入され、
以後の音符が８分音符を意味するようになります。
最初が有理数定数で始まってさえいれば式を使うことが
できますので、例えば、

@example
w+h  z/2  q/7  2h/3  w+(q-i) 720u-5u
@end example

@noindent
という式はすべて音価を指定するコマンドとして認識されます。しかし、

@example
2*w  (w+h)
@end example

@noindent
のような式は音価指定のコマンドにはなりません。

@subheading タイ

PMMLには2つの音符を結ぶタイに相当する直接的なコマンドはありません。
例えば、C#音の4分音符と16分音符がタイで繋がれている場合は、

@example
q+s C#
@end example

@noindent
のように音価指定に加算を用いて表現します。

@subheading 連符

PMMLには連符表現のために特別に用意されたコマンドはありません。
音価指定で除算演算子を使うことによって容易に表現できるからです。
例えば、下のように表現します。

@example
q/3 C D E              // @r{4分音符を3分割した3連符}
h/5 C D E F G          // @r{2分音符を5分割した5連符}
3i/2 E D               // @r{3つの8分音符を2分割した2連符}
q/7 C C# D D# E F F#   // @r{4分音符を7分割した7連符}
@end example

@ifset html
<A NAME="DURATION"></A>
@end ifset
@node Note Duration, Key, Note Length, Basic Commands
@section 持続時間（ゲートタイム）の指定
@cindex 持続時間
@cindex ゲートタイム

@dfn{持続時間}（あるいは @dfn{ゲートタイム}）とはある
音符のノートオンからノートオフまでの時間を意味します。
持続時間を音価（ステップタイム）に対して短く設定すればスタッカート奏法に
なりますし、逆に持続時間の方を長くとれば次の音符と一部が重なって
発音されることになります。

持続時間は、@code{do} (オフセット値)と @code{dp} (音価に対する百分率)
という２つのレジスタの値に基づき、
音符コマンド実行時に次の式によって算出されます。

@display
持続時間 = @code{do} + @code{l} * @code{dp} / 100
@end display

@noindent
なお、上の計算の結果、持続時間が負になった場合には 0 に修正されます。

この指定法は非常に柔軟性があり、各レジスタ値を下のように
設定することによって、３つの典型的な指定法をすべてカバーします。

@table @code
@item do=0 dp=@var{percentage}
持続時間を音価に対する百分率によって指定します。
この２つの代入操作は
まとめて @code{dr=}@var{percentage} または @code{gr=}@var{percentage} と
書くことができます。

@item do=@var{duration} dp=0
持続時間を音価とは無関係に常に @var{duration} に固定します。
この２つの代入操作は
まとめて @code{du=}@var{duration} または @code{gt=}@var{duration} と
書くことができます。

@item do=@minus{}@var{gap} dp=100
持続時間を音価から @var{gap} を減じた値に設定します。
つまり、音符間の空白時間を常に @var{gap} に保ちます。
@end table

@subsubheading 持続時間の指定例

@noindent
次の例ではC,D,E音について持続時間を音価の半分に設定し、
最後のF音については音価の 70% (つまり 7h/10) に設定しています。

@example
dr=50 q C i D E h dr=70 F
@end example

@noindent
次の例ではC,D,E音について持続時間を16分音符の長さに設定し、
最後のF音については 800 ティックに設定しています。

@example
du=s q C i D E du=800u h F
@end example

@node Key, Threads, Note Duration, Basic Commands
@section 調と臨時記号
@cindex 調
@cindex 臨時記号
@cindex シャープ
@cindex フラット
@cindex ナチュラル

PMMLにはハ長調／イ短調以外の調において自動的にシャープまたはフラットを
つける機能があります。この機能を使うには、
@code{key} レジスタに対し調号に現れる
シャープ／フラットの数を設定します。
シャープの場合は正の数、フラットの場合は負の数をセットします。
例えば、ト長調／ホ短調の場合は @code{key=1}、
変ロ長調／ト短調の場合は @code{key=-2} とします。

下の例は、ヘ長調の曲の一部です。

@example
key=-1 
i A B ^C ^D q ^C ^C B% B% ^C Bb
@end example

最初の @code{B} は @code{key=-1} があることによって実際はBb音
になります。ナチュラルを付けたい場合には、@code{B%} のように
書きます。PMMLには小節の概念がありませんので、五線譜のように
臨時記号が一小節間有効という規則はなく、臨時記号はその音符にだけ
有効になります。従って、上の例のように @code{B%} が
２つ以上続く場合には、２つめ以降の音符にもすべてナチュラルをつける必要が
あります。最後のBb音はもとのフラットのついた音に戻すという意味で
フラットをつけていますが、このフラットは無くても同じです。

ダブルシャープやダブルフラットが必要なときには、
@samp{##}, @samp{bb} のように書きます。
自動でついているシャープを取り消してフラットにする場合は、
@samp{%b} と @samp{b} のどちらでも構いません。

@code{key} レジスタの操作と、出力MIDIファイルに調号イベントを
生成する @code{keysig} コマンド(@pxref{Meta Events})は、
それぞれ独立に働きます。つまり、@code{key} レジスタを変更しても
調号イベントが生成されることはなく、逆に、@code{keysig} コマンドを
実行しても @code{key} レジスタは変化しません。
従って、自動シャープ／フラット付けと調号イベント出力の両方を行う場合には、
@code{key=}@var{expr} と @code{keysig} コマンドの両方を書く必要があります。
これとは異なり、@code{keysig} コマンドではハ長調以外の調を
指定したいが、自動シャープ／フラット付けの機能は使いたくない
場合には、@code{keysig} コマンドだけを指定することもできます。

@ifset html
<A NAME="THREAD"></A>
@end ifset
@node Threads, Modifiers, Key, Basic Commands
@section スレッドとその関連コマンド
@cindex スレッド
@cindex スレッド階層
@cindex スレッド木
@cindex ルートスレッド
@cindex スレッド名

@dfn{スレッド} とは逐次的に実行される一連のコマンド列を意味します。
通常、PMMLでは並行に実行される複数の
スレッドを使って音楽を記述します。
スレッドは動的に生成され、消滅します。

各スレッドはレジスタ(@pxref{Registers})と
識別子辞書をそれぞれ独立に持ちます。
従って、あるスレッドにおいてレジスタを変更しても、
それが有効なのはそのスレッドにおける後続のコマンドだけであって、
他のスレッドのコマンドには影響を与えません。
また、あるスレッドにおいて定義されたマクロは他のスレッドから
ある条件が成立しない限り(@pxref{Calling Macros})呼び出すことはできません。

スレッドには @dfn{名前つきスレッド} と、@dfn{名前なしスレッド} の
２種類が存在します。@dfn{名前つきスレッド} は @dfn{スレッド名} を持ち、
複数の楽器パートの記述に主に利用されます。
@dfn{名前なしスレッド} は、レジスタの局所的な変更や和音の記述を
実現するために使われています。

スレッドには親子関係があり、名前つき／名前なしの両方を含む
すべてのスレッドは１つの木構造を形成します。
新たに生成されたスレッドはそれを生成したスレッドの子になり、
その際すべてのレジスタ値は親スレッドよりコピーされます。
木の根に位置するスレッドは @dfn{ルートスレッド} と呼ばれ、
コンパイラ起動時には唯一これだけが存在します。
ルートスレッドは名前つきスレッドで、スレッド名は @samp{global} です。

@menu
* Grouping::                    名前なしスレッドの生成し、一時的なレジスタの
                                変更を実現するグルーピングコマンドの説明
* Chords::                      和音の表現方法              
* Creating Named Threads::      名前つきスレッドの生成法  
* Switching Threads::           スレッドの切り替え方法 
* Wait for Child Threads::      スレッド間の時刻合わせを行うには？  
* Deleting Named Threads::      名前つきスレッドの消去法  
@end menu

@ifset html
<A NAME="GROUPING"></A>
@end ifset
@node Grouping, Chords, Threads, Threads
@subsection グルーピングコマンド
@cindex 名前なしスレッド
@cindex 局所的なレジスタの変更
@cindex 並行声部の表現

次のコマンドはグルーピングコマンドと呼ばれます。

@table @t
@item @r{C:} @{ @var{command} @r{@dots{}} @} @r{[}@var{modifiers}@r{] [}&@r{]}
@end table
@findex @{ @var{command} @dots{} @}

グルーピングコマンドは、新しい名前なしスレッドを子スレッドとして生成し、
そのスレッドにおいて中括弧内のコマンドを順に実行します。
すべてのコマンドの実行を終えると、その子スレッドは自動的に消滅します。
最後の @samp{&} は
Unixシェルにおけるバックグランド実行指定に類似しています。
最後の @samp{&} が無い場合、
中括弧内のコマンドの実行している間は親スレッドの実行が中断されます。
従って、グルーピングコマンド直後の
親スレッドの時刻（@code{t} レジスタの値）は、
中括弧内の最後のコマンドの実行を終えたときの時刻になります。
最後に @samp{&} がある場合には、
中括弧内のコマンドと中括弧の後のコマンドが並列に実行されます。
従って、グルーピングコマンド直後の親スレッドの時刻は、
グルーピングコマンドの実行前の時刻と変わりません。

@samp{&} を伴わないグルーピングコマンドは、レジスタの値を
一時的に変更したい場合に便利です。
子スレッドでのレジスタ変更は親スレッドのレジスタ値には
影響を与えませんから、
中括弧内でレジスタを変更すれば、
それは中括弧内のそれ以降のコマンドだけに影響する局所的な指示となります。
変更していないレジスタについては、
子スレッドが生成されるとき親スレッドから全レジスタの値がコピー
されていますので、親スレッドの値がそのまま残っています。
例えば、下の例ではE音とD音だけが 100 のベロシティで演奏され、それ以外の
音は 80 のベロシティで演奏されます。

@example
v=80 C D @{v=100 E F@} E D C
@end example

@samp{&} つきのグルーピングコマンドは、
一つのパートが一時的に複数の声部に分かれて演奏を行うようなときに
便利です。たとえば次の例では、３つの声部が並行に演奏されています。

@example
@{w D E@}& 
@{w F G@}& 
@{h ^C B w ^C@}
@end example

@noindent
この例は次節の和音コマンドを使って

@example
[@{w D E@} @{w F G@} @{h ^C B w ^C@}]
@end example

@noindent
と書くこともできますが、最初の２つの声部が最後の声部に対して
従属的であると考えられる場合には、最初の書き方のほうが
望ましいと思われます。

@subsubheading グルーピングコマンドと修飾子

他の多くのコマンドと同様、
グルーピングコマンドに対しても修飾子(@pxref{Modifiers})を
付けることが可能です。
修飾子の評価は、
グルーピングコマンドによって生成されたスレッドにおいて、
中括弧内のコマンドより先に行われます。
例えば、

@example
@{v=100 E F@}(ch=2) 
@end example

@noindent
では、@code{v=100} の前に @code{ch=2} が実行され、
その結果 E, F 両音のMIDIチャネルは２になります。これは、

@example
@{ch=2 v=100 E F@}
@end example

@noindent 
と書いても同じです。一般に、

@example
@{ @var{commands1} @} (@var{commands2})
@end example

@noindent 
は、@var{commands2} が @code{t} レジスタを変更しない限り、

@example
@{ @var{commands2} @var{commands1} @}
@end example

@noindent 
と等価です。

@ifset html
<A NAME="CHORD"></A>
@end ifset
@node Chords, Creating Named Threads, Grouping, Threads
@subsection 和音コマンド
@cindex 和音
@cindex 和音コマンド
@cindex 名前なしスレッド

和音は下に示す和音コマンドによって記述できます。

@table @t
@item @r{C:} [ @var{command} @r{@dots{}} ] @r{[}@var{modifiers}@r{] [}&@r{]}
@end table
@findex [ @var{command} @dots{} ]

@noindent
最初の @samp{[} と @samp{]} はテキスト中の記号そのものを表し、
``省略可''という意味ではありません。
つまり和音コマンドは、音符コマンドにおける
音高定数の部分を角括弧で囲まれたコマンド列で置き換えた形になっています。

和音コマンドはグルーピングコマンドと同様に、
新しい名前なしスレッドを子スレッドとして生成し、
そのスレッドにおいて角括弧内のコマンドを順に実行します。
グルーピングコマンドの違いは、角括弧内のコマンド
のうち @samp{&} オプション指定可能なものは、
すべて @samp{&} オプションがついていると見なして実行する点です。
例えば、

@example
[C E G]
@end example

@noindent
は、

@example
@{C& E& G&@}
@end example

@noindent
のように見なされ、結果としてド、ミ、ソからなる三和音を生成します。
音符の順番をどのように並べても同じ和音が生成されます。

和音コマンドによって進められる時間の大きさ（つまり @code{t} レジスタの
加算値）は、角括弧内の各コマンドによって進められる時間の大きさのうちでの
最大値になります（従って、上に示した２つの例は等価とは言えません）。
ただし、和音コマンドの最後に @samp{&} がある場合には、@code{t} レジスタの
値は変更されません。

@subsubheading 和音コマンドと修飾子

和音コマンドには修飾子(@pxref{Modifiers})をつけることも可能です。
この修飾子は和音全体を修飾するという意味を持ちます。例えば、

@example
[C E G](w)  [C F A]++
@end example

@noindent
はそれぞれ、和音を全音符の長さで演奏する、
和音中のすべての音のベロシティーを少し増やす、という意味になります。
これらは、

@example
[w C E G] [++ C F A]
@end example

@noindent 
と書いても同じです。一般に、

@example
[ @var{commands1} ] (@var{commands2})
@end example

@noindent 
は、@var{commands2} が @code{t} レジスタを変更しない限り、

@example
[ @var{commands2} @var{commands1} ]
@end example

@noindent 
と等価です。

@ifset html
<A NAME="CHORDSEQ"></A>
@end ifset
@subsubheading 和音コマンドの中のグルーピングコマンド

角括弧内のコマンドにグルーピングコマンドを含めることもでき、
これを用いると和音の中で一部の声部が逐次的に動くような構造を
表現できます。例えば、

@example
w [D5 @{h C5 B4@} G4]
@end example

@noindent
は、

@example
w [D5& @{h C5 B4@}& G4&]
@end example

@noindent
のように扱われ、各音符の発音期間を直線で表すと下の図のようになります。

@display
D5: ------------
C5: ------ 
B4:       ------
G4: ------------
@end display

@subsubheading 使用上の注意

和音コマンドの直前が配列である場合、@samp{[} が
要素参照の演算子であると誤認されてしまいますので、そのような
場合には和音コマンドの前に @samp{;} を挿入して下さい(@pxref{No Operation})。

@node Creating Named Threads, Switching Threads, Chords, Threads
@subsection 名前つきスレッドの生成
@cindex 名前つきスレッドの生成
@cindex 名前つきスレッド
@cindex スレッドの生成

名前つきスレッドは @code{defthread} コマンドによって
生成されます。
複数のパートを記述するために名前つきスレッドを利用する場合には、
標準マクロ @code{newtrack} を使う方が便利です。

@table @t
@item @r{C:} defthread(@r{[}@var{thread-path}@r{]}@var{thread-name}, @r{@dots{}} )
@findex defthread
各引数で指定したスレッド名の名前つきスレッドを生成します。
生成されるスレッドの親スレッドは、
スレッドのパス指定 @var{thread-path} (@pxref{Scope Specifiers})
がある場合にはそれで示されるスレッドになり、
指定のない場合には現スレッドになります。

１つのスレッドが、２つ以上の同じ名前の子スレッドを持つことは許されません。
親が異なればスレッド名は衝突していても構いませんが、
スレッド切り替えが難しくなるのでできる限り避けるべきです。

@ifset html
<A NAME="NEWTRACK"></A>
@end ifset
@item @r{SM:} newtrack(@r{[}@var{thread-path}@r{]}@var{thread-name}) @{ @var{command} @r{@dots{}} @}
@findex newtrack
スレッド名 @var{thread-name} の名前つきスレッドを生成し、
そのスレッドの @code{tk} レジスタに新しいトラック番号に設定し、
次のそのトラックに "@t{(}@var{thread-name}@t{)}" という文字列の
トラック名イベント(@pxref{Meta Events})を生成し、
最後にそのスレッドにおいてコマンド列 @var{command}@dots{} を実行します。
スレッドのパス指定 @var{thread-path} は @code{defthread} コマンドの場合と
同じ意味を持ちます。トラック番号は最初２から始められ、
以後 @code{newtrack} 標準マクロが呼ばれるごとに１ずつ増やされます。
コマンド列には、チャネル設定や音色設定などの初期化操作を記述します。
@end table

@ifset html
<A NAME="TSWITCH"></A>
@end ifset
@node Switching Threads, Wait for Child Threads, Creating Named Threads, Threads
@subsection 他スレッドでのコマンド実行
@cindex 他スレッドでのコマンド実行
@cindex スレッド切り替えコマンド
@cindex 複数パートの記述

現在とは別のスレッドにおいてコマンドを実行するためには、
スレッド切り替えコマンドと呼ばれる下のコマンドを使います。

@table @t
@item @r{C:} @r{[}@var{thread-path}@r{]}@var{thread-name} @{ @var{command} @r{@dots{}} @} @r{[}+@r{]}
@end table
@findex @var{thread-name} @{ @var{command} @dots{} @}

@noindent
このコマンドは @var{thread-name} という名のスレッドに対して
コマンド列 @var{command}@dots{} の実行を依頼します。
@var{thread-name} はスレッド木のどの位置にあるスレッドの名前でも
構いません。指定した名前のスレッドが複数ある場合には、
もし自分またはその先祖スレッドの中に @var{thread-name} という名の
スレッドが含まれているのなら、そのうちで一番世代の近いスレッドが選ばれます。
もし先祖スレッドに @var{thread-name} という名のスレッドが
含まれていないのなら、選ばれるスレッドは不定となります。
そのような曖昧さを避けるためには @var{thread-path} を使います。
@var{thread-path} の記述法については @ref{Scope Specifiers} を参照して
下さい。

依頼を受けた @var{thread-name} スレッドは、
以前に依頼を受けたコマンド列の実行がまだ完了していなければ
それが終わるのを待ってコマンド列 @var{command}@dots{} を実行します。
既に実行が完了しているときには、コマンド列 @var{command}@dots{} を
依頼を受けた時刻からすぐに実行開始します。
依頼をした方のスレッドは @var{thread-name} スレッドでの実行状況とは
無関係にすぐに次のコマンドの処理に入ります。
従って、スレッド切り替えコマンド直後の @code{t} レジスタの値は、
スレッド切り替えの実行前の値と変わりません。

最後の @samp{+} は @samp{===} コマンドによる子スレッドの
実行終了待ちの
対象から除外したいときに付加します(@pxref{Wait for Child Threads})。

スレッド切り替えコマンドは、複数の楽器パートから構成される音楽の
記述に不可欠です。下にオルガンとベースの２つのパートから
成り立っている曲の記述例を示します。
オルガンパートには @code{organ} という名のスレッド、
ベースパートには @code{bass} という名のスレッドがそれぞれ
割り当てられています。

@example
newtrack(organ) @{ ch=1 @}      // organ スレッドの生成  トラック番号は2
newtrack(bass) @{ ch=2 o=2 @}   // bass スレッドの生成   トラック番号は3

organ @{
  /* (a) */
  h [E Bb ^Eb] i R [E Bb ^Eb] R(q)
  h [Eb A ^D]  i R [Eb A ^D]  R(q)
@}
bass  @{ 
  /* (b) */
  C D E G F ^Eb ^C A 
@}
organ @{
  /* (c) */
  w [E Bb ^Eb]
  q R [E Bb ^Eb] i R [E Bb ^Eb] R(q)
@}
bass  @{
  /* (d) */
  C D E F G A Bb ^C
@}
@end example

@noindent
どちらのスレッドも時刻０の状態から出発するので、
始め (a) と (b) が並行して演奏されます。
@code{organ} スレッドでは (a) の演奏が終ると、(c) の演奏を始めます。
同様に、@code{bass} スレッドでは (b), (d) という順序で演奏が進められます。
各スレッドのレジスタ値は独立していますので、
例えば (c) 部分の先頭では、
(a) 部分の最後でのレジスタ値がそのまま残っています。
このように一つのスレッドの記述をいくつかに分割することによって、
並行して演奏されるフレーズをテキスト上の近い位置に置くことができ、
その結果、それらの関連を見易くすることができます。

上の例は下のように、スコア風に書き直すこともできます。

@example
newtrack(organ) @{ ch=1 @}      // organ スレッドの生成
newtrack(bass) @{ ch=2 o=2 @}   // bass スレッドの生成

organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}

organ @{ w [E Bb ^Eb]                         @}
bass  @{ C     D          E              F    @}

organ @{ q R   [E Bb ^Eb] i R [E Bb ^Eb] R(q) @}
bass  @{ G     A          Bb             ^C   @}
@end example

@node Wait for Child Threads, Deleting Named Threads, Switching Threads, Threads
@subsection 子スレッドの実行終了待ち
@cindex 子スレッドの実行終了待ち

@table @t
@item @r{C:} ===
@end table
@findex ===

@samp{===} コマンドは、すべての子孫スレッドが次の３条件のうちの
いずれかを満たすまで、現スレッドの実行を中断します。

@enumerate
@item
依頼されているコマンド列の実行が全て終了する。

@item
@code{wait} (@pxref{Receiving Messages}) または 
@code{alt} (@pxref{Alternation}) コマンドにおいてメッセージ待ち状態になる。

@item
最後のコマンド列実行依頼を @samp{+} つきの
スレッド切り替えコマンドによって受けている。
@end enumerate

@samp{===} コマンドは複数パートの記述において以下のように利用されます。
例えば前節の例について曲の途中でテンポを変えたい場合を考えます。
テンポの指示は全パートに対しての指示ですから、ルートスレッドにおいて
テンポ指定をするのが妥当と考えられます。これに従って、次のように
テンポ指定を挿入したとします。

@example
tempo(120)
organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

tempo(130)
organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}
@end example

@noindent
しかし上のコードは意図したように動きません。
スレッド切り替えコマンドを実行してもルートスレッドの
時刻は前に進みませんので、@code{tempo(130)} は結局 @code{tempo(120)} と
同じ時刻においてテンポ指定を行うことになってしまいます。
正しいコードは以下の通りです。

@example
tempo(120)
organ @{ h [E Bb ^Eb]     i R [E Bb ^Eb] R(q) @}
bass  @{ C     D          E              G    @}

===
tempo(130)
organ @{ h [Eb A ^D]      i R [Eb A ^D]  R(q) @}
bass  @{ F     ^Eb        ^C             A    @}
@end example

@noindent
このようにテンポ指定をする前に @samp{===} を挿入すれば、
それまでに記述された部分の演奏が終ってから
テンポが変更されることになります。

@samp{===} コマンドはパート間の時刻合わせをする効果もあります。
次の例を見て下さい。

@example
/* (a) */
organ1 @{ q C D E F @}
organ2 @{ q E F @}
bass   @{ w C @}
===
/* (b) */
organ1 @{ G F E D @}
organ2 @{ B A G F @}
===
/* (c) */
organ1 @{ w C @}
organ2 @{ w E @}
bass   @{ w C @}
@end example

@noindent
(b) の部分には @code{bass} スレッドの記述が
ありませんが、これはこの期間 @code{bass} スレッドはずっと休みである
ことを意味します。したがって (c) の部分での @code{bass} スレッドの
C音は @code{organ1} スレッドのC音と同時に発音されます。
もし @samp{===} がなければ、このC音は (b) で演奏されてしまうことでしょう。
また、(a) の部分で @code{organ2} だけが他のスレッドに比べて演奏時間が短く
なっていますが、このようなことも許され、@code{organ2} には２分休符が
自動的に挿入されます。

一部のスレッドに @samp{===} をまたいでタイでつながれている音符が
ある場合には、@samp{+} つきのスレッド切り替えコマンドを使います。
下の例では、もし @samp{+} がなければ @code{organ1} スレッドに
余計な４分休符が挿入されてしまうことになります。

@example
===
/* (b) */
organ1 @{ G F E D @}
organ2 @{ B A G h F @}+
===
/* (c) */
organ1 @{ w C @}
organ2 @{ h. E @}
bass   @{ w C @}
@end example

@node Deleting Named Threads,  , Wait for Child Threads, Threads
@subsection 名前つきスレッドの消去
@cindex スレッドの消去
@cindex 名前つきスレッドの消去

スレッドによって使われている識別子やメモリ資源を解放する
必要があるときには、

@table @t
@item @r{C:} undef(@r{[}@var{thread-path}@r{]}@var{thread-name})
@end table
@findex undef

@noindent
によってスレッドを消去することができます。
@var{thread-name} は消去するスレッドの名前、
@var{thread-path} はそれに対するパスの指定です。

@code{undef} を実行すると、指定したスレッドのスレッド名、及び
そのすべての子孫スレッドのスレッド名は即座に解放されます。
しかし、スレッドが実際に消去されるのは、すぐにとは限りません。
@code{undef} の役割は、指定したスレッド及びその子孫スレッドに
消去のマークを付けるだけです。マークを付けられた各スレッドは
自分の子スレッドがすべて消滅し、かつ
自分のスレッドに依頼されているコマンドの実行がすべて
完了したときに実際に消去されます。

スレッドが実際に消去されると、
そのスレッドに属するマクロ（スレッドマクロ）はすべて消去され、
またそのスレッド内でアタッチされた
エフェクタは全てディタッチされます。

@node Modifiers, No Operation, Threads, Basic Commands
@section 修飾子
@cindex 修飾子
@cindex アクセント
@cindex 時刻シフト
@cindex 名前なしスレッド
@cindex 局所的なレジスタの変更
@cindex 一般修飾子
@cindex 従属イベント

修飾子はコマンドではなく、
イベント生成コマンドまたは和音コマンドの一部です。
修飾子は１つのコマンドについてだけレジスタの内容を
一時的に変更する場合や、１つの音符と緊密に関連するイベント（アフタータッチや
ピッチベンドなど）を生成する場合に使われます。

イベント生成コマンドに修飾子が付けられた場合、
そのコマンドのためだけの新しい名前なしスレッドが生成され、
修飾子の評価とイベント生成コマンドの実行はそのスレッドにおいて行われます。
その後、そのスレッドはすぐに消滅します。
このため、修飾子によるレジスタ変更は修飾されるコマンドに
対してだけ有効であり、後続のコマンドへは影響を与えません。

グルーピングコマンドまたは和音コマンドに修飾子が付けられた場合、
修飾子の評価はそれらのコマンドによって生成されたスレッドにおいて
行われます（イベント生成コマンドの場合とは異なり、
修飾子を付けることによって更に新たなスレッドが生成されることはありません）。
このとき、修飾子の評価は中括弧（あるいは角括弧）内のコマンドを
実行するのに先だって行われます。

修飾子には次の３種類があります。１つのコマンドには任意個の
修飾子をつけることができます。

@table @code
@item @var{accent}
@code{v} レジスタに
アクセント記号 @var{accent} によって示されるベロシティー増減値を
一時的に加算します。
例えば @samp{C D++ E} のような場合、D音のベロシティー
だけが @code{ac} レジスタの分だけ増やされます。

@item @var{time-shifter}
@code{dt} レジスタに
時刻シフト記号 @var{time-shifter} によって示される時刻の増減値を
一時的に加算します。
例えば @samp{C D>> E} のような場合、D音のノートオンとノートオフ両方の
時刻が @code{sh} レジスタの分だけ遅らされます。

@item ( @var{commands} @r{@dots{}} )
これは一般修飾子と呼ばれます。新しく生成されたスレッドにおいて、
修飾されるコマンドの実行に先だって
任意のコマンド列 @var{commands}@dots{} を実行し、
それから修飾されるコマンドを実行します。
最も頻繁に利用される一般修飾子は、音価（ステップタイム）を
一時的に変更するものです。
例えば、

@example
i C D E(q) F r(q) G
@end example

@noindent
では、E音と休符の長さだけが４分音符になり他の音符は８分音符のままに
なります。
他によく利用される例としては、

@example
C D(dr=80) E
@end example

@noindent
のように、音符の持続時間を一時的に変更する
ものがあります。この場合、D音だけについて持続時間が
音価の 80% に設定されます。

括弧内のコマンドはそれが更にイベント生成コマンドでもよく、
これを利用すると１つの音符に従属するイベント（アフタータッチや
ピッチベンドなど）をわかりやすく表現できます。例えば、

@example
C4(kp(40))
@end example

@noindent
では、ノートオンと同一時刻にキープレッシャーのイベントが生成されます。
修飾子内のコマンドを実行するとき、既に @code{n} レジスタの値は音高定数の
値になっていますし、また @code{kp} コマンドは @code{n} レジスタより
MIDIノート番号を取得しますので、キープレッシャーイベント
のMIDIノート番号は C4 と同じになります。

一般修飾子では、開き括弧の直後に @samp{tb=t}、閉じ括弧の直前に @samp{t=tb} が
自動的に挿入されます。このため、修飾子内で @samp{rt=@var{expr}} と
することによってノートオン時刻を基準とした相対的な時刻指定ができます。
例えば、次のようにして従属するイベントの時刻を指定できます。

@example
C(kp(40) rt=30u kp=(50) rt=60u kp(60))
C(bend(-200) rt=s bend_to(0))
@end example

@noindent
なお、この相対時刻指定の機能のために、
一般修飾子の中で @code{t} レジスタを変更しても無効になります。
例えば、音符の時刻をずらすために @samp{C(t+=10u)} のような書き方は
できません。代わりに @samp{C(dt+=10u)} を使って下さい。
@end table

@node No Operation,  , Modifiers, Basic Commands
@section 何もしないコマンド
@cindex 何もしないコマンド

@table @t
@item @r{C:} ;
@end table
@findex ;

セミコロンは何もしないコマンドとして認識されます。
ソーステキストの可読性を高めるために、
小節の区切りなどに自由に挿入することができます。
また、C言語との類似性を保つために、コマンドの
末尾に付加することもできますが、式の中から呼ばれる可能性のある
マクロ定義の中で使用することはできませんので注意して下さい。

@c --------------------------------------------------------------------
@node Event Generating Commands, Macros, Basic Commands, Top
@chapter イベント生成コマンド

@menu
* Note Events::                 ノートオン、ノートオフの単独生成 
* Virtual Control Change::      仮想と拡張コントロールチェンジとは？ 
* Velocity Magnifier::          ベロシティー拡大率について 
* Control-Change Events::       コントロールチェンジ、プログラムチェンジ、
                                ピッチベンド、アフタータッチ、テンポ変更など
* Continuous Control Change::   連続的にコントロール値を変化させる方法  
* Exclusive Events::            エクスクルーシブと任意メッセージ 
* Meta Events::                 メタイベントの生成法。拍子設定、調の設定、
                                マーカーの挿入、曲名タイトルの挿入を含む。
@end menu

@node Note Events, Virtual Control Change, Event Generating Commands, Event Generating Commands
@section ノートイベントの生成
@cindex ノートイベントの生成
@cindex ノートオンの単独生成
@cindex ノートオフの単独生成

ノートオンまたはノートオフのイベントを生成するコマンドには
以下のものがあります。

@table @t
@item @r{C:} @var{pitch-constant} @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
@itemx @r{C:} note @r{[}@var{modifiers}@r{]} @r{[}&@r{]}
これらについては @ref{Note Command} を参照して下さい。

@item @r{C:} note_on(@var{note-num} @r{[}, @var{velocity} @r{[}, @var{channel}@r{]]}) @r{[}@var{modifiers}@r{]}
@findex note_on
ノートオンイベントを生成します。イベント
時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @var{channel}、
MIDIノート番号は @var{note-num}, 
ベロシティーは @var{velocity} になります。
@var{velocity} が省略された時のベロシティーは @code{v} レジスタの
値になります。@var{channel} が省略された時のチャネル番号は @code{ch} レジスタ
の値になります。 

@item @r{C:} note_off(@var{note-num} @r{[}, @var{velocity} @r{[}, @var{channel}@r{]]}) @r{[}@var{modifiers}@r{]}
@findex note_off
ノートオフイベントを生成します。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @var{channel}、
MIDIノート番号は @var{note-num}, 
ノートオフベロシティーは @var{velocity} になります。
@var{velocity} が省略された時のノートオフベロシティーは @code{nv} レジスタの
値になります。ノートオフベロシティーが負の場合は、
ノートオフメッセージの代わりにベロシティーが０のノートオンメッセージが
生成されるようになります（通常これはMIDIトラフィックを減少させる
効果があります）。
@var{channel} が省略された時のチャネル番号は @code{ch} レジスタ
の値になります。 
@end table

@noindent
@var{modifiers} については @ref{Modifiers} を見て下さい。

@node Virtual Control Change, Velocity Magnifier, Note Events, Event Generating Commands
@section 仮想と拡張コントロールチェンジ
@cindex 仮想コントロールチェンジ
@cindex 仮想コントローラ
@cindex 拡張コントロールチェンジ
@cindex 拡張コントローラ番号

MIDIにおけるコントロールチェンジの
コントローラ番号は 0 から 127 までと定められていますが、
PMMLではそれが 255 までに拡張されています。
コントローラ番号が 128 以上のコントローラは @dfn{仮想コントローラ} と
呼ばれ、それに対するコントロールチェンジは @dfn{仮想コントロールチェンジ} と
呼ばれます。
また、(実)コントロールチェンジと仮想コントロールチェンジを
合わせて @dfn{拡張コントロールチェンジ} と呼び、
そのコントローラ番号 (つまり 0 から 255 まで) を @dfn{拡張コントローラ番号} と
呼びます。

一部の仮想コントローラはピッチベンドやテンポ指定などの機能が
システムによって予め割り付けられています。
それ以外の仮想コントローラは、
エフェクタ(@pxref{Virtual Controllers and Effectors})を
利用することによって、ユーザがその意味を自由に定義できます。
例えば、ある仮想コントローラをエクスクルーシブメッセージを
用いたマスタボリュームとして定義するようなことが可能です。

仮想コントローラ番号は、
192未満が各MIDIチャネル毎に独立したコントロール、
192以上が全チャネルに対するコントロールと決められています。
192番以上の仮想コントロールチェンジのイベントは、
出力ファイルのフォーマットが０または１の場合、
@code{tk} レジスタの値によらず常にトラック１へ置かれます。
また、連続コントロールチェンジにおいて
同じ折れ線や曲線に属するイベントを見つける際に、
MIDIチャネル番号を無視して
比較が行われます(@pxref{Continuous Control Change})。

システムによって予約されている
仮想コントローラ番号とその意味は以下の通りです。

@table @asis
@item 128
ピッチベンド
@item 129
キープレッシャー
@item 130
チャネルプレッシャー
@item 131
プログラムチェンジ
@item 132
ベロシティ拡大率(@pxref{Velocity Magnifier})
@item 192
テンポ設定
@item 193
相対テンポ設定(@pxref{Control-Change Events})
@end table

@noindent
例えば、@code{ctrl(128, 200)} というコマンドによって 
128 番の仮想コントローラに対して 200 というコントロール値を出力すると、
これはベンド値 200 のピッチベンドを出力するのと同じ意味になります。
つまり、@code{ctrl(128, 200)} は @code{bend(200)} と全く等価です。
PMMLコンパイラ内部では、ピッチベンドのイベントを
128 番の拡張コントロールチェンジイベントとして扱っています。
これは、テンポ設定を含む上に掲げた他の種類のイベントに対しても同様です。

ユーザが新たな仮想コントローラを定義する時、他の仮想コントローラと
かち合わないように番号を割り当てなくてはなりません。次の示す
２種類の標準マクロはこれを容易に行うためのものです。

@table @t
@item @r{SM:} new_vctrl
@findex new_vctrl
MIDIチャネル毎に独立したコントローラのための
新しい仮想コントローラ番号を与えます。
最初に @code{new_vctrl} を呼び出したときは 133 に置き換わり、
以後呼び出すごとに１ずつ増えた値が得られます。

@item @r{SM:} new_gctrl
@findex new_gctrl
全MIDIチャネルに対するコントローラのための
新しい仮想コントローラ番号を与えます。
最初に @code{new_vctrl} を呼び出したときは 194 に置き換わり、
以後呼び出すごとに１ずつ増えた値が得られます。
@end table

また、下の標準マクロは、ある拡張コントローラに対して、
それを操作する一連のマクロを定義するためのものです。

@table @t
@item @r{SM:} defctrl(@var{cntl-name}, @var{cap-ctrl-name}, @var{ctrl-num}, @var{tstep}, @var{threshold})
@findex defctrl
@var{ctrl-name} はコントローラの名前を表した文字列、
@var{cap-ctrl-name} はコントローラ番号を定義する変数型マクロ名を
表した文字列（通常は @var{ctrl-name} の先頭を大文字にしたもの）、
@var{ctrl-num} はコントローラ番号、
@var{tstep} と @var{threshold} は連続コントロールチェンジにおける
時間刻み幅と閾値です。
@code{defctrl} によって次の７つのマクロが定義されます。

@display
  @var{ctrl-name}, @var{ctrl-name}@t{_to}, @var{ctrl-name}@t{_pt}, @var{ctrl-name}@t{_cto}, 
  @var{cap-ctrl-name}, @var{cap-ctrl-name}@t{Step}, @var{cap-ctrl-name}@t{Threshold}
@end display

@noindent
例えば、

@example
defctrl("chorus", "Chorus", 93, 15u, 1)
@end example

@noindent
は、

@example
def(chorus, "n") @{ ctrl(93, $1) @}
def(chorus_to, "n") @{ ctrl_to(93, $1, ChorusStep, ChorusThreshold) @}
def(chorus_pt, "n") @{ ctrl_pt(93, $1) @}
def(chorus_cto, "n:nn") @{ 
  ctrl_cto(93, $1, ChorusStep, ChorusThreshold,
           null($2) ? 0 : @{$2@}, null($3) ? 0 : @{$3@})
@}
Chorus = 93
ChorusStep = 15u
ChorusThreshold = 1
@end example

@noindent
とすることと等価です。
@end table

@node Velocity Magnifier, Control-Change Events, Virtual Control Change, Event Generating Commands
@section ベロシティー拡大率
@cindex ベロシティー拡大率
@cindex ベロシティーの連続的変化

PMMLはベロシティーを用いてクレッシェンド／デクレッシェンドを実現するために、
ベロシティーマグニファイアという特別な仮想コントローラを持っています。
ベロシティーマグニファイアのコントロール値はベロシティー拡大率と呼ばれます。

通常は音符コマンドを実行したときの @code{v} レジスタの値が
そのまま出力MIDIファイル中のベロシティーになりますが、
ベロシティー拡大率に 1.0 以外の値をセットすると、
出力処理 (@pxref{Output Process}) の過程で
その値がベロシティーに乗ぜられます。
ベロシティー拡大率は連続的に変化させることができますから、
これを利用してベロシティーを徐々に増減することができます。
なお、ベロシティー拡大率は各MIDIチャネルごと独立に指定可能です。

@subsubheading ベロシティー拡大率の利用例

@example
v=50
vmag(1.0)      // ctrl(132, 1.0) でも同じ
q C D E F
vmag_to(1.6)   // ctrl_to(132, 1.6) でも同じ
G
@end example

@noindent
この例での各音のベロシティーは次のようになります。

@example
C: v=50
D: v=58
E: v=65
F: v=72
G: v=80
@end example

@node Control-Change Events, Continuous Control Change, Velocity Magnifier, Event Generating Commands
@section コントロール系イベントの生成

コントロールチェンジ、ピッチベンド、テンポ設定など
拡張コントロールチェンジのイベントを生成するコマンドおよび
標準マクロとしては以下のものが用意されています。

@table @t
@item @r{C:} ctrl(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl
@cindex コントロールチェンジ
拡張コントロールチェンジイベントを生成します。
イベント時刻は (@code{t} + @code{dt})、MIDIチャネル番号は @code{ch}、
拡張コントローラ番号は @var{ctrl-num}、
コントロール値は @var{value} になります。
@var{ctrl-num} が 129、すなわちキープレッシャーにあたる拡張コントロール
チェンジのとき、MIDIノート番号は @code{n} になります。 
@var{ctrl-num} は 0 から 255 の範囲でなければなりません。
コントロール値 @var{value} は任意のデータ型をとることができますが、
適当なデータ型でない場合は出力処理 (@pxref{Output Process}) の過程で
エラーになります。

@var{ctrl-num} が 192 未満の場合、
拡張コントロールチェンジイベントは @code{tk} レジスタの値で
示されるトラックに置かれます。
@var{ctrl-num} が 192 以上の場合、
置かれるトラックは出力MIDIファイルのフォーマットに依存します。
format 0または1である場合、
@code{tk} レジスタの値にかかわらず必ずトラック１に置かれます。
出力MIDIファイルがformat 2の場合は、@code{tk} レジスタの値で
示されるトラックに置かれます。

@item @r{C:} bend(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend
@cindex ピッチベンド
@cindex ピッチホイールチェンジ
ピッチベンドイベント（すなわち 128 番の拡張コントロールチェンジイベント）
を生成します。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch}、ベンド値は @var{value} になります。
ベンド値の範囲は @minus{}8192 から 8191 であり、
0 が中央(ピッチ変更なし)を表します。

@item @r{C:} kp(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex kp
@cindex キープレッシャー
@cindex キーアフタータッチ
@cindex アフタータッチ
ポリフォニックキープレッシャー（キーアフタータッチ）の
イベント（すなわち 129 番の拡張コントロールチェンジイベント）
を生成します。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch}、
MIDIノート番号は @code{n}、
プレッシャー値は @var{value} になります。
プレッシャー値の範囲は 0 から 127 です。

@item @r{C:} cpr(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex cpr 
@cindex チャネルプレッシャー
@cindex チャネルアフタータッチ
@cindex アフタータッチ
チャネルプレッシャー（チャネルアフタータッチ）の
イベント（すなわち 130 番の拡張コントロールチェンジイベント）
を生成します。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch}、プレッシャー値は @var{value} になります。
プレッシャー値の範囲は 0 から 127 です。

@ifset html
<A NAME="PROG"></A>
@end ifset
@item @r{C:} prog(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex prog
@cindex 音色の変更
@cindex プログラムチェンジ
プログラムチェンジイベント（すなわち 131 番の拡張コントロールチェンジイベント）
を生成します。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch}、プログラム番号は @var{value} になります。
プログラム番号の範囲は 1 から 128 です。

@item @r{SM:} vmag(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex vmag
@cindex ベロシティー拡大率
ベロシティー拡大率変更イベント（すなわち 132 番の
拡張コントロールチェンジイベント）を生成します(@pxref{Velocity Magnifier})。
イベント時刻は (@code{t} + @code{dt})、トラック番号は @code{tk}、
MIDIチャネル番号は @code{ch}、ベロシティー拡大率は @var{value} になります。

@ifset html
<A NAME="TEMPO"></A>
@end ifset
@item @r{C:} tempo(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex tempo
@cindex テンポの設定
テンポ設定イベント（すなわち 192 番の拡張コントロールチェンジイベント）
を生成します。
イベント時刻は (@code{t} + @code{dt})、テンポ値は @var{value} になります。
テンポ値は、１分間当たりの４分音符数で指定し、小数点以下を
指定することもできます。

出力MIDIファイルがformat 0または1である場合、
テンポ設定イベントは
@code{tk} レジスタの値にかかわらず必ずトラック１に置かれます。
出力MIDIファイルがformat 2の場合は、@code{tk} レジスタの値で
示されるトラックに置かれます。

時刻 0 においてテンポ設定イベントが存在しない場合には、
自動的に @code{tempo(120)} が挿入されます。

@item @r{SM:} rtempo(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex rtempo
@cindex 相対テンポの設定
（時刻順に考えて）直前の @code{tempo} コマンドによる
テンポ設定値に @var{value} を乗じた値へテンポが変更されるように、
相対テンポ設定イベント（すなわち 193 番の拡張コントロールチェンジイベント）
を時刻 (@code{t} + @code{dt}) に生成します。

@item @r{SM:} mod(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex mod
@cindex モジュレーションホイール
モジュレーションホイール値を設定するイベントを生成します。
@code{ctrl(1, @var{value})} と等価です。

@item @r{SM:} breath(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex breath
@cindex ブレスコントローラ
ブレスコントローラ値を設定するイベントを生成します。
@code{ctrl(2, @var{value})} と等価です。

@item @r{SM:} foot(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex foot
@cindex フットコントローラ
フットコントローラ値を設定するイベントを生成します。
@code{ctrl(4, @var{value})} と等価です。

@item @r{SM:} pmtime(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex pmtime
@cindex ポルタメントタイム
ポルタメントタイムを設定するイベントを生成します。
@code{ctrl(5, @var{value})} と等価です。

@ifset html
<A NAME="VOL"></A>
@end ifset
@item @r{SM:} vol(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex vol
@cindex ボリューム
ボリューム値を設定するイベントを生成します。
@code{ctrl(7, @var{value})} と等価です。

@item @r{SM:} pan(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex pan
@cindex パンポット
パンポット値を設定するイベントを生成します。
@code{ctrl(10, @var{value})} と等価です。

@item @r{SM:} expr(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex expr
@cindex エクスプレッション
エクスプレッション値を設定するイベントを生成します。
@code{ctrl(11, @var{value})} と等価です。

@item @r{SM:} ped @r{[}@var{modifiers}@r{]} 
@findex ped
@cindex ダンパーペダル
ダンパーペダルを踏むイベントを生成します。
@code{ctrl(64, 127)} と等価です。

@item @r{SM:} pedoff @r{[}@var{modifiers}@r{]} 
@findex pedoff
@cindex ダンパーペダル
ダンパーペダルを離すイベントを生成します。
@code{ctrl(64, 0)} と等価です。

@item @r{SM:} pm @r{[}@var{modifiers}@r{]} 
@findex pm
@cindex ポルタメント
ポルタメントを ON にするイベントを生成します。
@code{ctrl(65, 127)} と等価です。

@item @r{SM:} pmoff @r{[}@var{modifiers}@r{]} 
@findex pmoff
@cindex ポルタメント
ポルタメントを OFF にするイベントを生成します。
@code{ctrl(65, 0)} と等価です。

@item @r{SM:} sped @r{[}@var{modifiers}@r{]} 
@findex sped
@cindex ソフトペダル
ソフトペダルを踏むイベントを生成します。
@code{ctrl(67, 127)} と等価です。

@item @r{SM:} spedoff @r{[}@var{modifiers}@r{]} 
@findex spedoff
@cindex ソフトペダル
ソフトペダルを離すイベントを生成します。
@code{ctrl(67, 0)} と等価です。

@item @r{SM:} all_notes_off @r{[}@var{modifiers}@r{]} 
@findex all_notes_off
@cindex オールノートオフ
オールノートオフのイベントを生成します。
@code{ctrl(123, 0)} と等価です。

@item @r{SM:} rpc(@var{rpn}, @var{byte})
@findex rpc
@cindex RPC
@cindex RPN
MSB（上位バイト）だけからなる RPC（レジスタード・パラメタ・コントロール）の
ためのコントロールチェンジイベントの列を生成します。
100, 101番のコントローラを使ってパラメタ番号 @var{rpn} をセットしたあとに、
6番のコントローラ（データエントリMSB）を使って
整数 @var{byte} の下位 7 ビットを出力します。
パラメタ番号 @var{rpn} は16ビットの整数で指定して下さい。
例えば、MSB が 0x01、LSB が 0x08である場合には 0x0108 を引数に与えます。

@item @r{SM:} rpcw(@var{rpn}, @var{word})
@findex rpcw
MSB と LSB 両方からなる RPC の
ためのコントロールチェンジイベントの列を生成します。
100, 101番のコントローラを使ってパラメタ番号 @var{rpn} をセットしたあとに、
6, 38番のコントローラ（データエントリMSB, LSB）を使って
整数 @var{word} の下位 14 ビットを出力します。
パラメタ番号の指定法は上の @code{rpc} マクロと同じです。

@item @r{SM:} nrpc(@var{nrpn}, @var{byte})
@findex nrpc
@cindex NRPC
@cindex NRPN
MSB（上位バイト）だけから
なる NRPC（ノン・レジスタード・パラメタ・コントロール）の
ためのコントロールチェンジイベントの列を生成します。
98, 99番のコントローラを使ってパラメタ番号 @var{nrpn} をセットしたあとに、
6番のコントローラ（データエントリMSB）を使って
@var{byte} の下位 7 ビットを出力します。
パラメタ番号の指定法は上の @code{rpc} マクロと同じです。

@item @r{SM:} nrpcw(@var{nrpn}, @var{word})
@findex nrpcw
MSB と LSB 両方からなる NRPC の
ためのコントロールチェンジイベントの列を生成します。
98, 99番のコントローラを使ってパラメタ番号 @var{nrpn} をセットしたあとに、
6, 38番のコントローラ（データエントリMSB, LSB）を使って
@var{word} の下位 14 ビットを出力します。
パラメタ番号の指定法は上の @code{rpc} マクロと同じです。

@item @r{SM:} bender_range(@var{byte})
@cindex ベンダーレンジ
@cindex ピッチベンドセンシティビティ
RPC を使ってベンダーレンジ（ピッチベンドセンシティビティ）を設定します。
@var{byte} は 0 から 127 までの整数です。

@item @r{SM:} fine_tune(@var{word})
@cindex ファインチューニング
RPC を使ってファインチューニングを設定します。
@var{word} は @minus{}8192 から 8191 までの整数です。

@item @r{SM:} coarse_tune(@var{byte})
@cindex コースチューニング
RPC を使ってコースチューニングを設定します。
@var{byte} は @minus{}64 から 63 までの整数です。
@end table

@findex LASTVAL
上の各コマンドのコントロール値 @var{value} として @code{LASTVAL}
（これは 0x80000000 に定義されている標準マクロです）
を与えると、直前のコントロール値と同じという意味になります。
直前のコントロール値とは、時刻順に考えて１つ前の、
同じ拡張コントローラ番号、そして
拡張コントローラ番号が191以下の場合は同じトラック番号とMIDIチャネル番号、
キープレッシャーの場合は更に同じMIDIノート番号を持つ
拡張コントロールチェンジまたは連続コントロールチェンジイベントの
コントロール値のことです。
@code{LASTVAL} は、前と同じ値から連続コントロールチェンジを開始する
場合に使用します。

各コマンドの @var{modifiers} については @ref{Modifiers} を見て下さい。

@ifset html
<A NAME="CCONT"></A>
@end ifset
@node Continuous Control Change, Exclusive Events, Control-Change Events, Event Generating Commands
@section 連続コントロールチェンジ
@cindex 連続コントロールチェンジ

例えばボリュームコントロール（７番のコントロールチェンジ）を使った
クレッシェンドのように、
コントロール値が少しずつ変化させることが必要な場合、
MIDIでは多数のコントロールチェンジメッセージを
小刻みに出力しなくてはなりません。
PMMLは、@dfn{連続コントロールチェンジ} と呼ばれる、
これを自動的に行う機能を持っています。

変化の形状として、折れ線に沿ったものと、自由曲線に沿ったものの２種類が
用意されています。
どちらの場合も、始点、０個以上の中間点、及び終点を各点ずつ１つの
コマンドによって指定します。
始点については、
通常のコントロールチェンジコマンドである @code{ctrl} で指定するか、
あるいはそれが無ければ１つ前の折れ線／自由曲線の終点が始点だと
見なされます。
中間点は @code{ctrl_pt} コマンドで指定します。
終点は、折れ線の場合 @code{ctrl_to}、自由曲線の場合 @code{ctrl_cto} コマンド
によって指定します。例えば、次のように記述します。

@example
ctrl(7,0)              // 始点でのボリューム値を 0 とする。
q C D
ctrl_to(7,80,15u,1)    // C, D音の区間に合わせて、0 から 80 まで直線的に
                       // ボリュームを変化させる。
E F
ctrl_to(7,60,15u,1)    // E, F音の区間に合わせて、80 から 60 まで直線的に
                       // ボリュームを変化させる。
ctrl(7,30)             // 60 から 30 へボリュームを急に変更する。
G A B 
ctrl_pt(7,100)         // 自由曲線の中間点を 100 に指定する。
^C
ctrl_cto(7,120)        // 30 から 100 を通って 120 に達するなめらか曲線に
                       // に沿ってボリュームを変化させる。
@end example

@noindent
前半部分では２つの直線に分けて記述していますが、これを１つの折れ線と
見なして、

@example
ctrl(7,0)
q C D
ctrl_pt(7,80)          // 折れ線の中間点を 80 とする。
E F
ctrl_to(7,60,15u,1)
@end example

@noindent
と書いても結果は同じになります。自由曲線の場合は、中間点のところで分割
すると、そこで傾きが不連続になるため、結果が違ってしまいます。

中間点や終点のコマンドは、直接個々のコントロールチェンジイベントを
生成することはしません。
代わりに、中間点には中間点イベント、終点には終点イベントと呼ばれる
単一のイベントを生成します。
中間点イベントと終点イベントを合わせて
連続コントロールチェンジイベントと言います。
個々のコントロールチェンジへの展開は、
出力処理(@pxref{Output Process})あるいは
@code{ExpandCtrl} フラグの指定された
エフェクタのディタッチ(@pxref{Defining Effectors})
の過程において、
すべてのイベントを時刻順にソートした後になってからまとめて行われます。

ある終点イベントはイベント時刻の順序で考えて直前の
始点や中間点のイベントと対応します。
ソーステキスト上の位置は重要ではありません。
対応づけにおいて、同じ折れ線や曲線に属するイベントだと見なされるのは、
次のような条件が満たされたときです。
まず、トラック番号と拡張コントローラ番号が同じである必要があります。
拡張コントローラ番号が191以下の場合はMIDIチャネル番号も同じで
なければなりません。更にキープレッシャーの場合は
MIDIノート番号も同じでなければなりません。
これらの条件が満たされない場合は、
別の折れ線／自由曲線に属する点だと見なされます。
このため、
下の例のようにいくつかのコントローラに対する連続コントロールチェンジを
同時に並行して行う場合も、問題なく処理されます。

@example
ctrl(7,0) ctrl(1,100)
q C D
ctrl_to(7,40,15u,1) ctrl_to(1,0,15u,1)
@end example

以下に各コマンドについての説明を示します。

@table @t
@item @r{C:} ctrl_to(@var{ctrl-num}, @var{value}, @var{tstep}, @var{threshold}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_to
@cindex 直線に沿ったコントロールチェンジ
@cindex 折れ線に沿ったコントロールチェンジ
@cindex 時刻刻み幅
@cindex 閾値
折れ線に沿ったコントロールチェンジを行うための終点イベントを生成します。
対応する中間点がなければ始点と終点を結んだ直線に
沿った連続コントロールチェンジになり、
中間点があれば始点とそれら、そして終点を順に結んだ折れ線に沿う
連続コントロールチェンジになります。

終点イベントの時刻は (@code{t} + @code{dt})、
MIDIチャネル番号は @code{ch}、
拡張コントローラ番号は @var{ctrl-num}、
コントロール値は @var{value} になります。
トラック番号は @code{ctrl} コマンドと同じ規則によって決定されます。
@var{ctrl-num} が 129、すなわちキープレッシャーにあたる拡張コントロール
チェンジのとき、MIDIノート番号は @code{n} になります。 
拡張コントローラ番号 @var{ctrl-num} は 0 から 255 の間である
必要があります。

時間刻み幅 @var{tstep} と 閾値 @var{threshold} は 
個々のコントロールチェンジイベントへ展開するときの細かさを決定します。
@var{tstep} は隣り合うイベントの時間の最小間隔、
@var{threshold} は隣り合うイベントのコントロール値の
最小間隔を意味しています@footnote{
ただし、直線の開始点と終点との時間差が @var{tstep} の倍数になって
いない場合には、最初の２つのイベントにおける時間間隔
およびコントロール値間隔が指定した最小間隔より小さくなることがあります。}。
@var{tstep} は正の有理数、@var{threshold} は 0 以上の数でなければ
なりません。
PMMLインタンプリタは、まず @var{tstep} で指定される一定の時間間隔の
イベント列を想定し、そこから隣り合うイベントでの
コントロール値の変化が @var{threshold} 未満であるようなイベントを取り除き、
それを最終的なイベント列とします。
@var{threshold} に 0 を指定すれば、
常に一定の時間間隔でイベント列が生成されることになります。

@item @r{C:} ctrl_pt(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_pt
折れ線または自由曲線に沿った連続コントロールチェンジのための
中間点イベントを生成します。
イベント時刻は (@code{t} + @code{dt})、
MIDIチャネル番号は @code{ch}、
拡張コントローラ番号は @var{ctrl-num}、
コントロール値は @var{value} になります。
トラック番号は @code{ctrl} コマンドと同じ規則によって決定されます。
@var{ctrl-num} が 129、すなわちキープレッシャーにあたる拡張コントロール
チェンジのとき、MIDIノート番号は @code{n} になります。 
拡張コントローラ番号 @var{ctrl-num} は 0 から 255 の間である
必要があります。

@item @r{C:} ctrl_cto(@var{ctrl-num}, @var{value}, @var{tstep}, @var{threshold} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_cto
@cindex 曲線に沿ったコントロールチェンジ
@cindex 自由曲線に沿ったコントロールチェンジ
@cindex 三次曲線
@cindex 二次曲線
@cindex 正弦曲線
@cindex 指数的な曲線 
@cindex 対数的な曲線 
自由曲線に沿ったコントロールチェンジを行うための終点イベントを生成します。
それによって、
始点を出発しすべての中間点を順に通って終点に達するような滑らかな
曲線が想定され、それに沿ってコントロールチェンジイベントの列が生成されます。
生成される曲線は区間ごとに定義された３次曲線であり、
各中間点では１次導関数（つまり傾き）の連続性が保証されています。

終点イベントの時刻は (@code{t} + @code{dt})、
MIDIチャネル番号は @code{ch}、
拡張コントローラ番号は @var{ctrl-num}、
コントロール値は @var{value} になります。
トラック番号は @code{ctrl} コマンドと同じ規則によって決定されます。
@var{ctrl-num} が 129、すなわちキープレッシャーにあたる拡張コントロール
チェンジのとき、MIDIノート番号は @code{n} になります。 
拡張コントローラ番号 @var{ctrl-num} は 0 から 255 の間である
必要があります。

時間刻み幅 @var{tstep} と 閾値 @var{threshold} については
上記の @code{ctrl_to} の項を参照して下さい。

初期傾き @var{slope1} と 最終傾き @var{slope2} は、始点及び終点での傾きを、
始点と終点を結んだ直線の傾きに対する倍数（浮動小数点数でもよい）で指定します。
省略した場合には 0（つまり水平）と見なされます。
これらの値次第では、
中間点を使わなくても指数的または対数的な曲線を得ることができます。
@var{slope1}=0 @var{slope2}=2 で中間点の無い場合は、
指数的な格好の２次曲線になります。
@var{slope1}=0 @var{slope2}=3 の場合は、
より曲率の高い指数的な格好の３次曲線になります。
@var{slope1}=0 @var{slope2}>3 とすると、
さらに曲率は高くなりますが、オーバーシュートが発生してしまいます。
これらとは逆に、
@var{slope1}=2 @var{slope2}=0 の場合は対数的な格好の２次曲線、
@var{slope1}=3 @var{slope2}=0 の場合は
より曲率の高い対数的な格好の３次曲線になります。
@var{slope1}=0 @var{slope2}=0 の場合は、@minus{}90 から 90度の区間の
正弦曲線にほぼ近い曲線になります。

@item @r{SM:} bend_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_to(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend_to
@findex kp_to
@findex cpr_to
@findex vmag_to
@findex tempo_to
@findex rtempo_to
@findex mod_to
@findex breath_to
@findex foot_to
@findex pmtime_to
@findex vol_to
@findex pan_to
@findex expr_to
これらは各コントロールごとに定義された
これらは各コントロールごとに定義された
折れ線に沿ったコントロールチェンジを行うため標準マクロです。
いずれの標準マクロも @code{ctrl_to} コマンドに置き換えられます。
各コントローラの意味については @ref{Control-Change Events} を見て下さい。
時間刻み幅や閾値を与えるための引数がありませんが、
これらの値はコントローラ番号毎に定められている標準値が使用されます。
時間刻み幅の標準値は @code{XxxStep}、
閾値の標準値は @code{XxxThreshold}、
（@code{Xxx} は上の標準マクロ名の @samp{_to} を取って最初を大文字にしたもの）と
いう変数型マクロに記録されています。
初期状態では @code{XxxStep} はどのコントローラに対しても @samp{15u}、
@code{XxxThreshold} は VmagThreshold と RTempoThreshold に限り 0.01, 
それ以外のコントローラに対しては 1 に設定されています。
ユーザはこれらの変数型マクロを他の値に変更することができます。

@item @r{SM:} bend_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_pt(@var{value}) @r{[}@var{modifiers}@r{]} 
@findex bend_pt
@findex kp_pt
@findex cpr_pt
@findex vmag_pt
@findex tempo_pt
@findex rtempo_pt
@findex mod_pt
@findex breath_pt
@findex foot_pt
@findex pmtime_pt
@findex vol_pt
@findex pan_pt
@findex expr_pt
これらは各コントロールごとに定義された
中間点イベントを生成するための標準マクロです。
いずれの標準マクロも @code{ctrl_pt} コマンドに置き換えられます。
各コントローラの意味については @ref{Control-Change Events} を見て下さい。

@item @r{SM:} bend_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} kp_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} cpr_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vmag_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} tempo_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} rtempo_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} mod_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} breath_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} foot_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pmtime_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} vol_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} pan_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@itemx @r{SM:} expr_cto(@var{value} @r{[}, @var{slope1} @r{[}, @var{slope2}@r{]]}) @r{[}@var{modifiers}@r{]} 
@findex bend_cto
@findex kp_cto
@findex cpr_cto
@findex vmag_cto
@findex tempo_cto
@findex rtempo_cto
@findex mod_cto
@findex breath_cto
@findex foot_cto
@findex pmtime_cto
@findex vol_cto
@findex pan_cto
@findex expr_cto
これらは各コントロールごとに定義された
これらは各コントロールごとに定義された
自由曲線に沿ったコントロールチェンジを行うため標準マクロです。
いずれの標準マクロも @code{ctrl_cto} コマンドに置き換えられます。
各コントローラの意味については @ref{Control-Change Events} を見て下さい。
時間刻み幅や閾値については上記の @code{bend_to} の項を参照して下さい。
@end table

@noindent
各コマンドの @var{value} には、@code{LASTVAL} を使用することも
できます。@code{LASTVAL} については @ref{Control-Change Events} を
御覧下さい。
また、各コマンドの @var{modifiers} については @ref{Modifiers} を
参照して下さい。

@node Exclusive Events, Meta Events, Continuous Control Change, Event Generating Commands
@section エクスクルーシブイベントの生成
@cindex エクスクルーシブイベント
@cindex エクスクルーシブメッセージ

エクスクルーシブメッセージのイベントを生成する
コマンドには次の３種類があります。

@table @t
@item @r{C:} excl(@var{array}) @r{[}@var{modifiers}@r{]}
@findex excl
時刻 (@code{t} + @code{dt})、トラック番号 @code{tk} に
エクスクルーシブメッセージのイベント生成します。

エクスクルーシブメッセージの内容は配列 @var{array} によって指定します。
@var{array}の各要素は数値でなればなりません。
メッセージ先頭の 0xF0 と末尾の 0xF7 は自動的に付加されますので、
配列要素には含めないで下さい。
エクスクルーシブメッセージの長さに制限はありません。

エクスクルーシブメッセージを作成するとき、
各要素データに対して 0x7F のビットマスクがかけられます。
すなわち、各要素データの下位7ビット以外は無視されます。

@subsubheading @code{excl} の使用例

@example
excl( #(0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x04, 0x64, 0x58) )
@end example

@item @r{C:} excl2(@var{array}) @r{[}@var{modifiers}@r{]}
@findex excl2
@code{excl} とほぼ同じですが、
エクスクルーシブメッセージの最後に 0xF7 が付加されない点、
及び 0x7F のビットマスクがかけられない点が異なります。
次の @code{arbit} と合わせて
長いエクスクルーシブメッセージを分割して送出したり、
（MIDIの規約には違反するが）最上位ビットが1のデータを
メッセージに含めたい場合に使用されます。

@item @r{C:} arbit(@var{array}) @r{[}@var{modifiers}@r{]}
@findex arbit
@cindex 任意メッセージ
@cindex システムコモンメッセージ
時刻 (@code{t} + @code{dt})、トラック番号 @code{tk} に
任意のMIDIメッセージを出力するためのイベントを生成します。

@code{excl} とは異なり、@var{array}の各要素データに対して
ビットマスクはかけられません。

@code{arbit} コマンドは、@code{excl2} コマンドと合わせて
次の例のように長いエクスクルーシブメッセージを
小分けして時間をおきながら音源に送出する場合に使用することができます。

@example
excl2( #(0x41, 0x10, 0x42) )   // 最初は excl2 で始める
r(s)
arbit( #(0x12, 0x40, 0x00) )   // 2番目以降は arbit を使う
r(s)
arbit( #(0x04, 0x64, 0x58, 0xf7) )  // 最後の 0xf7 は必要
@end example

また @code{arbit} コマンドは、システムコモンメッセージなど
他のコマンドでは生成できない任意MIDIメッセージを扱うのに
利用することもできます。
@end table

@noindent
各コマンドの @var{modifiers} については @ref{Modifiers} を見て下さい。

@node Meta Events,  , Exclusive Events, Event Generating Commands
@section メタイベントの生成
@cindex メタイベントの生成

メタイベントの生成には以下のコマンドを使用します。
ただし、テンポ設定については @ref{Control-Change Events} の方を御覧下さい。
以下のコマンドによって生成される
メタイベントのイベント時刻はすべて (@code{t} + @code{dt}) です。

@table @t
@item @r{C:} seqno(@var{value}) @r{[}@var{modifiers}@r{]}
@findex seqno
@cindex シーケンス番号
シーケンス番号のメタイベントを生成します。
シーケンス番号は @var{value}、
トラック番号は１（出力MIDIファイルが format 0 または 1 の場合）
または @code{tk}（format 2 の場合）になります。

シーケンス番号イベントは、MIDIファイルの規定により、
トラックの冒頭（時刻 0）にある必要があります。

@item @r{C:} text(@var{type}, @var{string}) @r{[}@var{modifiers}@r{]}
@findex text
@cindex テキストイベント
任意の種類のテキストイベントを生成します。
トラック番号は @code{tk}、
テキスト種別番号は @var{type}、
テキストの内容は @var{string} になります。
テキスト種別番号 @var{type} は 1 から 15 の間である必要があります。

@item @r{SM:} title(@var{string}) @r{[}@var{modifiers}@r{]}
@findex title 
@cindex 曲名タイトル
@cindex タイトル
トラック１（ただし
出力MIDIファイルが format 2 の場合はトラック @code{tk}）に
一般テキスト文字列のイベント（種別番号１のテキストイベント）
を生成します。
主に曲名タイトル文字列を標準MIDIファイルに挿入するために用いられます。

@item @r{SM:} comment(@var{string}) @r{[}@var{modifiers}@r{]}
@findex comment
@cindex コメント
トラック @code{tk} に
一般テキスト文字列のイベント（種別番号１のテキストイベント）
を生成します。主に曲に関するコメント文字列を
標準MIDIファイルに挿入するために用いられます。

@item @r{SM:} copyright(@var{string}) @r{[}@var{modifiers}@r{]}
@findex copyright
@cindex 著作権表示
トラック１に著作権表示文字列のイベント（種別番号２のテキストイベント）を
生成します。

@item @r{SM:} seqname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex seqname
@cindex シーケンス名
トラック１（ただし
出力MIDIファイルが format 2 の場合はトラック @code{tk}）に
シーケンスまたはトラック名のイベント（種別番号３のテキストイベント）を
生成します。
このコマンドはシーケンス名を指定するために用いられます。

@item @r{SM:} trackname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex trackname
@cindex トラック名
トラック @code{tk} に
シーケンスまたはトラック名のイベント（種別番号３のテキストイベント）を
生成します。
このコマンドはトラック名を指定するために用いられます。
トラック名は、
PMMLコンパイラの @samp{-T} コマンド行オプションによって、
演奏するトラックを指定する際に利用できます。

@item @r{SM:} instname(@var{string}) @r{[}@var{modifiers}@r{]}
@findex instname
@cindex 楽器名
トラック @code{tk} に
楽器名のイベント（種別番号４のテキストイベント）を生成します。

@item @r{SM:} lyric(@var{string}) @r{[}@var{modifiers}@r{]}
@findex lyric
@cindex 歌詞
トラック @code{tk} に
歌詞のイベント（種別番号５のテキストイベント）を生成します。

@item @r{SM:} mark(@var{string}) @r{[}@var{modifiers}@r{]}
@itemx @r{SM:} marker(@var{string}) @r{[}@var{modifiers}@r{]}
@findex mark
@findex marker
@cindex マーカー
トラック１（ただし
出力MIDIファイルが format 2 の場合はトラック @code{tk}）に
マーカーのイベント（種別番号６のテキストイベント）を
生成します。@code{mark} と @code{marker} のどちらでも同じです。
マーカー名は、
PMMLコンパイラの @samp{-f} や @samp{-t} コマンド行オプションによって、
演奏する範囲を指定する際に利用できます。

@item @r{SM:} cue(@var{string}) @r{[}@var{modifiers}@r{]}
@findex cue
@cindex キューポイント
トラック @code{tk} に
キューポイントのイベント（種別番号７のテキストイベント）を生成します。

@item @r{C:} end @r{[}@var{modifiers}@r{]}
@findex end
@cindex トラックの終り
`End of track' イベントを生成します。トラック番号は @code{tk} になります。
このコマンドを実行しなくても、`End of track' イベントは
各トラックの最後に自動的に追加されますので、通常は実行する必要はありません。
@code{end} コマンドが有効なのは、
あるトラックの演奏を途中て打ち切りたい場合です。
各トラックの `End of track' イベントより
後にあるイベントは無視されてMIDIファイルには出力されませんので、
@code{end} によってそれ以降の演奏をカットすることができます。

@ignore
曲の最後に無音部分を残したい場合。
@code{end} コマンドがない限り、最後の音符のノートオフイベントが
曲の終りだと見なされますので、
曲の最後が休符であったり、あるいは最後の音符の
持続時間が音価より短かい場合には、
生成されるMIDIファイルは最後の小節だけ少し短い格好になってしまいます。
これが望ましくない場合には、最後の音符の後に @code{end} コマンドを置きます。
@end ignore

@item @r{C:} smpte(@var{hour}, @var{min}, @var{sec}, @var{frame}, @var{frac}) @r{[}@var{modifiers}@r{]}
@cindex SMPTEオフセット
@findex smpte
SMPTEオフセット・イベントを生成します。
トラック番号は１（出力MIDIファイルが format 0 または 1 の場合）
または @code{tk}（format 2 の場合）、
時間は @var{hour}、
分は @var{min}、
秒は @var{sec}、
フレーム番号は @var{frame}、
フレーム番号小数部は @var{frac} になります。

@ifset html
<A NAME="TIMESIG"></A>
@end ifset
@item @r{C:} timesig(@var{num}, @var{den}, @r{[}@var{metro}, @r{[}@var{div}@r{]]}) @r{[}@var{modifiers}@r{]}
@cindex 拍子設定
@findex timesig
拍子設定イベントを生成します。
トラック番号は１（出力MIDIファイルが format 0 または 1 の場合）
または @code{tk}（format 2 の場合）になります。

分子 @var{num} と 分母 @var{den} は、楽譜に表れる拍子記号の分子と分母です。
メトロノーム周期 @var{metro} は 分母 @var{den} で表される
音符（例えば @var{den}が 4 なら４分音符）のいくつ毎に
メトロノームのクリックを鳴らすかを表します。
@var{metro} を省略すると 1 になります。
分割数 @var{div} はMIDIにおける４分音符がシーケンサーにおける32分音符の
何個分に相当するかを表し、通常は８に設定します（省略値も８です）。

@var{num}、@var{den} および @var{div} が 0 または負、
あるいは @var{metro} が負である場合には
エラーになります。また分母 @var{den} が２の冪乗でない場合には警告が出され、
２の冪乗になるように修正されます。

いくつかの拍子設定の例を下に示します。

@example
timesig(4,4)       // @r{4/4 拍子}
timesig(3,4)       // @r{3/4 拍子}
timesig(2,4)       // @r{2/4 拍子}
timesig(2,2)       // @r{2/2 拍子}
timesig(6,8,3)     // @r{6/8 拍子（(3+3)/8 の場合）}
timesig(6,8,2)     // @r{6/8 拍子（(2+2+2)/8 の場合）}
timesig(12,8,3)    // @r{12/8 拍子（(3+3+3+3)/8 の場合）}
timesig(12,8,4)    // @r{12/8 拍子（(4+4+4)/8 の場合）}
timesig(5,8)       // @r{5/8 拍子}
@end example

時刻０において拍子が設定されていないときは、4/4 拍子になります。

@item @r{C} keysig(@var{sharp-flats}, @var{mode}) @r{[}@var{modifiers}@r{]}
@findex keysig
@cindex 調の設定
@cindex 調号イベント
調号のイベントを生成します。トラック番号は @code{tk} になります。

@var{sharp-flats} は調号に表れるシャープまたはフラットの数であり、
シャープの場合に正、フラット場合に負の値を指定します。
@var{mode} は長調のとき 0、短調のとき 1 を指定します。
例えば、ト長調では @code{keysig(1,0)}、ト短調では @code{keysig(-2,1)}
のように指定します。

@code{keysig} コマンドは、@code{key} レジスタの操作とは、
全く独立に働きます(@pxref{Key})。
また、@code{keysig} コマンドの動作は @code{tp} レジスタの値には
影響されません。
従って、@code{tp} レジスタを変更して曲の移調を行った場合には、
ユーザの責任において @code{keysig} の引数を修正する必要があります。

@item @r{C:} meta(@var{type}, @var{array}) @r{[}@var{modifiers}@r{]}
@findex meta
@cindex 任意のメタイベント
任意の種類のメタイベントを生成します。
メタイベント種別番号 @var{type} は 0 から 127 の間である必要があります。
メタイベントのデータ部は配列 @var{array} で指定します。
配列の各要素は数値でなけばなりません。
データ長は @var{array} の要素数から算出されますので、
配列要素の中にデータ長を表すバイト列を含める必要はありません。

メタイベントが出力されるトラックは、
@var{type} が 0x01 (シーケンス番号),
0x54 (SMPTEオフセット), 0x58 (拍子イベント) のいずれかで、
かつ出力MIDIファイルが format 2 でない場合には、
@code{tk} レジスタの値に関わらず常にトラック１になります。
それ以外では、@code{tk} レジスタの値がトラック番号になります。	

@code{meta} コマンドによってテンポ設定イベントを生成してはいけません。

メタイベントの種別によっては、MIDIファイルの規約によってデータ長が
定められているものがあります。
これとは異なる長さのメタイベントを生成してもエラーにはなりませんが、
間違った標準MIDIファイルが生成されてしまうことになります。
@end table

@noindent
各コマンドの @var{modifiers} については @ref{Modifiers} を見て下さい。

@c --------------------------------------------------------------------
@node Macros, Control Structures, Event Generating Commands, Top
@chapter マクロ
@cindex マクロ

繰り返し利用する演奏パターンを１つの短い名前で定義したり、
音色番号やリズム楽器のノート番号をわかりやすいように名前で
定義したりするために、マクロはよく使われます。

@menu
* Types of Macros::             マクロの分類
                                変数型マクロと関数型マクロの違い
* Calling Macros::              マクロの呼び出し方法      
* Defining Variable Macros::    変数型マクロの定義方法 
* Defining Function Macros::    関数型マクロの定義方法 
* Macro Examples::              関数型マクロの例 
* Local Macros::                ローカルマクロの使用法 
* Scope Rules::                 マクロの通用範囲に関する規則 
* Scope Specifiers::            名前の通用範囲を明示的に指定する方法 
* Macro Directive::             マクロ指令を実行できるのはどの位置か？
* Eval Macro Directive::        式の強制評価 
* Evalstr Macro Directive::     文字列のソーステキストとしての評価 
* Undefining Macros::           マクロ定義の取り消し法 
* Examine Empty Token Lists::   トークン列が空かどうか判定するには？ 
* File Inclusion::              他のソースファイルの読み込み 
@end menu

@node Types of Macros, Calling Macros, Macros, Macros
@section マクロの種類
@cindex マクロの種類
@cindex 変数型マクロ
@cindex 関数型マクロ
@cindex スレッドマクロ
@cindex ローカルマクロ

PMMLのマクロには２通りの分類方法があり、
１つはマクロの機能による分類、
もう１つはマクロの通用範囲による分類です。

@noindent
マクロを機能によって分類すると次の２つになります。

@table @dfn
@item 変数型マクロ
これは他のプログラミング言語における変数に相当し、
引数をとることはできませんが、
関数型マクロよりも高速に展開が行われます。
変数型マクロは代入演算子によって定義します。
変数型マクロは任意のデータ型(@pxref{Data Types})と結び付くことができます。

@item 関数型マクロ
これは他のプログラミング言語における関数に相当するもので、
変数型マクロよりも低速ですが、引数を渡せるメリットがあります。
また、ローカルマクロが使えるのも関数型マクロだけです。
関数型マクロは @code{def} または @code{edef} コマンドを用いて定義します。
関数型マクロと結び付くことのできるデータ型はトークン列型だけです。
@end table

@noindent
マクロをその通用範囲によって分類すると次の２つになります。

@table @dfn
@item スレッドマクロ
これはスレッドごとに定義されているマクロであり、
マクロが属しているスレッド及びその子孫スレッドにおいてのみ有効になります。
ルートスレッドに属しているスレッドマクロは
特に @dfn{グローバルマクロ} と呼ばれ、これは全ての範囲で常に通用します。

@item ローカルマクロ
これは他のプログラミング言語におけるローカル変数に相当するものであり、
１つの関数型マクロの展開中だけ有効なマクロです。
マクロ展開が終わると自動的に消滅します。
@end table

@node Calling Macros, Defining Variable Macros, Types of Macros, Macros
@section マクロの呼び出し
@cindex マクロの呼び出し

変数型マクロの呼び出しは、次のように単にマクロ名を書くだけです。

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name}
@end table
@findex @var{macro-name}

@noindent
@var{scope} はマクロの通用範囲を指定する
ためもので省略可能です(@pxref{Scope Specifiers})。

関数型マクロの場合にはマクロ名の後に括弧でくくって
コンマで区切った引数のリストを並べます。
引数が無くても空括弧 @samp{()} は必要です。

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name}(@var{argument}, @r{@dots{}})
@end table

@noindent
引数の数や型が引数仕様(@pxref{Argument Spec})と異なるときにはエラーになります。
引数リストの最後がカンマで終わった場合、つまり

@example
macro2(1,2,)
@end example

@noindent
のようなとき、最後のカンマは無視されます。

トークン列型のデータに結び付いた変数型マクロと関数型マクロは、
式の中の演算数として呼び出された時の展開のされ方が異なります。
トークン列と結び付いた変数型マクロは、トークン列定数と同じように
扱われます。これに対して関数型マクロは、式を構成するトークンの一部として
展開されます。下の例を参照して下さい。

@example
x = '1 + 2'        // x はトークン列と結び付いた変数型マクロ
def(y) @{ 1 + 2 @}   // y は関数型マクロ

x2 = x    // これは次のように展開され、結局 x2 にはトークン列が結び付く。
     @expansion{} x2 = '1 + 2' 

y2 = y()  // これは次のように展開され、結局 y2 には整数 3 が結び付く。
     @expansion{} y2 = 1 + 2 
     @expansion{} y2 = 3
@end example

@node Defining Variable Macros, Defining Function Macros, Calling Macros, Macros
@section 変数型マクロの定義
@cindex 変数型マクロの定義

次のコマンドは変数型マクロを定義します。

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name} = @var{expr}
@end table
@findex =
@findex @var{macro-name} = @var{expr}

@noindent
@var{scope} はマクロの通用範囲を指定する
ためもので省略可能です(@pxref{Scope Specifiers})。
@var{macro-name} は定義するマクロの名前です。
@var{expr} はどんな型でも構いません。
@var{expr} の中に含まれるマクロの展開や式の計算はマクロ定義時に行われ、
@var{macro-name} と結び付くのはその計算結果です。

@var{macro-name} は既に定義済みのマクロであっても構いません。
この場合は再定義となります。
ただし、マクロ以外の種類の識別子（例えばスレッド名など）
として既に定義されている場合にはエラーになります。

レジスタ変更の場合と同じように、次のように複合代入演算子を用いた
変数型マクロの定義も可能です。

@table @t
@item @r{MD:} @r{[}@var{scope}@r{]}@var{macro-name} @var{op}= @var{expr}
@end table
@findex @var{op}=
@findex @var{macro-name} @var{op}= @var{expr}

@noindent
上のコマンドは、

@example 
@r{[}@var{scope}@r{]}@var{macro-name} = @r{[}@var{scope}@r{]}@var{macro-name} @var{op} @var{expr}
@end example

@noindent
と同じ意味になります。ただし、@var{op} は次の演算子のいずれかです。

@example
+ - * / % shl shr & xor |
@end example

次の例は整数型、浮動小数点型及び文字列型の変数型マクロの定義を行います。

@example
$v1 = 64
$v2 *= 1.5
song_title = "Simple song"

v=$v1 C4 D4 v=$v2 E4 F4
     @expansion{} v=64 C4 D4 v=96.0 E4 F4

title(song_title)
     @expansion{} title("Simple song")
@end example

@noindent
下の例はトークン列型の式を使った例です。

@example
chord1 = '[C4 E4 G4]'
Violin = 'prog(41)'

Violin
     @expansion{} prog(41)
q chord1 i chord1 chord1
     @expansion{} q [C4 E4 G4] i [C4 E4 G4] [C4 E4 G4]
@end example

@node Defining Function Macros, Macro Examples, Defining Variable Macros, Macros
@section 関数型マクロの定義
@cindex 関数型マクロの定義

関数型マクロは @code{def} または @code{edef} コマンドによって定義されます。

@table @t
@item @r{MD:} def(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{arg-spec}@r{]}) @{ @var{token} @dots{} @}
@item @r{MD:} edef(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{arg-spec}@r{]}) @{ @var{token} @dots{} @}
@end table
@findex def
@findex edef

@var{scope} はマクロの通用範囲を指定する
ためもので省略可能です(@pxref{Scope Specifiers})。
@var{macro-name} は定義するマクロの名前です。
@var{arg-spec} はマクロの引数仕様を表した文字列です(@pxref{Argument Spec})。
トークン列 @var{token} @dots{} はマクロの定義内容です。
トークン列を囲んでいる中括弧は、
グルーピングのコマンド(@pxref{Grouping})と同じ記号のため混同しやすいですが、
単に定義するトークン列の範囲を示すためのもので、
定義したマクロによって置き換えられた結果には現れません。

@code{def} コマンドの場合、中括弧内のトークン列について、
定義する時点でのマクロ展開、引数置換、マクロ指令の評価は
一切行われません。記述したものがそのままマクロの定義内容になります。
これに対し @code{edef} コマンドの場合は
引数置換と @code{eval} 及び @code{evalstr} マクロ指令の評価だけを
定義時に行います。

識別子は既に定義済みのマクロであっても構いません。この場合は再定義と
なります。ただし、マクロ以外の種類の識別子（例えばスレッド名など）
として既に定義されている場合にはエラーになります。

@menu
* Argument Substitution::       マクロの引数を参照するには？
* Argument Spec::               引数仕様文字列の書き方 
@end menu

@node Argument Substitution, Argument Spec, Defining Function Macros, Defining Function Macros
@subsection 引数置換
@cindex 引数置換
@findex $@var{number}
@findex $#
@findex $@@
@findex $*
@findex $$
@findex $[@var{expr}]

@code{def} または @code{edef} コマンドにおいて、
@samp{@{} と @samp{@}} で囲まれたトークン列の中で以下の記述を使用すると、
その部分はマクロが展開されたときに引数の内容に置換されます。

@table @code
@item $@var{number}
@var{number} 番目の引数の内容に置換されます。
@var{number} は 1 以上の整数であり、式は使えません。
@var{number} が実際の引数の数を越えたとき、
もしその引数が省略可能と指定されている場合には空に置換され、
そうでない場合はエラーになります。

@item $#
マクロ引数の数に置換されます。

@item $@@
コンマによって区切られた全引数のリストに置換されます。

@item $[@var{expr}]
式 @var{expr} の値が計算され、その値番目の引数の内容に置換されます。
@var{expr} の値が実際の引数の数を越えたときは、
$@var{number} と同様に、
もしその引数が省略可能と指定されている場合には空に置換され、
そうでない場合はエラーになります。

@item $*
マクロ引数からなる配列に置換されます。
@samp{$*[@var{expr}]} の様に使用すれば、
上と同様に式によって何番目の引数かを指定できますが、
@var{expr} の値が引数の数を越えたときは常にエラーとなる点が異なります。

@item $$
@samp{$} 自身に置換されます。
主に @code{edef} コマンドにおいて呼び出された時の引数を
参照するために使われます(@pxref{Macro Examples})。
@end table

@node Argument Spec,  , Argument Substitution, Defining Function Macros
@subsection 引数仕様文字列
@cindex 引数仕様文字列

@code{def} または @code{edef} コマンドにおける第２引数は
引数仕様文字列と呼ばれ、マクロ引数の型を表します。
引数仕様文字列は省略可能で、省略時は @t{"q*"} と見なされます。
引数を取らない関数型マクロの場合は空文字列 @t{""} を指定しますが、
この場合でも呼び出す時には @samp{()} が必要です。

引数仕様文字列は以下の文字のうちのいずれかを
各引数に対して１文字ずつ第１引数から順に並べたものです。

@table @asis
@item @code{q} --- 無評価トークン列 (Quoted token list)
いわゆる遅延評価と呼ばれている引数渡しの方法を実現します。
引数には任意のトークン列を置くことができ、それは空であっても構いません。
引数トークン列はそのままトークン列としてマクロに渡されます。
ただし、マクロに渡される前に、
引数置換と @code{eval} 及び @code{evalstr} マクロ指令の評価だけは
行われます。マクロ展開やこれら以外のマクロ指令の評価は行われません。

マクロ定義の中において、この方法によって受け渡されたトークン列を
式の演算数として参照したときは、関数型マクロの展開と同じように、
式を構成するトークンの一部として展開されます(@pxref{Calling Macros})。

@item @code{i} --- 整数 (Integer)
引数として整数、有理数、または浮動小数点型の式を受け、
整数型以外の場合は整数に自動変換されます(@pxref{Type Conversion})。
式の評価は呼び出し時に行われます。つまり、
マクロを呼び出す際に引数中に含まれるマクロの展開、レジスタ参照、
及び式の計算が行われ、１つの整数になってからマクロに渡されます。

@item @code{f} --- 浮動小数点数 (Floating-point Number)
引数として整数、有理数、または浮動小数点型の式を受け、
浮動小数点型以外の場合は浮動小数点数に
自動変換されます(@pxref{Type Conversion})。
式の評価は呼び出し時に行われます。

@item @code{r} --- 有理数 (Rational Number)
引数として整数、有理数、または浮動小数点型の式を受け、
有理数型以外の場合は有理数に
自動変換されます(@pxref{Type Conversion})。
式の評価は呼び出し時に行われます。

@item @code{n} --- 数値 (Number)
引数として整数、有理数、または浮動小数点型の式を受けます。
型変換は行われません。
式の評価は呼び出し時に行われます。

@item @code{s} --- 文字列 (String)
引数として文字列型の式を受けます。
式の評価は呼び出し時に行われます。

@item @code{p} --- 数値または文字列 (Primary Data)
引数として整数、有理数、浮動小数点、または文字列型の式を受けます。
式の評価は呼び出し時に行われます。

@item @code{a} --- 配列 (Array)
引数として配列型の式を受けます。
引数中に含まれるマクロの展開、各要素の式の評価は、
マクロを呼び出す際に行われます。

@item @code{t} --- トークン列 (Token List)
引数としてトークン列型の式を受けます。
式の評価は呼び出し時に行われます。

マクロ定義の中において、この方法によって受け渡されたトークン列を
式の演算数として参照したときは、変数型マクロの展開と同じように、
トークン列定数と同じように扱われます(@pxref{Calling Macros})。

@item @code{e} --- 任意の型の式 (Expression)
引数として任意の型の式を受けます。
式の評価は呼び出し時に行われます。

@item @code{l} --- ループ変数 (Loop Variable)
@code{for} または @code{foreach} で使用するループ変数の名前を
引数として渡すための特別な引数仕様です。
@samp{def(for10, "l") @{ for($1,1,10) @}} というような場合に使用します。
@end table

@noindent
上の文字の他に引数仕様の中に次の文字を含めることができます。

@table @asis
@item @code{:} ---  オプション指定
以後の引数が省略可能であることを示します。

@item @code{*} --- 繰り返し
1つ前の引数の 0 回以上の繰り返しを意味します。
必ず引数仕様文字列の最後に来る必要があります。
@end table

@noindent
例えば、

@example
def(macro1, "n:qs*") @{ @dots{} @}
@end example

@noindent
という場合、@code{macro1} の第１引数は数値、第２引数は無評価トークン列、
第３引数以降は文字列であることを示し、
更に２番目以降の引数は省略可能であることを意味します。

@node Macro Examples, Local Macros, Defining Function Macros, Macros
@section 関数型マクロの例
@cindex 関数型マクロの例

@subsubheading 伴奏パターンの定義

下の例は簡単なワルツの伴奏を定義したマクロです。
伴奏の構成音は引数で渡します。@code{waltz} マクロでは、
まず第１引数の音をアクセントをつけて４分音符で演奏したあと、
第２引数と第３引数からなる和音をスタッカートで２回演奏するように定義
しています。引数には任意のトークン列を置けますので、
最後の行のように第１引数をオクターブにすることも可能です。

@example
def(waltz) @{
  q $1++ @{dr=30 [$2 $3] [$2 $3]@}
@}
waltz(C, E, G)
waltz(_B, F, G)
waltz(C, E, G)
waltz([_C C], E, G)
@end example

@subsubheading 修飾音マクロの例

次の @code{grace} というマクロは、
音符に半音下からの装飾音を付加するマクロです。
@samp{$1(l -= z)} の部分は引数で与えられた音符（基本音）を
演奏しますが、装飾音の分だけ音価を短く変更しています。

@example
def(grace) @{
  note( n = $1 - 1     // 半音下の装飾音。
        v *= 0.5       // ベロシティーは基本音の半分
        z )            // 長さは32分音符
  $1( l -= z )         // 基本音
@}
grace(c4)
@end example

@noindent
上の例では装飾音の先頭がもともとの発音タイミングに一致していますが、
逆に基本音の先頭を一致させたい場合には下のようにします。
ただし、装飾音が１つ前の音と重なって発音される可能性があります。

@example
def(grace) @{
  note( n = $1 - 1; v *= 0.5; z; dt -= z ) &      
  $1       // 基本音
@}
@end example

@subsubheading 算術関数の定義

下の例は引数の値を２乗するマクロです。結果を囲む括弧は必要であり、
これがないと @samp{1 / sqr($x)} という場合に @samp{1 / $x * $x} のように
展開されて値が狂ってしまいます。引数仕様にマクロ展開時に式の計算を
行う @t{"n"} を用いていますので @samp{(($1) * ($1))} とする必要はありません。

@example
def(sqr, "n") @{
  ($1 * $1)
@}
@end example

@subsubheading マクロの再帰呼び出し
@cindex マクロの再帰呼び出し

マクロは再帰的に呼ぶことも可能です。下の例は再帰を利用して
フィボナッチ数を計算するマクロです。

@example
def(fib, "n") @{
  if( $1 < 2 )  @{ 1 @}
  else @{ (fib($1-1) + fib($1-2)) @}
@}
@end example

@subsubheading @code{edef} の使用例
@cindex @code{edef} の使用例
@findex edef

下はコントロールチェンジ用のマクロを定義するための
マクロを @code{edef} を使って実現した例です。

@example
def(defcontroller, "qn") @{ 
  edef($1) @{ ctrl($2, $$1) @}
@}
@end example

@noindent
これを用いて例えばボリュームコントローラを定義すると、次のようになります。

@example
defcontroller(vol, 7)
     @expansion{} def(vol) @{ ctrl(7, $1) @}
@end example

@noindent
@code{edef} の中で @samp{$$1} が使われていますが、
これは @code{defcontroller} が定義するマクロの内容に
引数参照が入るようにしたものです。
もしこれを @samp{$1} と書いたら、次のように展開されてしまうことに
なります。

@example
def(defcontroller2, "qn") @{ 
  edef($1) @{ ctrl($2, $1) @}
@}

defcontroller2(vol, 7)
     @expansion{} def(vol) @{ ctrl(7, vol) @}
@end example

@node Local Macros, Scope Rules, Macro Examples, Macros
@section ローカルマクロ
@cindex ローカルマクロ
@findex local

ローカルマクロは１つの関数型マクロの展開中だけ有効なマクロです。
マクロ展開が終わると自動的に消滅します。
あるマクロの中で一時的に必要な別のマクロを定義する場合、
スレッドマクロを使用してしまうと、
既に同じ名前のスレッドマクロが存在していたときにそれを
破壊してしまうという危険性が生じますが、
ローカルマクロを用いれば安全に処理することができます。

ローカルマクロは、定義時にマクロ名の前に @samp{local::} という
通用範囲指定を置くことによって生成されます。
@samp{local::} は最初に定義するときにだけ必要であり、以後その
ローカルマクロを呼び出しまたは再定義するときには単にマクロ名だけ
を書けば十分です（全部に @samp{local::} をつけても害はありません）。

次の例は２つの数の２乗和を計算するマクロを、ローカルマクロを使って書いた
ものです。例えば、@code{sqr_dist(1,2)} として呼ぶと５に置き換わります。
もしもこのマクロを呼ぶ側で、@code{$t} や @code{sqr} という
マクロを既に使用していたとしても、それには全く影響を与えません。

@example
def(sqr_dist, "nn") @{
  local::$t = 0          // ローカルマクロ（変数型）
  def(local::sqr, "n") @{ // ローカルマクロ（関数型）
     ($1 * $1) 
  @}

  $t += sqr($1)
  $t += sqr($2)
  $t                     // これが関数の戻り値に相当する
@}
@end example

ローカルマクロはそれを定義しているマクロの中だけで有効であり、
そのマクロから別のマクロを呼び出してそのマクロを離れた場合にはもはや
有効ではありません。下の例を見て下さい。

@example
def(macro1) @{
  local::$x = 2      // $x というローカルマクロを定義。
  macro2()
  print($x)          // この $x は上のローカルマクロなので
                     // ここでは 2 と出力される。
@}

/* macro2 は macro1 の中から呼ばれている */
def(macro2) @{        
  print($x)          // この $x は上のローカルマクロではなく
                     // グローバルマクロの方の $x なので
                     // ここでは 5 と出力される。
@}

$x = 5
macro1()
@end example

あるマクロにローカルマクロの名前を @t{"q"} 引数仕様を使って渡した場合には、
上のルールによってマクロが参照できなくなってしまわないように、
呼び出す前にローカルマクロの名前がその参照へ置き換えられます。
これによって次の @code{swap} のような場合でも、期待通りの処理が行われます。

@example
def(swap, "qq") @{    // 2つのマクロの値を交換する。
  local::$tmp = $1    // $1 は $x という名前ではなく、それへの参照に
                      // 置き換えられているので、5 が得られる。
  $1 = $2
  $2 = $tmp
@}

def(macro1) @{
  local::$x = 5
  local::$y = 7
  swap($x, $y)
  print($x, $y)
       @print{} 7 5
@}

macro1()
@end example

@node Scope Rules, Scope Specifiers, Local Macros, Macros
@section マクロ名の通用範囲規則
@cindex 通用範囲規則

あるスレッドにおいて、
通用範囲指定 @var{scope} をつけずに
マクロ呼びだしを行えるのは、
そのスレッドおよびその先祖スレッドの
スレッドマクロ、そして現在有効なローカルマクロです。
この中に同じ名前のマクロが複数存在していた場合には、
下に示す優先順位の最も高いものに対して呼び出しが行われます。

@display
(最高)
ローカルマクロ
現スレッドのスレッドマクロ
現スレッドの親スレッドのスレッドマクロ
  :
  :
ルートスレッドのスレッドマクロ（グローバルマクロ）
(最低)
@end display

一方、マクロが定義されるとき、通用範囲指定をつけなかった場合の
定義動作は次のようになります。

@itemize @bullet
@item
同じ名前のローカルマクロが存在していた場合には、
そのローカルマクロを再定義する。

@item
現スレッドに同じ名前のスレッドマクロが存在していた場合には、
そのスレッドマクロを再定義する。

@item
それ以外の場合には、現スレッドに新しいスレッドマクロを定義する。
@end itemize

@noindent
先祖スレッドのスレッドマクロを定義することは
無いことに注意して下さい。例えば、下の例において
３箇所で定義されている @code{$x} は
それぞれ別のマクロを意味することになります。

@example
$x = 1 
@{ $x = 2 
  print($x)     @print{} 2
@}        
print($x)     @print{} 1
@{ $x += 2       // $x = $x + 2 と同じ意味 
  print($x)     @print{} 3
@}
print($x)     @print{} 1
@end example

これらのデフォルトの通用範囲とは異なる通用範囲のマクロを
呼びだし或は定義したい場合には、次節で述べる通用範囲指定を用います。

@node Scope Specifiers, Macro Directive, Scope Rules, Macros
@section 通用範囲指定
@cindex スコープ
@cindex 通用範囲指定
@findex local
@findex global
@findex .
@findex ..
@findex ...

識別子に通用範囲指定を付ければ、デフォルトの通用範囲とは異なる
通用範囲の識別子について参照／定義を行うことができます。
通用範囲指定は次のうちのどれかです。

@table @t
@item local::
ローカルマクロを指定します。

@item @r{[}global@r{]}::
グローバルな識別子、すなわちルートスレッドの辞書に属する識別子を指定します。
@code{global} は省略可能であり、無くても意味は変わりません。

@item @r{[}@var{thread-path}@r{]}@var{thread-name}::
指定された名前つきスレッドの辞書に属する識別子を指定します。
スレッド名 @var{thread-name} はスレッド木のどの位置にあるスレッドの名前でも
構いません。指定した名前のスレッドが複数ある場合には、
もし自分またはその先祖スレッドの中に @var{thread-name} という名の
スレッドが含まれているのなら、そのうちで一番世代の近いスレッドが選ばれます。
もし先祖スレッドに @var{thread-name} という名のスレッドが
含まれていないのなら、選ばれるスレッドは不定となります。
そのような曖昧さを避けるためには @var{thread-path} に
指定するスレッドまでパス（道筋）を示す必要があります。
パスを示すには、指定するスレッドの先祖のうち
一意に指定可能なスレッドの名前をまず書き、
それから順に子スレッド名を @samp{::} で区切りながら並べます。
パスに名前なしスレッドが含まれている場合は、それを除外して記述します。
ルートスレッドからのパスを記述する場合には最初を @samp{::} で始めます。

@item .::
現スレッドの辞書に属する識別子を指定します。

@item ..::
親スレッドの辞書に属する識別子を指定します。

@item ...::
先祖スレッドの中で最も近い名前つきスレッドの辞書に属する識別子を指定します。
@end table

@subsubheading 通用範囲指定の例

@example
$x = 1             // グローバルマクロ
defthread(t1)
t1 @{ 
   defthread(t2)   // t2はt1の子スレッド
   $y = 3          // t1のスレッドマクロ
   ::$x = 5        // グローバルマクロの再定義
   t2 @{
     $z = 7        // t2のスレッドマクロ
   @}
@}

t1::$y += 1        // t1のスレッドマクロの再定義
::t1::$y += 1      // 上と同じ
t2::$z = 9         // t2のスレッドマクロの再定義
::t1::t2::$z = 9   // 上と同じ
@end example

@node Macro Directive, Eval Macro Directive, Scope Specifiers, Macros
@section マクロ指令の利用できる場所
@cindex マクロ指令の利用できる場所
@cindex 引数置換の利用できる場所

@ref{Commands} で述べたようにマクロ指令や組み込み関数は
式の中でも利用できますが、式のどの位置でも利用できるというわけでは
ありません。また、引数置換も利用できる場所が限られています。
以下にこれらの利用できる場所を示します。

@enumerate
@item 
@code{eval}、@code{evalstr} 以外のマクロ指令、及び組み込み関数の
利用できる場所。

@itemize @bullet
@item
一般コマンドの利用できる位置。
@item
式の演算数の位置。
@item
@code{null} マクロ指令の引数中。
@item
@code{defeff} コマンドにおける @code{case} の引数や、
@code{ecode}、@code{set_thru_etypes}、
@code{set_eff_etypes}、@code{add_eff_etypes}、@code{del_eff_etypes} の
引数に現れるイベント型名の場所。
さらに、そのイベント型名に続くコントローラ番号、メタイベント種別番号、
テキスト種別番号の場所。
@item 
@code{set_thru_chs}、@code{set_eff_chs}、@code{add_eff_chs}、
@code{del_eff_chs} の引数に現れるMIDIチャネル番号の場所。
@item
@code{attach} コマンドにおけるエフェクタクラス名の場所。
@end itemize

@item
@code{eval}、@code{evalstr} マクロ指令、及び引数置換の利用できる場所。

@itemize @bullet
@item 
1. で述べたすべての場所。
@item
引数仕様が @t{"q"} であるマクロ引数の中。
@item
@code{edef} マクロ指令の中の @samp{@{} から @samp{@}} まで間。
@item
@code{def}、@code{undef} など識別子を引数として受けとる
マクロ指令または組み込みマクロにおける識別子の場所。
@item
代入演算子、複合代入演算子による変数型マクロ定義の左辺。
@item
通用範囲指定における @samp{::} 以外の位置。
@item
バッククオートで囲んだトークン列定数の中。
@end itemize
@end enumerate

@noindent
演算子の位置や、引数または修飾子を囲む括弧の位置では
マクロ指令は利用できない点に注意して下さい。

@example
// エラーになる例

plus = '+'
$x = 1 plus 5

velup = '(v+=10)'
C velup
@end example

@noindent
しかし、次のようなマクロ定義は可能です。

@example
plus1 = '1 +'
$x = plus1 5

velup = 'v+=10'
C(velup)
@end example

@node Eval Macro Directive, Evalstr Macro Directive, Macro Directive, Macros
@section @code{eval} マクロ指令
@findex eval
@cindex 式の強制評価

@code{eval} は通常式の評価が行われない場所において、
式を評価しその結果に置き換えます。

@table @t
@item @r{MD:} eval(@var{expr})
@end table

@noindent
@code{eval} は次のように @code{edef} やバッククオートの中で
部分的に定義時の式評価をしたいときに利用できます。

@example
$x = 'v+=10'
$y = `n=3 eval($x)`

dumpdef($y)     // $y の定義内容を表示する
     @print{} ::$y = 'n = 3 v += 10'

n = 60
$z = `n=eval(n + 1)`
dumpdef($z)
     @print{} ::$z = 'n = 61'
@end example

@noindent
下は変数型マクロ定義の左辺において @code{eval} を利用した例です。
このように式の評価結果がトークン列になった場合、@code{eval} は
そのトークン列を更に評価することはしません。それを行うためには
@code{eval} を２重以上にする必要があります。

@example
$x = '$y'
$y = '$z'

eval($x) = 5
     @expansion{} $y = 5

print($y)
     @print{} 5

$y = '$z'

eval(eval($x)) = 6
     @expansion{} $z = 6

print($z)
     @print{} 6
@end example

@noindent
次のように配列と組み合わせて利用することもできます。

@example
$table = #('one', 'two', 'three')
for($i, 1, #$table) @{
  eval($table[$i]) = $i
@}
     @expansion{} one = 1  two = 2  three = 3
@end example

@node Evalstr Macro Directive, Undefining Macros, Eval Macro Directive, Macros
@section @code{evalstr} マクロ指令
@findex evalstr

@code{evalstr} は文字列をPMMLソーステキストと見なして評価する
マクロ指令です。フォーマットは以下の通りです。

@table @t
@item @r{MD:} evalstr(@var{string})
@end table

@noindent
文字列 @var{string} は字句解析部に戻されてトークンに分割されます。
そして、上のマクロ指令はそのトークン列に置き換えられます。
例えば、

@example
$x = "c" + "4"      // $x は "c4" という文字列になる
evalstr($x)
@end example

@noindent
は、

@example
c4
@end example

@noindent
という音符コマンドに置換されます。

@code{evalstr} がよく使われるのは、マクロ呼び出しや
マクロ定義において、文字列によってマクロ名を指定するときです。
@code{def} の第１引数や代入演算子の左辺は、
@code{evalstr} の評価が行われますので、マクロ定義のときに
文字列でマクロ名を指定できます。

@example
$base = "expr_"
$opr = "mlt"

/* マクロ名を文字列で指定したマクロ定義 */
def(evalstr($base + "add"), "nn") @{ ($1 + $2) @}
def(evalstr($base + "mlt"), "nn") @{ ($1 * $2) @}

print(expr_add(5,7))
     @print{} 12

/* マクロ名を文字列で指定したマクロ呼び出し */
$x = evalstr($base + $opr) (5,8)

print($x)
     @print{} 40
@end example

@node Undefining Macros, Examine Empty Token Lists, Evalstr Macro Directive, Macros
@section マクロ定義の取り消し
@cindex マクロ定義の取り消し
@findex undef

マクロ定義などを取り消すためには @code{undef} マクロ指令を使います。

@table @t
@item @r{MD:} undef(@r{[}@var{scope}@r{]}@var{macro-name})
@end table

@var{scope} はマクロの通用範囲を指定する
ためもので省略可能です(@pxref{Scope Specifiers})。
@var{macro-name} は取り消すマクロの名前です。

@var{macro-name} が組み込み関数の名前であった場合には、
その組み込み関数を無効にします。これによって、ユーザは組み込み関数の
意味を再定義することが可能です。

@code{undef} はマクロ定義の取り消し以外、
スレッドや通信チャネルの消去やエフェクタ定義の取り消しに使うことができます。
これらについてはそれぞれの章を参照して下さい。

@node Examine Empty Token Lists, File Inclusion, Undefining Macros, Macros
@section 空トークン列の判定
@cindex 空トークン列の判定
@findex null

@code{null} はトークン列が空かどうかをテストします。

@table @t
@item @r{MD:} null(@var{token} @dots{})
@end table

トークン列 @var{token} @dots{} に対して、
マクロ展開、引数置換およびマクロ指令が実行され、
その結果が空トークン列になれば上のマクロ指令は 1 に置き換わり、
さもなければ 0 に置き換わります。
次のように、引数の有無をテストするためによく使われます。

@example
def(mac1, "q:q") @{
  if( null($2) ) @{    // $# < 2 でもよい
    print("The 2nd argument does not exist")
  @} else @{
    print("The 2nd argument exist")
  @}
@}
@end example

@node File Inclusion,  , Examine Empty Token Lists, Macros
@section @code{include} マクロ指令
@cindex ファイルの読み込み
@findex include

@code{include} マクロ指令は、指定されたファイルからPMMLソーステキストを
読み込み、その内容を @code{include} のあった場所に埋め込みます。

@table @t
@item @r{MD:} include(@var{filename})
@end table

@var{filename} は読み込むファイル名を表す文字列型の式です。
ディレクトリパスやドライブ指定（MS-DOSの場合のみ）を含んでいても構いません。
@var{filename} の拡張子が @samp{.pml} である場合にはその拡張子は省略
できます。

ファイルを見つけるときには、検索パス(@pxref{Environment})が参照されますので、
通常はカレントディレクトリだけでなくシステムやユーザの
ライブラリディレクトリも見に行きます。
ファイルがどこにも存在しない場合はエラーになります。

@code{include} はネストしていても構いません。つまり、
読み込むファイルが更に @code{include} を含んでいても正しく処理されます。

@subsubheading @code{include} の使用例

@example
include("gs")         // GS音源用ライブラリの読み込み
include("drums")      // リズム記述用マクロライブラリの読み込み
@end example

@c --------------------------------------------------------------------
@node Control Structures, Arrays, Macros, Top
@chapter 制御構造

本章では条件分岐と繰り返しのためのコマンドについて説明します。
これらのコマンドはすべてマクロ指令として実装されています。
従って、@ref{Macro Directive} に述べられているように式の演算数の位置でも
使用することができます。

@menu
* Conditionals::                条件分岐のためのコマンド 
* Loops::                       繰り返しのためのコマンド 
@end menu

@node Conditionals, Loops, Control Structures, Control Structures
@section 条件分岐のためのコマンド
@cindex 条件分岐

条件分岐を行うコマンドには @code{if} と @code{switch} の２種類があります。

@menu
* If Command::                  条件によって異なるトークン列を選択する
* Switch Command::              多重分岐 
@end menu

@ifset html
<A NAME="IF"></A>
@end ifset
@node If Command, Switch Command, Conditionals, Conditionals
@subsection @code{if} コマンド
@findex if

@code{if} は条件によって異なるトークン列を選択するマクロ指令です。
フォーマットは以下の通りです。

@table @t
@item @r{MD:} if(@var{expr1}) @{@var{tokens-1}@} @r{[}elsif(@var{expr2}) @{@var{tokens-2}@}@r{]} @dots{} @r{[}else @{@var{tokens-n}@}@r{]}
@end table

式 @var{expr1} が真(@pxref{Logical Values})ならば
トークン列 @var{tokens-1} が選択され、
式 @var{expr1} が偽で 式 @var{expr2} が真ならば
トークン列 @var{tokens-2} が選択され（以下同様）、
すべての式が偽ならば トークン列 @var{tokens-n} が選択されます。
@code{elsif} および @code{else} 節は省略可能です。

トークン列を囲む中括弧 @samp{@{ @}} はどんな場合でも必要なことに
注意して下さい。C言語のように @samp{if( x == 1 ) y += 1} といった
書き方はできず、@samp{if( x == 1 ) @{ y += 1 @}} と書かなければなりません。

@subsubheading @code{if} の使用例

@example
/* $tの値によって2つの音符のいずれかを生成する */
if( $t == 1 ) @{ g4 @} else @{ d4 @} 

/* $iが0以外ならばc4音にアクセントをつける */ 
c4(if($i)@{++@})     // c4 if($i)@{++@} は不可

/* 式の中での使用。ifの部分は(v > 40 ? 40 : v)と同じ */
v = 20 + if( v > 40 ) @{ 40 @} else @{ v @}
@end example

@node Switch Command,  , If Command, Conditionals
@subsection @code{switch} コマンド
@findex switch
@cindex 多重分岐

@code{switch} は式の値によって異なるトークン列を選択するマクロ指令です。
フォーマットは以下の通りです。

@table @t
@item @r{MD:} switch(@var{expr}) @{ case(@var{val1}, @var{val2}, @dots{}) @{@var{tokens-1}@} @dots{} @r{[}default @{@var{tokens-n}@}@r{]} @}
@end table

式 @var{expr} の値によって、トークン列 @var{tokens-1} @dots{} @var{tokens-n} 
のうちから１つだけを選択します。
式 @var{expr} の値が、@code{case} の引数 @var{val1}, @var{val2}, @dots{} 
のどれかと一致すれば、その @code{case} に続くトークン列が選択されます。
一致する @code{case} 節が複数ある場合には、先に書いた方が優先します。
もしどの @code{case} 引数にも一致しなければ、
@code{default} に続くトークン列 @var{tokens-n} が選択されます。
式 @var{expr} の型は何でも構いません。
@code{case} の引数 @var{val1}, @var{val2}, @dots{} も任意の型の式です。

@subsubheading @code{switch} の使用例

@example
switch($x) @{
  case(1,2) @{
    print("Hi")                 // $x が 1 または 2 ならばこれが実行される
  @}
  case(1,3) @{
    print("How are you?")       // $x が 3 ならばこれが実行される
  @}
  default @{
    print("Nice to meet you.")  // $x がそれ以外の値ならこれが実行される
  @}
@}

switch(1) @{
  case($x < 0)  @{ $y = 1 @}    // case の引数にも式が使えます 
  case($x == 0) @{ $y = 0 @}
  case($x > 0)  @{ $y = -1 @}
@}
@end example

@ifset html
<A NAME="REPEAT"></A>
@end ifset
@node Loops,  , Conditionals, Control Structures
@section 繰り返しのためのコマンド
@cindex 繰り返し
@cindex ループ

繰り返しを行うコマンドには @code{repeat}、@code{while}、
@code{for}、@code{foreach} の４種類があります。またループから抜け出る
コマンドに @code{break} があります。

@menu
* Repeat Command::              指定回数だけ繰り返す 
* While Command::               条件が満たされている間繰り返す
* For Command::                 カウンタの値を変えながら繰り返す 
* Foreach Command::             配列の各要素について繰り返す  
* Break Command::               ループからの抜け出し  
@end menu

@node Repeat Command, While Command, Loops, Loops
@subsection @code{repeat} コマンド
@findex repeat
@code{repeat} は指定された回数だけトークン列を繰り返すマクロ指令です。

@table @t
@item @r{MD:} repeat(@var{expr}) @{ @var{tokens} @}
@end table

@noindent
式 @var{expr} の値が繰り返し回数です。
これが 0 以下の場合には空トークン列に置き換わります。

@node While Command, For Command, Repeat Command, Loops
@subsection @code{while} コマンド
@findex while
@code{while} は条件が成立している間、トークン列を繰り返す
マクロ指令です。

@table @t
@item @r{MD:} while(@var{expr}) @{ @var{tokens} @}
@end table

@noindent
式 @var{expr} の値が真(@pxref{Logical Values})になるまで
トークン列 @var{tokens} が繰り返されます。
@var{expr} の値が最初から偽の場合は空トークン列に置き換わります。
@var{expr} の値が真のまま変化せずに無限ループとなった場合、
コンパイラが終了しなくなりますので注意して下さい。

トークン列を囲む中括弧 @samp{@{ @}} はどんな場合でも必要なことに
注意して下さい。C言語のように @samp{while( x < 1 ) x += 1} といった
書き方はできず、@samp{while( x < 1 ) @{ x += 1 @}} と書かなければなりません。

@subsubheading @code{while} の使用例

@example
/* ベロシティーを 40,50,60,70 と変えてc4音を演奏する */
v = 40
while( v <= 70 ) @{
  c4
  v += 10
@}
@end example

@ifset html
<A NAME="FOR"></A>
@end ifset
@node For Command, Foreach Command, While Command, Loops
@subsection @code{for} コマンド
@findex for

@code{for} はある変数型マクロ（ループ変数と呼ぶ）の値を変えながら
トークン列を繰り返すマクロ指令です。

@table @t
@item @r{MD:} for(@r{[}@var{scope}@r{]}@var{macro-name}, @var{from}, @var{to} @r{[}, @var{step}@r{]}) @{ @var{tokens} @}
@end table

@noindent
@var{macro-name} および @var{scope} はループ変数の名前と通用範囲です。
@var{scope} が省略された場合で、かつ @code{for} が関数型マクロの中で使用された
場合には、通用範囲として @samp{local::} が仮定されます。
言い替えれば、ループ変数は特に指定のない限りローカルマクロとして扱われます。
始値 @var{from}, 終値 @var{to}, ステップ値 @var{step} はすべて
整数型の式である必要があります。@var{step} は省略すると 1 だと見なされます。

@code{for} の動作は以下の通りです。
始めループ変数の値は @var{from} にセットされ、
ループ変数の値が @var{to} 以下
（@var{step} が負の場合は @var{to} 以上）である間、
トークン列 @var{tokens} を繰り返えすとともに
ループ変数に @var{step} が加えられます。
最初の時点で、@var{from} > @var{to} 
（@var{step} が負の場合は @var{from} < @var{to}）の場合には
空トークン列に置き換わります。

必要ならばループ内でループ変数の値を変更することができます。

ループ変数はループを終了した後も消去されずに残ります。
その値は、@code{break} によって途中で抜け出した場合を除いて、
ループ変数が @var{to} を最初に越えた（@var{step} が負の場合は 
最初に @var{to} 未満になった）時の値になっています。
@code{break} によって抜け出た場合には、@code{break} を実行した
時点でのループ変数の値が残ります。

@subsubheading @code{for} の使用例

@example
for($i,1,3) @{ print($i) @}
     @print{} 1
     @print{} 2
     @print{} 3
for($i,3,1,-1) @{ print($i) @}
     @print{} 3
     @print{} 2
     @print{} 1
for($i,1,4,2) @{ print($i) @}
     @print{} 1
     @print{} 3

x = #(for($i,1,8) @{$i,@})         // 配列初期化での使用
print(x)
     @print{} #(1,2,3,4,5,6,7,8)

/* Menuett   J.S. Bach */
for($i,1,2) @{
  q ^D i G A B ^C q ^D G G 
  q ^ E i C D E F# q G _ G G 
  q ^C i ^D ^C B A q B i ^C B A G 
  if( $i == 1 ) @{
    q F# i G A E G h. A	         // 1回目の繰り返し
  @} else @{
    q A i B A G F# h. G          // 2回目の繰り返し
  @}
@}
@end example

@node Foreach Command, Break Command, For Command, Loops
@subsection @code{foreach} コマンド
@findex foreach

@code{foreach} はある変数型マクロ（ループ変数と呼ぶ）を
配列の各要素に値を変えながらトークン列を繰り返すマクロ指令です。

@table @t
@item @r{MD:} foreach(@r{[}@var{scope}@r{]}@var{macro-name} @r{[}, @var{array}@r{]}) @{ @var{tokens} @}
@end table

@noindent
@var{macro-name} および @var{scope} はループ変数の名前と通用範囲です。
@var{scope} が省略された場合で、
かつ @code{foreach} が関数型マクロの中で使用された
場合には、通用範囲として @samp{local::} が仮定されます。
言い替えれば、ループ変数は特に指定のない限りローカルマクロとして扱われます。

@code{foreach}は、ループ変数の値を
配列 @var{array} の各要素に順に値を変えながら
トークン列 @var{tokens} を繰り返します。
配列 @var{array} を省略すると引数参照の配列 @samp{$*} の意味になります。
配列のサイズが 0 ならば、結果は空トークン列に置き換わります。

ループ変数はループを終了した後も消去されずに残ります。
その値は、@code{break} によって途中で抜け出した場合を除いて、
@var{array} の最後の要素の値になっています。
@code{break} によって抜け出た場合には、@code{break} を実行した
時点でのループ変数の値が残ります。

@subsubheading @code{foreach} の使用例

@example
$a = #("one", "two", "three")
foreach($i,$a) @{ print($i) @}
     @print{} one
     @print{} two
     @print{} three

foreach($i, #(10,20)) @{
  print($i)
@}
     @print{} 10
     @print{} 20

def(printall) @{
  foreach($i) @{ print($i) @}    // 配列名を省略した場合
@}

printall(5,6,7)
     @print{} 5
     @print{} 6
     @print{} 7
@end example

@node Break Command,  , Foreach Command, Loops
@subsection @code{break} コマンド
@cindex ループからの抜け出し
@findex break

@code{break} は、繰り返しのためのマクロ指令(@code{repeat}, @code{while}, 
@code{for}, @code{foreach}, @code{alt}(@pxref{Alternation}))において、
途中で繰り返しを中断するためのマクロ指令です。

@table @t
@item @r{MD:} break@r{[}(@var{level})@r{]}
@end table

@noindent
単に @code{break} とだけ書いた場合、
最内殻のループについてループの残りのトークン列を無視して即座に
ループを抜け出ます。式 @var{level} を指定すると、
そのレベルだけ外側のループを抜け出ることができます。

ループコマンドと @code{break} とが異なるスレッドで実行された場合は、
@code{break} を実行したスレッドがループコマンドを実行したスレッドの
子孫にあたり、且つその子孫スレッドがすべて @samp{&} を伴わない
グルーピングコマンド(@pxref{Grouping})で生成された場合に限り、
ループを抜け出ることができます。下の最後の例を参照して下さい。

@subsubheading @code{break} の使用例

@example
$x = 0
while( $x != 3 ) @{
  print($x)
  if( $x == 1 ) @{ break @}
  $x += 1
@}
     @print{} 0
     @print{} 1

for($i,1,3) @{
  for($j,1,3) @{
    print($i, $j)
    if( $i == 2 && $j == 1 ) @{ 
      break(2)       // 外側のループを抜け出る
    @}
  @}
@}
     @print{} 1 1
     @print{} 1 2
     @print{} 1 3
     @print{} 2 1

for($i,1,2) @{
  C D
  @{                // 子スレッドの生成 
    v=80 E F
    if( $i == 2 ) @{ break @}   // スレッドは異なるが抜け出し可能
  @}
  G A
@}
@end example

@c --------------------------------------------------------------------
@node Arrays, Built-in Functions, Control Structures, Top
@chapter 配列の操作
@cindex 配列

PMMLは動的に要素数を増減することができる配列を持っています。
配列要素のデータ型は任意であり、
要素毎にデータ型が異なっていても構いません。
配列の要素がまた配列であることも可能であり、
これによって２次元以上の配列を構成することができます。
以下の章において、配列を操作するための演算子、マクロ指令、
組み込み関数について説明します。

@menu
* Array Subscripting::          要素参照の方法。添字の書き方。
* Array Size::                  配列の大きさを得る方法 
* Array Expansion::             配列を引数リストに展開する方法
* Duplicating Arrays::          配列を複製する方法 
* Element Replication::         同じ要素を持った配列を初期化する方法 
* Resizing Arrays::             配列に要素を追加、削除する方法 
@end menu

@node Array Subscripting, Array Size, Arrays, Arrays
@section 要素の参照
@cindex 配列要素の参照

配列の後に @samp{[@var{expr}]} を置くと配列の要素を
取り出すことができます。@var{expr} は数値型の式であり、
添字と呼ばれます。
添字は 1 から始まります（C言語と異なるので注意して下さい）。
もし添字が浮動小数点数や有理数の場合には、
型変換規則(@pxref{Type Conversion})に従って整数に丸められます。
範囲を越えた添字を指定するとエラーになります。
配列要素のアクセスにかかる時間は
配列の要素数や添字の大きさとは関係なく一定です。

@subsubheading 要素参照の例

@example
$a = #(10,20,30)
print($a[2])
     @print{} 20
print(#(10,20,30)[2])
     @print{} 20

$x = #(#(1,2,3),        // 2次元配列
       #(4,5,6),
       #(7,8,9)) 
print($x[2][3])
     @print{} 6

$y = $x[1]              // $y には #(1,2,3) が入る。
print($y[3])
     @print{} 3

$n = #('c4', 'd4', 'e4')  // トークン列を要素とした配列
$n[3] $n[2]               // 直接 e4 d4 と書くのと同じ効果がある。
@end example

@noindent
要素参照は（複合）代入演算子によるマクロ定義の左辺に使用することも
できます。

@example
$b = #(1,4,7)
$b[3] = 6               // 第３要素を 6 に変更する。    
print($b)
     @print{} #(1,4,6)
$b[1] += 1
print($b)
     @print{} #(2,4,6)
@end example

@node Array Size, Array Expansion, Array Subscripting, Arrays
@section 要素数
@cindex 配列の要素数

配列の前に @samp{#} を置くと、配列の（第１レベルの）要素数に
置換されます。

@example
$a = #(10,20,30)
print(#$a)
     @print{} 3
$z = #( #(1,2), #(3,4) )
print(#$z)
     @print{} 2
print(# #())  
     @print{} 0          // #()は空の配列なので0が表示される。
@end example

@node Array Expansion, Duplicating Arrays, Array Size, Arrays
@section トークン列への展開
@cindex 配列のトークン列への展開

配列の前に @samp{@@} を置くと、コンマによって各要素が結合された
トークン列に変換されます。例えば、@code{#(1,2,3)} という配列の
前に @samp{@@} を置くと @code{1,2,3} というトークン列が得られます。
このままマクロの引数として渡したり、
次のように配列の連結を行うのに使われます。

@example
$a = #(1,2,3)
$b = #(4,5,6)
$c = #( @@$a, @@$b )     // $aと$bを連結したものを$cへ入れる。
print($c) 
     @print{} #(1,2,3,4,5,6)
@end example

@node Duplicating Arrays, Element Replication, Array Expansion, Arrays
@section 配列の複製
@cindex 配列の複製
@findex dup

代入演算子によって配列型のマクロが定義されるとき、
あるいは配列がマクロの引数として渡されるときは、
配列の複製が行われるのではなく、元の配列への参照が追加されるだけです。
このため、配列の要素を変更するとそれを参照している全てのマクロが
影響を受けます。次の例を見て下さい。

@example
$a = #(1,2,3)
$b = $a                // $bは同じ配列の "別名" になる。    
$a[3] = 5              // $aを変更すると$bも変わる。
print($a)
     @print{} #(1,2,5)
print($b)
     @print{} #(1,2,5)

def(macro1, "a") @{
  $1[1] = 10
@}

macro1($a)             // 配列を引数としてマクロ呼ぶ。

print($a)
     @print{} #(10,2,5)
print($b)
     @print{} #(10,2,5)
@end example

配列の参照は複製よりも格段に高速に行えるためこのような仕様になっていますが、
もし上のような副作用が好ましくない場合には、@code{dup} 組み込み関数を
用いることで配列を複製することができます。

@table @t
@item @r{BI:} dup(@var{array})
@end table

@subsubheading @code{dup} の使用例

@example
$a = #(1,2,3)
$b = dup($a)           // $bには上の配列を複製したものを代入する。
$a[3] = 5              // $aを変更しても$bは変わらない。
print($a)
     @print{} #(1,2,5)
print($b)
     @print{} #(1,2,3)
@end example

@node Element Replication, Resizing Arrays, Duplicating Arrays, Arrays
@section 同じの要素の反復
@cindex 配列要素の反復 
@findex rep

@noindent
@code{rep} 組み込み関数は、同じ要素を指定した回数だけ反復した配列を
返します。

@table @t
@item @r{BI:} rep(@var{nelms}, @var{element})
@end table

@var{nelms} は繰り返し回数、@var{element} は繰り返す要素です。
要素が配列の場合には、配列の複製（参照ではない）によって
要素の反復がなされます。

@subsubheading @code{rep} の使用例

@example
$a = rep(5,0)          // $aには #(0,0,0,0,0) が入る。
$b = rep(3,rep(2,1))   // $bは #(#(1,1),#(1,1),#(1,1)) が入る。
@end example

@node Resizing Arrays,  , Element Replication, Arrays
@section 配列の伸長と縮小
@cindex 配列の伸長と縮小
@findex append
@findex insert
@findex shift

PMMLの配列はその要素数を動的に変更することが可能であり、
リストとしての役割も果たします（ただしリストのように中間に
要素を挿入することはできません）。
配列の要素数を変更するコマンドには次の３つがあります。

@table @t
@item @r{MD:} append(@var{array}, @var{element}, @dots{})
配列 @var{array} の末尾に
任意個の新たな要素を追加します。
2番目以降の引数が追加する要素のリストです。
@var{array} に引数参照の配列 @samp{$*} を指定することはできません。

@item @r{MD:} insert(@var{array}, @var{element}, @dots{})
配列 @var{array} の先頭に
任意個の新たな要素を追加します。
2番目以降の引数が追加する要素のリストです。
@var{array} に引数参照の配列 @samp{$*} を指定することはできません。

@item @r{MD:} shift@r{[}(@var{array} @r{[}, @var{n}@r{]})@r{]}
配列 @var{array} のサイズを縮小します。
@var{n} は整数式であり、
これが正の場合は配列先頭の @var{n} 個の要素が削除され、
負の場合は配列末尾の @minus{}@var{n} 個の要素が削除されます。
@var{n} が 0 の場合は何もしません。
@var{n} が要素数以上の場合には結果は空の配列になります。
@var{array} として引数参照の配列 @samp{$*} も指定できます。
@var{n} を省略すると 1 と見なされます。
また、括弧を含めた引数全体を
省略して @code{shift} だけを残すこともでき、
この場合は @code{shift($*,1)} の意味になります。

引数参照の配列 @samp{$*} に対し @code{shift} を適用して
要素を削除すると、それにつれて @samp{$1}, @samp{$2}, @dots{} も
新しい配列での第１要素、第２要素、@dots{} を参照するように更新されます。
@end table

@subsubheading 配列サイズ変更の例１

@example
$a = #(1,2,3)
append($a, 4,5)       // $aの末尾に4と5を追加。
print($a)
     @print{} #(1,2,3,4,5)
insert($a, 0)         // $aの先頭に0を追加。
print($a)
     @print{} #(0,1,2,3,4,5)
shift($a, 2)          // $aの先頭の2要素を削除。
print($a)
     @print{} #(2,3,4,5)
shift($a, -2)         // $aの末尾の2要素を削除。
print($a)
     @print{} #(2,3)
@end example

@subsubheading 配列サイズ変更の例２

@example
def(mac1, "n*") @{
  print($1, $2, $#)
       @print{} 5 6 3 
  shift               // 引数を1つずつずらす。
  print($1, $2, $#)
       @print{} 6 7 2
@}

mac1(5,6,7)
@end example

@c --------------------------------------------------------------------
@node Built-in Functions, Effectors, Arrays, Top
@chapter 組み込み関数
@cindex 組み込み関数(built-in function)

組み込み関数はシステムよって予め用意されているマクロの一種です。
組み込み関数の処理内容はC言語で書かれており、そのコードは
PMMLコンパイラの中に組み入れられています。
この点において、標準マクロ（これはPMMLで記述されている）とは異なります。

マクロ指令との違いは、組み込み関数は再定義が可能という点です。
スレッド内で、組み込み関数と同じ名前のマクロを定義すれば、
そのスレッド内ではユーザ定義マクロの方が優先します。
ルートスレッドにおいても、一旦 @code{undef} によって
組み込み関数を無効にしてからマクロ定義を行えば、
組み込み関数と同じ名前のマクロを定義することができます。
ただし、これらの再定義は、マクロライブラリが使用している
組み込み関数にも影響を与える危険がありますので、
行う場合は慎重に行って下さい。

@menu
* Message Output Functions::    メッセージの出力。print, printf など。 
* Math Functions::              算術関数。abs, sin など。 
* Random Number Generators::    乱数を生成する関数
* Numerical Type Conversion::   数値間での型変換を行う関数
* String Functions::            文字列処理を行う関数 
* Get Identifier Information::  識別子の種類や定義状態を調べる関数 
* Expression Type::             式の型を調べる type 関数
* Token Extraction::            n番目のトークンを得る nth_token 関数 
* Error Handling::              エラー処理のための関数
* Debugging::                   デバッグのためのサポート関数 
@end menu

@node Message Output Functions, Math Functions, Built-in Functions, Built-in Functions
@section メッセージ出力
@cindex メッセージ出力

メッセージを出力する組み込み関数には以下の種類があります。

@table @t
@item @r{BI:} print(@var{expr}, @dots{})
@findex print
式 @var{expr} の値を標準出力に出力します。
@var{expr} はどんな型でもよく、配列型、トークン列型のときは
その全内容が出力されます。
有理数型の場合は a+b/c (b と c は互いに素、b < c, b >=0, c > 0) という
形で出力されます。
式と式の間は１つのスペース文字で区切られ、
最後には改行文字が付加されて出力されます。

@item @r{BI:} eprint(@var{expr}, @dots{})
@findex eprint
出力が標準エラー出力である以外 @code{print} と同じです。

@item @r{BI:} printf(@var{format}, @var{expr}, @dots{})
@findex printf
C言語の printf と同様のフォーマットつきの出力を行います。
出力は標準出力です。最後に改行文字の付加は行われません。
フォーマット文字列 @var{format} の中では次の変換指定を使うことができます。

@example
%@r{[}+@r{][}-@r{][}0@r{][}@var{space}@r{][}@var{width}@r{[}.@var{precision}@r{]]}@var{convchar}
@end example

@noindent
幅 @var{width} および 精度 @var{precision} は @samp{*} でもよく、
この場合後に続く引数からこれらの数値が
取られます。変換文字 @var{convchar} は次のうちのどれかです。
@table @code
@item d
10進数整数表示。引数が整数以外の場合は整数に丸められて表示される。
@item o
8進数整数表示。
@item x @r{or} X
16進数整数表示。@code{%X} は a-f を大文字で出力。
@item f
小数形式表示。デフォルト精度は小数点以下６桁。
指定精度より下位の部分は丸めが行われる。
@item e @r{or} E
指数形式表示。デフォルト精度は小数点以下６桁。@code{%E} は e を大文字で表示。
@item g @r{or} G 
小数形式または指数形式のうちの適切な方。
小数点以下の末尾の０は削除される。
デフォルトの最大有効桁数は６。
@code{%G} は e を大文字で表示。
@item c
引数で与えられたコードの文字を出力。
@item s
文字列出力。
@item %
@samp{%} 自身を出力。
@end table

@item @r{BI:} eprintf(@var{format}, @var{expr}, @dots{})
@findex eprintf
出力が標準エラー出力である以外 @code{printf} と同じです。
@end table

@node Math Functions, Random Number Generators, Message Output Functions, Built-in Functions
@section 算術関数
@cindex 算術関数

@table @t
@item @r{BI:} floor(@var{expr})
@findex floor
引数の値以下の最大の整数を返します。
整数、有理数、浮動小数点数に対して適用可能であり、
結果は常に整数型になります。

@item @r{BI:} ceil(@var{expr})
@findex ceil
引数の値以上の最小の整数を返します。
整数、有理数、浮動小数点数に対して適用可能であり、
結果は常に整数型になります。

@item @r{BI:} abs(@var{expr})
@findex abs
引数の絶対値を返します。
整数、有理数、浮動小数点数に対して適用可能であり、
結果のデータ型は引数と同一になります。

@item @r{BI:} sqrt(@var{expr})
@findex sqrt
引数の値の平方根を返します。
引数が負の場合はエラーになります。

@item @r{BI:} sin(@var{expr})
@findex sin
正弦関数の値を返します。引数はラジアンで与えます。

@item @r{BI:} cos(@var{expr})
@findex cos
余弦関数の値を返します。引数はラジアンで与えます。

@item @r{BI:} atan2(@var{y}, @var{x})
@findex atan2
@var{y}/@var{x} の逆正接関数に基づいて、
直交座標における点 (@var{x}, @var{y}) を極座標に変換したときの
角度を返します。
@var{x} が 0 の場合でも正しい結果を返します。
結果はラジアンであり、@minus{}πからπまでの範囲です。

@item @r{BI:} exp(@var{expr})
@findex exp
e を底とした指数関数の値を返します。

@item @r{BI:} log(@var{expr})
@findex log 
e を底とした対数関数の値を返します。
引数が正でない場合はエラーになります。
@end table

@node Random Number Generators, Numerical Type Conversion, Math Functions, Built-in Functions
@section 乱数生成のための関数
@cindex 乱数生成のための関数

@table @t
@item @r{BI:} rand()
@findex rand
0 <= x <= 1 の範囲にある浮動小数点の乱数値を返します。

@item @r{BI:} irand(@var{n} @r{[}, @var{m}@r{]})
@findex irand
整数の乱数値を返します。@var{m} が省略された場合、
範囲は 1 から @var{n} までとなります。
@var{m} が指定された場合、範囲は @var{n} から @var{m} まで
になります。

@item @r{BI:} frand(@var{n} @r{[}, @var{key}@r{]})
@findex frand
0 から @var{n}@minus{}1 の範囲にある整数の 1/f 乱数値を返します。
乱数値の分布は一様分布です。@var{n} は２の冪乗でなければなりません。
@var{key} は整数であり、乱数の系列番号（種とは異なる）を意味します。
２つ以上の乱数系列を並行して発生させる場合には、それぞれに対して異なる
系列番号を割り当てないと正しい 1/f 乱数になりません。
@var{key} を省略すると 1 だとみなされます。

@item @r{BI:} fgrand(@var{n} @r{[}, @var{m} @r{[}, @var{key}@r{]]})
@findex fgrand
整数の 1/f 乱数値を返します。
@var{m} が省略された場合、範囲は 1 から @var{n} までとなります。
@var{m} が指定された場合、範囲は @var{n} から @var{m} までになります。
乱数値はガウス分布に近い分布になり、すなわち (@var{n} + 1) / 2 （@var{m} が
指定されているときは (@var{n} + @var{m}) / 2）付近の整数が乱数値として
返される確率が最も高くなります。
@var{key} は上述の @code{frand} の場合と同じ意味です。

@c !!!!!!!!!! 乱数関数を追加／削除したら下も直す !!!!!!!!!!!!!
@item @r{BI:} srand(@r{[}@var{seed}@r{]})
@findex srand
上の４つの関数における乱数の種を設定します。
引数を省略すると、現在の時刻(秒単位)と
プロセス番号の和によって、乱数の種を設定します。
@end table

@node Numerical Type Conversion, String Functions, Random Number Generators, Built-in Functions
@section 数値間の型変換
@cindex 数値間の型変換

@table @t
@item @r{BI:} int(@var{expr}) 
@findex int
任意の型の数を型変換規則(@pxref{Type Conversion})に従って整数に変換します。

@item @r{BI:} rational(@var{expr}) 
@findex rational
任意の型の数を型変換規則(@pxref{Type Conversion})に従って有理数に変換します。

@item @r{BI:} float(@var{expr}) 
@findex float
任意の型の数を型変換規則(@pxref{Type Conversion})に従って浮動小数点数に
変換します。

@item @r{BI:} intg(@var{rational})
@findex intg
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 a を返します。

@item @r{BI:} num(@var{rational})
@findex num
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 b を返します。

@item @r{BI:} den(@var{rational})
@findex den
有理数 @var{rational} を a+b/c (b と c は互いに素、b < c, b >= 0, c > 0) 
という形したときの整数 c を返します。
@end table

@node String Functions, Get Identifier Information, Numerical Type Conversion, Built-in Functions
@section 文字列処理関数
@cindex 文字列処理関数

@table @t
@item @r{BI:} strlen(@var{string}) 
@findex strlen
文字列 @var{string} の長さを返します。

@item @r{BI:} substr(@var{string}, @var{pos} @r{[}, @var{nchars}@r{]}) 
@findex substr
文字列 @var{string} のうち、@var{pos} 文字目から @var{nchars} 個の文字を
取り出した文字列を返します。@var{pos} は 1 が先頭の文字に対応し、
それ未満の場合は 1 と見なされます。@var{nchars} を省略すると、
文字列の最後までという意味になります。

@item @r{BI:} index(@var{string1}, @var{string2})
@findex index
文字列 @var{string1} の中にある文字列 @var{string2} を先頭から探し、
最初にマッチした位置を返します。
結果は @var{string1} の先頭を 1 として数えた整数です。
見つからない場合は 0 になります。

@item @r{BI:} charcode(@var{string} @r{[}, @var{pos}@r{]})
@findex charcode
文字列 @var{string} のうちの @var{pos} 番目にある文字のアスキーコードを
返します。@var{pos} を省略すると 1 とみなされます。
@var{pos} 番目の文字が無い場合は、0 に置き換わります。

@item @r{BI:} atoi(@var{string})
@findex atoi
文字列 @var{string} によって表される整数値を返します。
@var{string} が整数を表す文字列でない場合には 0 を返します。

@item @r{BI:} atof(@var{string})
@findex atof
文字列 @var{string} によって表される浮動小数点値を返します。
@var{string} が浮動小数点数を表す文字列でない場合には 0.0 を返します。

@item @r{BI:} sprintf(@var{format}, @var{expr}, @dots{})
@findex sprintf
@code{printf} (@pxref{Message Output Functions})と同じ書式化が行われ、
その結果得られる文字列を返します。
数値から文字列への変換にはこの @code{sprintf} を使います。

@item @r{BI:} toupper(@var{string})
@findex toupper
文字列 @var{string} 中の文字を全て大文字に変換した文字列を返します。

@item @r{BI:} tolower(@var{string})
@findex tolower
文字列 @var{string} 中の文字を全て小文字に変換した文字列を返します。

@item @r{BI:} notename(@var{note-num} @r{[}, @var{octave}@r{]})
@findex notename
MIDIノート番号 @var{note-num} に対応する音名の文字列を返します。
例えば、@code{notename(61)} は @t{"C#4"} に置換されます。
整数 @var{octave} が指定されている場合には、
そのオクターブを基準として、オクターブが相対表記になります（例えば、
@code{notename(61,3)} は @t{"^C#"} に置換されます）。
@var{octave} が 0 のときは、オクターブ表記のない文字列に変換されます。
@code{notename} においては、
@code{tp} や @code{key} レジスタの値とは無関係に変換が行われます。
また、異名同音が存在する音は、常にシャープがついた形になります。

@item @r{BI:} idstr(@var{identifier})
@findex idstr
識別子 @var{identifier} を文字列に変換します。
例えば、@code{idstr($zzz)} は @t{"$zzz"} に置き換えられます。 
@var{identifier} は定義されていない識別子でも構いませんが、
予約語(@pxref{Identifiers})は受け付けません。

@item @r{BI:} concat(@var{array} @r{[}, @var{delimiter}@r{]})
@findex concat
要素が文字列の配列 @var{array} について、すべての要素を連結した
文字列を返します。@var{delimiter} は要素間に挿入される文字列であり、
省略時は空文字列になります。
@end table

@node Get Identifier Information, Expression Type, String Functions, Built-in Functions
@section 識別子情報の取得
@cindex 識別子情報の取得

@table @t
@item @r{BI:} defined(@r{[}@var{scope}@r{]}@var{identifier})
@findex defined
識別子 @var{identifier} が何らかの種類の名前として定義されていれば 1、
そうでなければ 0 を返します。
@var{scope} は通用範囲指定(@pxref{Scope Specifiers})です。

@item @r{BI:} idtype(@r{[}@var{scope}@r{]}@var{identifier})
@findex idtype
識別子 @var{identifier} の種類によって以下の値を返します。
@var{scope} は通用範囲指定(@pxref{Scope Specifiers})です。

@table @asis
@item 0
未定義名 
@item 1
ローカルマクロ名
@item 2
スレッドマクロ名
@item 3
組み込み関数名
@item 4
スレッド名
@item 5
エフェクタクラス名
@item 6
エフェクタインスタンス名
@item 7
通信チャネル名
@end table
@end table

@node Expression Type, Token Extraction, Get Identifier Information, Built-in Functions
@section 式の型の判定
@cindex 式の型の判定

@table @t
@item @r{BI:} type(@var{expr})
@findex type
式 @var{expr} の型によって、以下の文字列を返します。

@table @t
@item "i"
整数型
@item "r"
有理数型
@item "f"
浮動小数点型
@item "s"
文字列型
@item "a"
配列型
@item "t"
トークン列型
@end table
@end table

@node Token Extraction, Error Handling, Expression Type, Built-in Functions
@section トークンの抽出
@cindex トークンの抽出 

@table @t
@item @r{BI:} nth_token(@r{[}@var{scope}@r{]}@var{macro-name}, @var{n})
@findex nth_token

変数または関数型マクロ @var{macro-name} に結びつけられているトークン列の中の
@var{n} 番目のトークンを返します。例えば、@code{x = 'y = 1'} のとき、
@code{nth_token(x,1)} は @code{y}、@code{nth_token(x,3)} は @code{1} に
それぞれ置き換えられます。
@var{n} がトークン列中の
トークン数を越えた場合には、空トークン列に置き換わります。
@end table

@node Error Handling, Debugging, Token Extraction, Built-in Functions
@section エラー処理
@cindex エラー処理

@table @t
@item @r{BI:} error(@var{format}, @var{expr}, @dots{})
@findex error
コンパイラによってエラーが検出されたのと同じようにして、
標準エラー出力にメッセージを出力し、コンパイラを終了します。
引数はエラーメッセージの内容であり、
@code{printf} と同じ形式です。最後には改行文字が付加されて出力されます。

@item @r{BI:} warn(@var{format}, @var{expr}, @dots{})
@findex warn
コンパイラによって警告が発せられたのと同じようにして、
標準エラー出力にメッセージを出力します。
引数は警告メッセージの内容であり、@code{printf} と同じ形式です。
最後には改行文字が付加されて出力されます。

@item @r{BI:} exit(@var{exit-status})
@findex exit
@cindex 終了ステータス
コンパイルを即座に中断させます。
終了ステータス @var{exit-status} はコンパイラプロセスの終了ステータスとして
オペレーティングシステムに渡されます。
@code{exit} によって中断した場合、出力MIDIファイルは生成されません。
@end table

@node Debugging,  , Error Handling, Built-in Functions
@section デバッグのための関数
@cindex デバッグ

@table @t
@item @r{BI:} dumpdef(@r{[}@var{scope}@r{]}@var{identifier})
@findex dumpdef
識別子 @var{identifier} の定義内容を表示します。
@var{scope} は通用範囲指定(@pxref{Scope Specifiers})です。

@item @r{BI:} dumpdict(@r{[}@var{string} @r{[}, @r{[}@var{thread-path}@r{]}@var{thread-name}@r{]})
@findex dumpdict
識別子辞書の内容を表示します。
文字列 @var{string} は表示する識別子の種類を下に示した記号の列で
表したもので、省略すると @t{"lm"}（すなわちローカルマクロ名と
スレッドマクロ名）になります。 
スレッド名 @var{thread-name} の指定がある場合には、そのスレッドの
辞書に登録されている識別子だけが表示されます。指定のない場合は
すべてのスレッドの識別子が表示されます。スレッド名には
パス @var{thread-path} をつけることができます。

@table @t
@item "l"
ローカルマクロ名
@item "m"
スレッドマクロ名
@item "b"
組み込み関数名
@item "t"
スレッド名
@item "e"
エフェクタクラス名
@item "i"
エフェクタインスタンス名
@item "c"
通信チャネル名
@item "s"
辞書のハッシュに関する統計の表示
@end table

@item @r{BI:} trace(@var{level})
@findex trace
トレースレベルを @var{level} に設定します。
トレースレベルが１であると、関数型マクロの呼びだしが行われた際に、
その引数と展開結果が表示されます。トレースレベルが２であると、
それに加えて変数型マクロの呼びだしと展開結果が表示されます。
トレースレベルが３であると、さらに引数展開についてもその展開結果が
表示されるようになります。

@item @r{BI:} showeffs()
@findex showeffs
現在のスレッドのアタッチされているエフェクタインスタンスの
情報を表示します。
@end table

@c --------------------------------------------------------------------
@node Effectors, Communication, Built-in Functions, Top
@chapter エフェクタ 
@cindex エフェクタ
@cindex アクション

@dfn{エフェクタ} とは、イベント生成コマンドによって出力された各イベントに
対して @dfn{アクション} と呼ばれる手続きを呼びだすことによって、
イベントの修正や統計を取ることを可能にしたソフトウェアモジュールです。
エフェクタという名前は、
電子音楽機器の1つであるMIDIエフェクタに動作が似ていることに因んでいます。

@menu
* Overview of Effectors::       エフェクタの概要。用語の解説。 
* Event Types::                 イベント種別の記述方法とイベントコード
* Defining Effectors::          エフェクタの定義方法 
* Event Actions::               イベントに対するアクションの記述方法 
* Attaching Effectors::         エフェクタをスレッドにアタッチする方法
* Changing Valid Flags::        エフェクタ有効フラグの操作
* Changing Through Bits::       スルービットの操作 
* Undefining Effectors::        エフェクタ定義の取り消し 
* Effector Examples::           いくつかのエフェクタの例 
* Predefined Effectors::        既定義エフェクタ（エフェクタライブラリ）
* Virtual Controllers and Effectors::  仮想コントローラの意味を定義する方法 
@end menu

@node Overview of Effectors, Event Types, Effectors, Effectors
@section エフェクタの概要

エフェクタを操作する具体的なコマンドの説明に入る前に、
エフェクタで使われる用語とエフェクタ使用法の概略について述べます。

@menu
* Effector Class::              エフェクタ定義とエフェクタクラス 
* Effector Instance::           エフェクタのアタッチとエフェクタインスタンス 
* Effector Chain::              複数のエフェクタのアタッチ 
* Inheritance of Attachment::   アタッチされたエフェクタリストの引き継ぎ 
* Through Bits::                スルービットとは？ 
* Effector Valid Flags::        エフェクタ有効フラグとは？ 
@end menu

@node Effector Class, Effector Instance, Overview of Effectors, Overview of Effectors
@subsection エフェクタ定義とエフェクタクラス
@cindex エフェクタクラス

エフェクタを使用するためには、まず、
各イベント種類毎にどんな処理を行うかをコンパイラに知らせるために
エフェクタ定義を行わなければなりません。
エフェクタ定義は @code{defeff} コマンドによって行います。
エフェクタ定義の結果生成される、各イベント種類毎のアクションを記述した
データ構造を @dfn{エフェクタクラス} と呼び、その名前を
エフェクタクラス名と言います。

@node Effector Instance, Effector Chain, Effector Class, Overview of Effectors
@subsection アタッチとエフェクタインスタンス
@cindex エフェクタインスタンス
@cindex アタッチ
@cindex エフェクタスレッド
@cindex ディタッチ

エフェクタを実際に稼働させるためには、定義したエフェクタを
スレッドに @dfn{アタッチ} する必要があります。
アタッチを行うと @dfn{エフェクタインスタンス} と呼ばれるデータ
構造が作られます。エフェクタインスタンスに対して、
必要ならばエフェクタインスタンス名という名前をつけることができます。
各エフェクタインスタンスはイベントを蓄えるためのイベントバッファと、
@dfn{エフェクタスレッド} と呼ばれる独自のスレッドを持ちます。
エフェクタスレッドの親スレッドはアタッチしたときのスレッドです。
エフェクタスレッドのスレッド名はエフェクタインスタンス名と同一です。
エフェクタインスタンス名が与えられていないときは
名前なしスレッドになります。

あるスレッドにエフェクタをアタッチすると、
そのスレッドにおいて生成されたイベントは、
エフェクタインスタンス内に存在するイベントバッファに蓄えられる
ようになります（ただし、全部のイベントが置かれるのではなく、
後で述べるスルービットやエフェクタ有効フラグによって定められる条件が
整ったものだけが置かれます）。

エフェクタをアタッチしたスレッドが消滅するとき、
エフェクタの @dfn{ディタッチ} と呼ばれる処理が行われます。
このディタッチによって、イベントバッファに
蓄えられていたすべてのイベントに対してアクションが呼び出されます。
このとき、アクション内のコマンドはエフェクタスレッドにおいて実行されます。

次の例はオクターブ上の音を追加するエフェクタを定義し、
アタッチした例です。

@example
/* エフェクタ定義 */
defeff(octaver) @{    // octaverはエフェクタクラス名。
   /* ノートイベントのためのアクション */
   case(note) @{
      note(n+=12)&   // オクターブ上の音を追加する。
   @}
@}

/* エフェクタのアタッチ */
octaver()

/* 音符コマンドの実行 */
C D E                // これらはオクターブで演奏される。
@end example

@noindent
最後のC, D, E音の音符コマンドが実行されるとき、これらの音のイベントは
@code{octaver} のエフェクタインスタンスが持つイベントバッファに
蓄えられます。コンパイル処理の最後においてルートスレッドが消滅する段階
になると、このエフェクタがディタッチされ、
それによって、蓄えられていたイベントの各々についてアクションが呼ばれ
１オクターブ上の音のイベントが追加されます。
	
上の例においてエフェクタのアタッチ以降の部分を次のように変更すると
どうなるでしょうか？

@example
C @{octaver() D@} E
@end example

@noindent
結果は、D音だけがオクターブで演奏されることになります。
@code{octaver} エフェクタは
グルーピングコマンド(@pxref{Grouping})によって
生成される子スレッドに対してアタッチされ、このため、
D音のイベントは @code{octaver} インスタンスの
イベントバッファに一旦置かれます。
グルーピングコマンドが終了したとき、
@code{octaver} エフェクタはディタッチされ、
そのときアクションが呼び出されてD音はオクターブになります。
E音を生成するときには、スレッドが元へ戻っていますので、
もはやオクターブにはなりません。
この例は下のように修飾子を使って書いても意味になります。

@example
C D(octaver()) E
@end example

@node Effector Chain, Inheritance of Attachment, Effector Instance, Overview of Effectors
@subsection 複数エフェクタのアタッチと終端エフェクタ
@cindex 複数エフェクタのアタッチ
@cindex 終端エフェクタ

１つのスレッドに対して複数のエフェクタをアタッチすることができます。
このとき、エフェクタのディタッチは、
アタッチした順番とは逆順に、
すなわち最後にアタッチしたものから行われます。
この様子をもう少し詳しく示すと次のようになります。
複数のエフェクタがアタッチされている状態でイベントを生成すると、
そのイベントはひとまず一番最後にアタッチされたエフェクタの
イベントバッファに置かれます。
そして、スレッドが消滅したとき、
まず一番最後にアタッチされたエフェクタのアクションが
各イベントに対して適用されます。
このアクションによって変更を受けたイベント、或はそのアクションによって
新たに生成されたイベントは、最後から２番目にアタッチした
エフェクタのイベントバッファに置かれます。
一番最後にアタッチされたエフェクタのディタッチ処理が完全に終わると、
今度は２番目のエフェクタに対して同様の処理が適用されます。
この過程はアタッチされていたすべてのエフェクタについて繰り返されます。

最後にディタッチされるエフェクタ（つまり、最初にアタッチしたエフェクタ）
は @dfn{終端エフェクタ} と呼ばれます。
PMMLコンパイラはスタートアップファイル(@pxref{Start-up})
の中で @code{$smfout} という終端エフェクタをアタッチします。
@code{$smfout} エフェクタはイベントを標準MIDIファイルへ書き出す
エフェクタであり、PMMLコンパイラが標準MIDIファイルを結果として出力
するのはすべてこの終端エフェクタの効果によるものです。
従って、スタートアップファイルを変更すれば、
標準MIDIファイルへ書き出す代わりに別の動作（例えば、イベント内容を
テキストとして出力するなど）をさせることができます。

現スレッドにアタッチされている
エフェクタインスタンスのリストは @code{showeffs} 組み込み
関数によって調べることができます(@pxref{Debugging})。

下に @code{octaver} と @code{rand_velocity} という２つのエフェクタを
アタッチした例を示します。

@example
/* ベロシティに +-10 の乱数を加えるエフェクタ */
defeff(rand_velocity) @{
   case(note) @{
      v += irand(-10,10)
   @}
@}

/* エフェクタのアタッチ */
rand_velocity()
octaver()      // 前節で定義したエフェクタ

/* 音符コマンドの実行 */
C D E          // これらはオクターブで、かつベロシティーに乱数が
               // 加えられて演奏される。
@end example

@noindent
後にアタッチしたのは @code{octaver} ですので、C, D, E音のイベントは
まず @code{octaver} のイベントバッファに置かれます。
コンパイル処理が最後まで進むと、まず @code{octaver} のディタッチ処理が
行われます。
すなわち、各イベントに対する１オクターブ上の音のイベントが追加され、
元のイベントとともに @code{rand_velocity} のイベントバッファに格納されます。
次に @code{rand_velocity} のディタッチが行われ、
各イベントについてベロシティーに乱数が加えられます。
その結果のイベントは終端エフェクタのイベントバッファに置かれ、
最終的に標準MIDIファイルへ書き出されます。

エフェクタのアタッチの順序には意味があることに注意して下さい。
上の例で @code{octaver} と @code{rand_velocity} の順序を逆にすると、
まずベロシティに乱数が加えられてから１オクターブ上の音が追加
されるため、オクターブで演奏される２つの音は同一ベロシティになります。

@node Inheritance of Attachment, Through Bits, Effector Chain, Overview of Effectors
@subsection アタッチされたエフェクタの引き継ぎ
@cindex アタッチの引き継ぎ

アタッチされているエフェクタのリストはスレッドごとに管理されています。
新しいスレッドが生成されるとき、そのレジスタ内容はスレッド生成コマンドを
実行したスレッド（親スレッド）からコピーされますが、このとき
アタッチされているエフェクタのリストも一緒にコピーされます。
したがって親スレッドにアタッチされているエフェクタは、
新しいスレッドにおいても有効となります。
ただし、新しいスレッドが消滅したときにディタッチされるエフェクタは、
新しいスレッドになってからアタッチされたエフェクタだけであり、
親スレッドから引き継いだエフェクタはディタッチされません。

たとえば下の例では、途中で新しいスレッドを生成していますが、
その前にアタッチされていた @code{volup} エフェクタは、スレッドが
新しくなった後でもまだ有効です。

@example
/* ボリュームを1.5倍するエフェクタ */
defeff(volup) @{
   case(ctrl(7)) @{
      val *= 1.5
   @}
@}

/* エフェクタのアタッチ */
volup()

/* コマンドの実行 */
vol(50)      // エフェクタがかかって実際はvol(75)になる。          
C D 
@{            // 新しいスレッドが生成される。
  octaver()  // volupとoctaverが両方アタッチされた状態になる。
  E          // オクターブで演奏。
  vol(80)    // エフェクタがかかって実際はvol(120)になる。          
  F          // オクターブで演奏。
@}            // octaverはディタッチされ、volupだけがアタッチ
             // された状態に戻る。
G            // オクターブでは演奏されない。
vol(50)      // エフェクタがかかって実際はvol(75)になる。          
             // 最後にvolupがディタッチされる。
@end example

@node Through Bits, Effector Valid Flags, Inheritance of Attachment, Overview of Effectors
@subsection スルービット
@cindex スルービット
@cindex イベントスルービット
@cindex チャネルスルービット

エフェクタは、そのインスタンス毎に、@dfn{スルービット} と呼ばれる
イベントを通過（素通り）させるかどうかを記録したビットベクトルを持っています。
スルービットには以下の２種類があります。

@table @asis
@item イベントスルービット
これはイベントの種類毎に１ビットずつ存在します。
このビットが 1 であると、該当する種類のイベントはエフェクタを通過し、
従ってエフェクタによる影響を受けなくなります。
コントロールチェンジに対しては、各コントローラ番号ごとに
別のビットが割り当てられています。また、ノートオンとノートオフも
別のビットになっています。

@item チャネルスルービット
これはMIDIチャネルごとに１ビットずつ存在します。
このビットが 1 であると、対応するチャネルのイベントはエフェクタを通過し、
従ってエフェクタによる影響を受けなくなります。
これは特定のチャネルに対してだけエフェクタをかけるために使用します。
@end table

エフェクタを通過するイベント、
すなわち上のどちらかのスルービットが１であるイベントは、
エフェクタインスタンスの持つイベントバッファには置かれません。
これによって、当然、そのイベントに対してアクションが適用されることは
ありません。

エクスクルーシブのようにチャネル番号とは関係のないイベントに対しては、
チャネルスルービットは無視されます。つまり、イベントスルービット
だけによって通過か否かが決定されます。

イベントスルービットは、エフェクタがアタッチされたときに
（つまりインスタンスが生成されたときに）、
エフェクタ定義にアクション記述があるものは 0 に設定され、
残りは 1 に設定されます。
例えば、前節の @code{octaver} エフェクタの場合、ノートオンとノートオフ
についてだけイベントスルービットが 0 になり、それ以外では 1 になります。
このため、コントロールチェンジなどのイベントは、
たとえアタッチされていても @code{octaver} のイベントバッファには
置かれません。チャネルスルービットはアタッチされたときに
すべて 0 に設定されます。

スルービットはアタッチ後で任意の値に変更することが可能です。

@node Effector Valid Flags,  , Through Bits, Overview of Effectors
@subsection エフェクタ有効フラグ
@cindex エフェクタ有効フラグ

各スレッドの各エフェクタインスタンスには @dfn{有効フラグ} と呼ばれるビットが
割り当てられています。あるエフェクタインスタンスの
有効フラグが 0 の間は、たとえアタッチされていても
そのエフェクタインスタンスのイベントバッファにイベントは置かれず、
したがってイベント処理は適用されません。
有効フラグの操作は @code{disable} および @code{enable} コマンドによって
行います。
有効フラグは、エフェクタを一時的に無効化するために使われます。

@node Event Types, Defining Effectors, Overview of Effectors, Effectors
@section イベント種別名とイベントコード
@cindex イベント種別名
@cindex インベトコード

イベント種別名はイベントの種類（単独またはその集合）を表した名前です。
また、イベントコードはイベントの各種類を整数で表したものです。これらは、
エフェクタ定義やスルービットの変更において使われます。
以下にイベント種別名とその意味、及びイベントコードを示します。

@table @t
@item note_on
ノートオンイベント。イベントコードは 403 (0x193)。
@item note_off
ノートオフイベント。イベントコードは 402 (0x192)。
@item note
ノートオンとノートオフの両方。
@item ctrl@r{[}(@var{number-list-0-255})@r{]}
拡張コントロールチェンジイベント。
イベントコードは 0 から 255 (0xff)。
@item bend
ピッチベンドイベント。イベントコードは 128 (0x80)。
@item kp
キープレッシャーイベント。イベントコードは 129 (0x81)。
@item cpr
チャネルプレッシャーイベント。イベントコードは 130 (0x82)。
@item prog
プログラムチェンジイベント。イベントコードは 131 (0x83)。
@item tempo
テンポ設定イベント。イベントコードは 192 (0xc0)。
@item excl
エクスクルーシブイベント。イベントコードは 400 (0x190)。
@item arbit
任意メッセージイベント。イベントコードは 401 (0x191)。
@item meta@r{[}(@var{number-list-0-127})@r{]}
テンポ設定を除くメタイベント。イベントコードは 256 (0x100) から 383 (0x17f)。
@item seqno
シーケンス番号イベント。イベントコードは 256 (0x100)。 
@item text@r{[}(@var{number-list-1-15})@r{]}
テキストイベント。イベントコードは 257 (0x101) から 271 (0x10f)。
@item smpte
SMPTEオフセットイベント。イベントコードは 340 (0x154)。
@item timesig
拍子設定イベント。イベントコードは 344 (0x158)。
@item keysig
調号イベント。イベントコードは 345 (0x159)。
@item all
すべての種類のイベント。
@end table

@noindent
上の @var{number-list-m-n} は、コントローラ番号やメタイベント種別番号を
コンマで区切って並べたものです。
@samp{@var{x}-@var{y}} によって
ある範囲内の番号をまとめて指定することもできます。
例えば、@samp{ctrl(1,7-9)} はコントロールチェンジの1,7,8,9番を意味します。
番号は @var{m} 以上 @var{n} 以下でなければなりません。
番号には式を使うことはできませんが、そこでのマクロ呼び出しは可能です。
番号リストを省略すると "すべての" という意味になります。
例えば、@samp{ctrl} はすべての拡張コントロールチェンジを意味します。

一部のコントローラ番号は標準マクロにその値が定義されており、
それを用いれば直接番号を書くよりわかりやすくなります。
定義されている変数型マクロは、@code{Mod}, @code{Breath}, @code{Foot},
@code{Pmtime}, @code{Vol}, @code{Pan}, @code{Expr}, @code{Bend},
@code{Kp}, @code{Cpr}, @code{Vmag}, @code{Tempo}, @code{Ped}, @code{Pm},
@code{Sped} です。例えば、
@code{ctrl(7)} の代わりに @code{ctrl(Vol)} と書くことができます。
各マクロ名の意味については @ref{Control-Change Events} を参照して下さい。

連続コントロールチェンジのイベントは、連続でないものと
同じイベント種別に属し、イベントコードも同じです。

テンポ設定イベントは、標準MIDIファイルにおいてメタイベントの一種として
扱われていますが、PMML内部では拡張コントロールチェンジの
イベントとして扱っているため、メタイベントには含まれません。
このため、@code{meta(0x51)} としてもテンポ設定イベントを指定することは
できません。

イベント種別名からイベントコードへの変換は次のマクロ指令によって
行うことができます。

@table @t
@item @r{MD:} ecode(@var{event-type})
@findex ecode
@end table

@noindent
@code{ecode} はイベント種別名 @var{event-type} のイベントコードを返します。
@var{event-type} は単一のイベント種別を表すものでなければなりません。

@node Defining Effectors, Event Actions, Event Types, Effectors
@section エフェクタの定義
@cindex エフェクタの定義
@findex defeff
@cindex @code{init}アクション定義部
@cindex @code{detach}アクション定義部
@cindex @code{case}アクション定義部
@cindex @code{wrap}アクション定義部
@cindex エフェクタフラグ

エフェクタの定義は @code{defeff} コマンドによって行います。

@table @t
@item @r{C:} defeff(@r{[}@var{scope}@r{]}@var{class-name} @r{[}, @var{arg-spec} @r{[}, @var{flags}@r{]]}) @{ @var{actions} @}
@end table

@noindent
@var{class-name} は定義するエフェクタのエフェクタクラス名です。
通用範囲指定 @var{scope} を省略した場合、@var{class-name} は
現スレッドの識別子辞書に登録されます。
通用範囲指定 @var{scope} によって他のスレッドの辞書に登録すること
も可能です(@pxref{Scope Specifiers})。
ただし @samp{local::} は指定できません。
登録する際に、既に同名のエフェクタクラス名があれば、それを再定義します。
既に同名の他の種類の識別子が登録されている場合にはエラーになります。

引数仕様 @var{arg-spec} はこのエフェクタをアタッチするときに渡す
引数の仕様であり、@code{def} における引数仕様文字列と
同じ形式です(@pxref{Argument Spec})。
アタッチ時に渡された引数は、アクションの中で参照することができます。
参照の方法は、関数型マクロにおける引数参照の場合と
同じです(@pxref{Argument Substitution})。

@var{flags} はエフェクタフラグと呼ばれる整数であり、
その各ビットが次の意味を持っています。

@table @asis
@item 第0ビット
このビットは、
ディタッチする直前に行われるイベントのソート方法を決定します。
これらのビットを示すために、
@code{MergeTracks} という標準マクロが 0x01 に定義されています。

このビットが 0 のときは、トラックごとに時刻順ソートがかけられます。
アクションの呼ばれる順番は、
まずトラック 1 の時刻順に並んだ全イベント、
次にトラック 2 の時刻順に並んだ全イベント、
@dots{} という順番になります。
同一時刻のイベントは、
イベント優先度に従って並べ変えられます(@pxref{Priority})。
優先度も同じ場合は、生成された順番が保たれます。

このビットが 1 の場合（すなわち
エフェクタフラグとして @samp{MergeTracks} を与えた場合）、
イベントバッファ内のすべてのイベントに対してトラック番号とは無関係に
時刻順ソートがかけられます。
同一時刻イベントの扱いは、上と同じです。
アクションの呼ばれる順番はイベントの時刻順であり、
トラック番号は入り交じることになります。

@item 第1ビット 
このビットが 1 であると、ディタッチする直前に
イベントバッファ内にある連続コントロールチェンジのイベントが
個々のコントロールチェンジイベントに展開されます。
なお、このビットを示すために、@code{ExpandCtrl} という標準マクロが 
0x02 に定義されています。
@end table

@noindent
@var{flags} は省略すると 0 になります。	
上に掲げたビット以外を 1 にしてはいけません。

@code{defeff} コマンドの @var{actions} の部分には
エフェクタの処理内容を記述します。
この部分は、それぞれ高々１つの @code{init} アクション定義部、
@code{detach} アクション定義部、@code{wrap} アクション定義部、
そして任意個の @code{case} アクション定義部からなります。
@code{case} 以外のアクション定義部については、どのような順序で記述しても
意味は同じです。しかし、@code{case} アクション定義部どうしの順序関係には
下に述べるように意味があります。
各アクション定義部の形式とその意味は以下の通りです。

@table @t
@item init @{ @var{command} @dots{} @}
@itemx attach @{ @var{command} @dots{} @}
@code{init} アクション定義部です。
上のコマンド列 @var{command} @dots{} は、
@code{init} アクションと呼ばれ、
エフェクタがアタッチされたときに実行されます。
@code{init} アクションにはエフェクタに関する初期化処理を記述します。
@code{init} を @code{attach} に置き換えても意味は変わりません。
@code{init} アクション中で @code{t} レジスタを参照すると
アタッチしたときの時刻が得られます。

@item detach @{ @var{command} @dots{} @}
@code{detach} アクション定義部です。
上のコマンド列 @var{command} @dots{} は、
@code{detach} アクションと呼ばれ、
このエフェクタがディタッチされたときに各イベントの処理に先だって、
エフェクタフラグを設定した時に行われる
時刻順ソートや連続コントロールチェンジの展開の直後に実行されます。
@code{detach} アクション中で @code{t} レジスタを参照すると
ディタッチしたときの時刻が得られます。

@item case(@var{event-type}, @dots{}) @{ @var{command} @dots{} @}
@code{case} アクション定義部です。
上のコマンド列 @var{command} @dots{} は、
イベントアクションと呼ばれ、
イベント種別名 @var{event-type} (@pxref{Event Types}) で示される
種類の各イベントに対して実行されます。
イベント種別名はコンマで区切って複数指定することもできます。
なお、同じイベント種別に対して２つ以上のアクションが存在する場合は、
先に書いた方のアクションだけが実行されます。
イベントアクションの記述方法については次節を参照して下さい。

@item wrap @{ @var{command} @dots{} @}
@code{wrap} アクション定義部です。
上のコマンド列 @var{command} @dots{} は、
@code{warp} アクションと呼ばれ、
すべてのイベント処理を終えた一番最後に実行されます。
例えばイベントの集計結果を出力するような処理を記述します。
@end table

@node Event Actions, Attaching Effectors, Defining Effectors, Effectors
@section イベントアクション
@cindex イベントアクション
@findex reject
@findex etype
@findex val
@findex ctype

イベントアクションは、各イベントに対して実行されるコマンド列です。

各アクションが呼ばれる前に、まず
下に示したレジスタ（エフェクタスレッドのレジスタ）や
変数型マクロ（エフェクタスレッドのスレッドマクロ）の
うちのいくつかが自動的に設定されます。	
どのレジスタやマクロが設定されるかは、イベントの種別により異なります。

@table @asis
@item @code{t} レジスタ
イベントの発生時刻
@item @code{tk} レジスタ
トラック番号
@item @code{ch} レジスタ
MIDIチャネル番号
@item @code{n} レジスタ
ノート番号
@item @code{v} レジスタ
ベロシティー
@item @code{nv} レジスタ
ノートオフベロシティー
@item @code{do} レジスタ
ノートオンとノートオフの時間差
@item @code{dp} レジスタ
常に 0
@item @code{etype} マクロ
イベントコード(@pxref{Event Types})
@item @code{val} マクロ
拡張コントロールチェンジイベントの場合は、コントロール値。
エクスクルーシブまたは任意メッセージイベントの場合は、データの配列。
メタイベントの場合は、データの値（整数、文字列または配列）。
@item @code{ctype} マクロ
連続コントロールチェンジイベントの場合、
@code{ctrl_to} では 1、@code{ctrl_cto} では 2、@code{ctrl_pt} では 3 となる。
通常のコントロールチェンジの場合は 0。
@end table

なお、@code{dt} レジスタは、アタッチのときに 0 にクリア
されます(@pxref{Attaching Effectors})。

アクションの中では、どんな種類のコマンドを実行することもできます。
よく行われる操作には、上のレジスタを書き換えたり、
別のイベントを生成したりすることなどが挙げられます。
アクションの中で @samp{$} で始まる引数参照を使うと、
アタッチ時に与えられた引数を参照することができます。

アクションの実行が終了すると、イベントバッファからのイベントと
同じ種類のイベントが自動的に出力されます。
アクションが空の場合には、イベントバッファからのイベントが
そのまま出力されます。アクション内において上のレジスタやマクロを
変更すると、それを反映するようにイベントが修正されて出力されます。
イベントの自動出力を抑制したい場合には、アクションの中で
次の @code{reject} というコマンドを実行します。
@code{reject} はイベントバッファからのイベントとは違う種類の
イベントを出力する場合に利用できます。

@table @t
@item @r{C:} reject
@end table

@noindent
各イベント種別ごとのアクションの動作は以下の通りです。

@subheading ノートイベントの場合
@findex REST

イベントバッファからのイベントの種類がノートオン/オフである場合、
@code{case} への引数が、@code{note} であるか、
或は @code{note_on} または @code{note_off} であるかによって
アクションの動作が変わってきます。

@code{case(note)} の場合、ノートオンとノートオフのペアに対して
アクションが呼ばれます。時刻順ソートがかかっている場合、それは
ノートオン時刻に対するソートを意味しています。
設定されるレジスタ／マクロは
@code{t}, @code{tk}, @code{ch}, @code{n}, @code{v}, @code{nv}, 
@code{do}, @code{dp}, @code{etype} です。
@code{t} はノートオンの時刻です。ノートオフの
時刻は (@code{t} + @code{du}) で計算できます。
アクション終了時には、
ノートオンとノートオフの両方が出力されます。@code{etype} 以外の
レジスタ／マクロを変更すると、それは出力される２つのイベントに反映されます。
@code{n} レジスタの値を休符を表す @code{REST}（これは 0x80000000 に
定義されている
標準マクロです）に変更したときは、イベントの出力が抑制されます。

一方、@code{case(note_on)} または @code{case(note_off)} の場合、
ノートオンまたはノートオフのそれぞれに対してアクションが実行されます。
設定されるレジスタ／マクロは
@code{t}、@code{tk}、@code{ch}、@code{n}、@code{v}（ノートオンの場合のみ）、
@code{nv}（ノートオフの場合のみ）、
@code{etype} であり、@code{do}, @code{dp} レジスタはセットされません。
アクション終了時には、ノートオンまたはノートオフの１つのイベントが
出力されます。@code{etype} 以外のレジスタ／マクロの更新は有効です。
@code{n} レジスタを @code{REST} に変更するとイベントの出力は抑制されます。

@code{case(note_on, note_off)} と @code{case(note)} は異なることに
注意して下さい。
１つのノートオン/オフのペアに対して、前者では２回アクションが
呼ばれるのに対し、後者は１回のアクションが呼ばれるだけです。

@subheading 拡張コントロールチェンジの場合

イベントバッファからのイベントの種類が
拡張コントロールチェンジ／連続コントロールチェンジであった場合、
設定されるレジスタ／マクロは
@code{t}、@code{tk}、@code{ch}（コントロール番号が192以上のときは
不定値）、@code{n}（キープレッシャーの場合のみ）、
@code{etype}、@code{val}、@code{ctype} です。
コントローラ番号は @code{etype} が保持しています。
イベントを修正するために、上の @code{ctype} 以外の
どのレジスタ／マクロも変更することが
できます。@code{etype} を変更すれば、コントローラ番号を変えることが
できますが、コントロールチェンジ以外のイベントコード（つまり256以上）
に変更することはできません。
同様に、@code{ch} や @code{n} を
参照するコントロールチェンジに変更した場合には、これらの
レジスタを正しい値に設定する必要があります。

コントロールチェンジのためのアクションの中では、通常のコマンドに加えて、
次のコマンドを実行することができます。

@table @t
@item @r{C:} ctrl_any(@var{ctrl-num}, @var{value}) @r{[}@var{modifiers}@r{]} 
@findex ctrl_any
@end table

@code{ctrl_any} は、イベントバッファからのイベントが
連続でないコントロールチェンジであった場合、@code{ctrl} コマンドと
全く同じ働きをします。イベントバッファからのイベントが
連続コントロールチェンジであった場合には、その種類に従って、
@code{ctrl_to}、@code{ctrl_pt}、@code{ctrl_cto} のうちの
いずれかと同じ働きをします。
@code{ctrl_to} 及び @code{ctrl_cto} コマンドの第３引数以降で指定すべき値
については、イベントバッファからのイベントが持つ値と同じものが仮定されます。

@subheading エクスクルーシブの場合

イベントバッファからのイベントが
エクスクルーシブまたは任意メッセージであった場合には、
@code{t}、@code{tk}、@code{etype}、@code{val} が設定されます。
@code{val} はメッセージデータの配列になります。@code{excl} コマンドで
エクスクルーシブイベントを生成した場合には、この配列の最後には
0xf7 が付加されています。@code{excl2} あるいは @code{arbit} で
生成されたイベントの場合は、引数で指定したデータ配列そのままです。
イベントを修正するために、
@code{t}、@code{tk}、及び @code{val} を変更することができます。
 
@subheading メタイベントの場合

イベントバッファからのイベントがメタイベントであった場合には、
@code{t}、@code{tk}、@code{etype}、@code{val} が設定されます。
@code{etype} から256を引いた値がメタイベント種別番号になります。
@code{val} は、
@code{case(seqno)} によってシーケンス番号のイベントを指定した場合には
整数になり、
@code{case(text(@dots{}))} によってテキストイベントを指定した
場合には文字列になり、
それ以外のメタイベント場合、あるいは上の２種類であっても
@code{case(meta(@dots{}))}によってイベント種別を指定した場合には、
データの配列になります。
イベントを修正するために、
@code{t}、@code{tk}、及び @code{val} を変更することができますが、
@code{val} の型を変更することはできません。

@subheading まとめ

下の表は、各イベント種別において設定されるレジスタ／マクロをまとめたものです。
@code{rw} は設定されしかも変更可能であるもの、
@code{ro} は設定はされるが変更は不可能なものを表しています。

@example
Event Type  |   t   tk  ch   n   v  nv  do/dp  etype  val  ctype
------------+----------------------------------------------------
note        |   rw  rw  rw  rw  rw  rw    rw    ro         
note_on     |   rw  rw  rw  rw  rw              ro         
note_off    |   rw  rw  rw  rw      rw          ro         
ctrl        |   rw  rw (rw)(rw)                 rw    rw    ro 
excl,arbit  |   rw  rw                          ro    rw    
meta        |   rw  rw                          ro    rw   
@end example

@node Attaching Effectors, Changing Valid Flags, Event Actions, Effectors
@section エフェクタのアタッチ
@cindex エフェクタのアタッチ
@findex attach

アタッチには次の２通りの方法があります。

@table @t
@item @r{C:} @r{[}@var{scope}@r{]}@var{class-name}(@var{argument}, @dots{})
@item @r{C:} attach(@r{[}@var{scope}@r{]}@var{class-name}(@var{argument}, @dots{}), @var{instance-name} @r{[}, @var{enable}@r{]})
@end table

@var{class-name} はアタッチするエフェクタのクラス名です。
@var{class-name} が現スレッドまたはその先祖スレッドの識別子辞書に
登録されていれば、通用範囲指定 @var{scope} を省略できます。
それ以外の場合は通用範囲指定が必要です(@pxref{Scope Specifiers})。

@var{argument} はアクションへ渡す引数です。

第１の形式の場合、無名のエフェクタインスタンスが作成されます。
第２の形式の場合、@var{instance-name} がエフェクタインスタンスの名前に
なります。
エフェクタインスタンス名は、
同じクラスのエフェクタをパラメータを変えて
２つ以上アタッチする場合において、どちらかを区別するのに役立ちます。
@var{instance-name} は現スレッドの辞書に登録されます。
インスタンス名に対して通用範囲指定をつけることはできません。

第２の形式における @var{enable} はエフェクタ有効フラグの初期値です。
0 または 1 を指定します。省略した場合、あるいは第１の形式の場合は、
エフェクタ有効フラグの初期値は 1 になります。

エフェクタをアタッチするとエフェクタスレッドが生成されますが、
そのときエフェクタスレッドの @code{dt} レジスタは
0 にクリアされます。それ以外のレジスタの値は現スレッドのものが
引き継がれます。

@node Changing Valid Flags, Changing Through Bits, Attaching Effectors, Effectors
@section エフェクタ有効フラグの変更
@cindex エフェクタ有効フラグの変更
@findex enable
@findex disable

@code{enable} はエフェクタ有効フラグ(@pxref{Effector Valid Flags})を
セット、@code{disable} はリセットするコマンドです。

@table @t
@item @r{C:} enable(@r{[}@var{scope}@r{]}@var{effector})
@item @r{C:} disable(@r{[}@var{scope}@r{]}@var{effector})
@end table

@var{effector} はエフェクタクラス名とエフェクタインスタンス名の
どちらでも構いません。
エフェクタクラス名の場合は、
現在のスレッドにアタッチされているエフェクタのうち、
指定したエフェクタクラスに属するすべてのインスタンスに対して
有効フラグの変更が行われます。インスタンス名の場合は、
特定のインスタンスだけに対して有効フラグの変更が行われます。
クラス名、インスタンス名にかかわらず、
現スレッドまたはその先祖スレッドの識別子辞書にそれが
登録されていれば通用範囲指定 @var{scope} を省略できます。
それ以外の場合は通用範囲指定が必要です(@pxref{Scope Specifiers})。

エフェクタインスタンスに対する有効フラグのセットは
次のようにエフェクタインスタンス名だけで行うこともできます。

@table @t
@item @r{C:} @r{[}@var{scope}@r{]}@var{instance-name}
これは @code{enable(@r{[}@var{scope}@r{]}@var{instance-name})} と同じです。
@end table

有効フラグの操作は、アタッチやディタッチをするより
ずっと高速に行えます。
従って、同じエフェクタを離れた多数の箇所で利用する場合には、
最初に有効フラグを 0 にしてアタッチしておいて、必要な時だけ
有効フラグを 1 にする方が、その都度アタッチし直すよりも効率的です。

エフェクタ有効フラグは、
各スレッドの各エフェクタインスタンス毎に存在します。
したがって、スレッドが元へ戻ると、有効フラグの状態も
元へ戻ります。下の例を参照して下さい。

@example
octave()    // octave エフェクタのアタッチ 
C D E 
@{ disable(octave) F G @}    // F,G音には octave がかからない。
A          // このA音には octave がかかる。
@end example

@node Changing Through Bits, Undefining Effectors, Changing Valid Flags, Effectors
@section スルービットの変更
@cindex スルービットの変更

エフェクタのスルービット(@pxref{Through Bits})を
変更するコマンドには以下のものがあります。
各コマンドの第１引数である @var{effector} は、
エフェクタクラス名またはエフェクタインスタンス名のどちらでも良く、
またエフェクタ定義の @code{init} アクションの中でこれらのコマンドを
実行する場合には省略することができます。
@var{effector} がエフェクタクラス名の場合は、
現在のスレッドにアタッチされているエフェクタのうち、
指定したエフェクタクラスに属するすべてのインスタンスに対して
スルービットの変更が行われます。インスタンス名の場合は、
特定のインスタンスだけに対してスルービットの変更が行われます。
@var{effector} を省略した場合には、
現在アタッチしている最中のエフェクタに対してスルービットの変更が行われます。

@table @t
@item @r{C:} set_thru_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex set_thru_etypes
指定されたイベント種別のイベントスルービットを 1 にし、
残りを 0 に変更します。
イベント種別については @ref{Event Types} を参照して下さい。

@item @r{C:} set_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex set_eff_etypes
指定されたイベント種別のイベントスルービットを 0 にし、
残りを 1 に変更します。

@item @r{C:} add_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex add_eff_etypes
指定されたイベント種別のイベントスルービットを 0 に変更し、
残りはそのままの状態を保ちます。

@item @r{C:} del_eff_etypes(@r{[}@var{effector}@r{]})(@var{event-type}, @dots{})
@findex del_eff_etypes
指定されたイベント種別のイベントスルービットを 1 に変更し、
残りはそのままの状態を保ちます。

@item @r{C:} set_thru_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex set_thru_chs
指定されたMIDIチャネルについて
チャネルスルービットを 1 にし、残りを 0 に変更します。
MIDIチャネル番号の指定には、
ある範囲内の番号をまとめて指定する @samp{-} が使えます。
チャネル番号に式を使うことはできませんが、
そこでのマクロ呼び出しは可能です。

@item @r{C:} set_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex set_eff_chs
指定されたMIDIチャネルについて
チャネルスルービットを 0 にし、残りを 1 に変更します。

@item @r{C:} add_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex add_eff_chs
指定されたMIDIチャネルについて
チャネルスルービットを 0 に変更し、残りはそのままの状態を保ちます。

@item @r{C:} del_eff_chs(@r{[}@var{effector}@r{]})(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex del_eff_chs
指定されたMIDIチャネルについて
チャネルスルービットを 1 に変更し、残りはそのままの状態を保ちます。
@end table

@ref{Through Bits} で述べたように、イベントスルービットは、
エフェクタがアタッチされたとき、
エフェクタ定義にアクション記述があるものは 0 に、
ないものは 1 に設定されます。
アクション記述があるものに対して、イベントスルービットを 1 に
変更すると、そのアクションは適用されなくなります。
逆に、アクション記述がないものに対して、イベントスルービットを 0 に
変更すると、そのイベントは削除されます。

下の例は特定の種類のイベントを削除するエフェクタです。

@example
/* 引数で与えられた種類のイベントを除去するエフェクタ */
defeff(reject_events) @{ 
  init @{
    set_eff_etypes()($@@)
  @}
  case(all) @{  
    reject
  @}
@}

reject_events(excl, arbit) // エクスクルーシブを除去する
@end example

@noindent
上の例における、

@example
  case(all) @{  
    reject
  @}
@end example

@noindent
の部分はわかりやすいように入れてありますが、
無くても全く同じように動作します。

特定のMIDIチャネルのイベントだけを抽出するエフェクタを作るには、
下のように、
チャネルスルービットを設定するとともに、
@code{set_eff_etypes} によって
MIDIチャネル番号を参照するイベントに対してスルービットを 0 にします。
@code{set_eff_etypes} がないと、
すべてのイベント種別について無条件にスルーとなるため、
チャネルスルービットが意味を持たなくなってしまいます。

@example
/* チャネル1以外のイベントを除去するエフェクタ */
defeff(chan1only) @{
  init @{
    set_thru_chs()(1)
    set_eff_etypes()(note, ctrl(0-191))
  @}
@}
@end example

@node Undefining Effectors, Effector Examples, Changing Through Bits, Effectors
@section エフェクタ定義の取り消し
@cindex エフェクタ定義の取り消し
@findex undef

マクロ定義を取り消すための @code{undef} マクロ指令は、
エフェクタ定義を取り消すためにも使用できます。

@table @t
@item @r{MD:} undef(@r{[}@var{scope}@r{]}@var{effector})
@end table

@var{scope} は通用範囲を指定する
ためもので省略可能です(@pxref{Scope Specifiers})。
@var{effector} はエフェクタのクラス名またはインスタンス名です。
クラス名の場合は、エフェクタ定義が取り消されます。
インスタンス名の場合は、その
エフェクタインスタンスが無名のインスタンスに変わります。
@code{undef} によってエフェクタをディタッチすることはできません。

@node Effector Examples, Predefined Effectors, Undefining Effectors, Effectors
@section エフェクタ定義の例
@cindex エフェクタ定義の例

@subheading タイムストレッチャ
@cindex タイムストレッチャ

下のエフェクタは、アタッチされた時の時刻を基準に、
それとの時間差を拡大・縮小します。
拡大率はアタッチのとき引数で指定します。

@example
defeff(time_stretch, "n") @{
  init @{
    $attach_time = t
  @}
  case(all) @{
    t = (t - $attach_time) * $1 + $attach_time
  @}
@}
@end example

@subheading アルペジオエフェクタ
@cindex アルペジオエフェクタ

このエフェクタをアタッチすると、和音の各構成音が
時間的にずれて演奏されます。ずらす時間を引数で指定します。
和音を検出するのために、一つ前の音符と同じ発音時刻か
どうかをチェックしている点に注目して下さい。

@example
defeff(arpeggio, "r") @{
  init @{
    $previous_time = -1u
  @}
  case(note) @{
    if( $previous_time != t ) @{
       $delay = 0
    @} else @{
       $delay += $1
    @}
    $previous_time = t
    t += $delay
    du -= $delay
  @}
@}
@end example

@subheading イベントの間引きを行うエフェクタ
@cindex イベントの間引き

MIDIの通信量を減らすために、あまりコントロール値の
変わらないコントロールチェンジは１つにまとめてしまうことが
よく行われます。
下のエフェクタは、ボリュームコントロールについて、
以前に出力したイベントのコントロール値と
現在のコントロール値との差が引数で指定された値以上に
なるまで、コントロールチェンジのイベントを削除します。
削除には @code{reject} コマンドを使っています。
なお、このエフェクタは１つのトラックには１つのMIDIチャネル
しか含まれていないことを仮定してます。

@example
defeff(thin_volume, "n") @{
  init @{
    $prev_val = -10000
  @}
  case(ctrl(Vol)) @{
    if( abs(val - $prev_val) >= $1 ) @{ 
       $prev_val = val
    @} else @{
      reject
    @}
  @}
@}
@end example

@node Predefined Effectors, Virtual Controllers and Effectors, Effector Examples, Effectors
@section 既定義エフェクタ
@cindex 既定義エフェクタ
@cindex 組み込みエフェクタ
@cindex 標準エフェクタ

システムによって予め用意されているエフェクタクラスを既定義エフェクタと
呼びます。既定義エフェクタには、コンパイラに組み込まれている
組み込みエフェクタ（@samp{BE:} と表示されています）と
スタートアップファイルの中で定義されている
標準エフェクタ（@samp{SE:} と表示されています）の２種類があります。
下に既定義エフェクタのリストを示します。

@table @t
@item @r{SE:} modify_notes(@var{command} @dots{})
@findex modify_notes
各音符に対してイベントアクション @var{command} @dots{} を適用すること
によって、音符の属性などを修正します。
例えば、 @code{modify_notes(v+=20)} は各音符のベロシティを 20 増やし、
@code{modify_notes(du*=0.8)} は各音符の持続時間を 80% に削減します。

@item @r{SE:} add_notes(@var{command} @dots{}, @var{command} @dots{}, @dots{})
@findex add_notes
各音符に対して新しい音符群を追加します。
追加する各音符について１つの引数を指定し、そこには
追加する音符に対する修飾子の内容を書きます。
例えば、@code{add_notes(n+=12 v-=20)} は各音符に対してベロシティを 20 減じた
オクターブ上の音を追加し、
@code{add_notes(n+=4, n+=7)} は各音符を基音とする長三和音を構成します。

@item @r{SE:} modify_ctrl(@var{ctrl-num}, @var{command} @dots{})
@findex modify_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベントに
対してイベントアクション @var{command} @dots{} を適用します。
例えば、@code{modify_ctrl(7, val*=1.2)} は、連続コントロールチェンジを
含む各ボリュームコントロールに対して、そのコントロール値を 1.2 倍します。

@item @r{SE:} sel_events(@var{event-type}, @dots{})
@findex sel_events
指定されたイベント種別のイベントだけを残して、あとを削除します。
イベント種別については @ref{Event Types} を御覧下さい。

@item @r{SE:} rej_events(@var{event-type}, @dots{})
@findex rej_events
指定されたイベント種別のイベントを削除します。
例えば、@code{rej_events(excl)} はエクスクルーシブイベントを取り除きます。

@item @r{SE:} sel_chs(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex sel_chs
指定されたMIDIチャネル以外のイベントを削除します。
MIDIチャネルに関係のないイベントは削除されません。
MIDIチャネルの指定法は @code{thru_chs} コマンドと
同じです(@pxref{Changing Through Bits})。

@item @r{SE:} rej_chs(@var{channel}@r{[}-@var{channel}@r{]}, @dots{})
@findex rej_chs
指定されたMIDIチャネルのイベントを削除します。
MIDIチャネルの指定法は @code{thru_chs} コマンドと
同じです(@pxref{Changing Through Bits})。

@item @r{SE:} tr_chs(@var{from1}, @var{to1}, @var{from2}, @var{to2}, @dots{})
@findex tr_chs
MIDIチャネルの置換を行います。
イベント中のMIDIチャネル @var{fromX} は @var{toX}（@var{X} = 1, 2, @dots{}) に
置き換えられます。

@item @r{SE:} remap_chs(@var{ch1}, @var{ch2}, @dots{}, @var{ch16})
@findex remap_chs
MIDIチャネルの一斉置換を行います。
イベント中のMIDIチャネル @var{X} は @var{X} 番めの引数で示される
MIDIチャネルに置き換わります。

@item @r{SE:} tr_prog(@var{from1}, @var{to1}, @var{from2}, @var{to2}, @dots{})
@findex tr_prog
プログラムチェンジのイベントに対してプログラム番号の置換を行います。
プログラム番号 @var{fromX} は @var{toX}（@var{X} = 1, 2, @dots{}) に
置き換えられます。

@item @r{SE:} tstretch(@var{rate})
@findex tstretch
アタッチしたときの時刻の基準として、
そこから各イベントまでの時間差を @var{rate} 倍に引き延ばします。

@item @r{SE:} swing(@var{period}, @var{percentage})
@findex swing
アタッチしたときの時刻から始まる周期 @var{period} の各時間区間について、
周期を２等分した時刻が周期の @var{percentage} パーセントの時刻に移るように
線形の時間変換を行います。
例えば、@code{swing(q,75)} は２つの８分音符が付点8分音符と16分音符に
なるように時間変換を行い、@code{swing(h,66)} は２つの４分音符が
三連符のうちの４分音符と８分音符になるように時間変換を行います（
66/100 は 1/3 に一致しませんので、正確には三連符ではありません。
正確な三連符が必要なときは
有理数を用いて @code{swing(h, 200u/3))} と指定します。）

@item @r{SE:} arp(@var{delay-step})
@findex arp
和音がアルペジオで演奏されるように、
ノートオン時刻が同一の音符のそれぞれに対して、
0, @var{delay-step}, @var{delay-step} * 2, @var{delay-step} * 3, @dots{}
という値をノートオン時刻へ加えます。
ノートオフ時刻は変わりません。
例えば、@code{arp(s)} をアタッチした状態で @code{[c e g]} を演奏すると、
E音は16分音符の長さ、G音は８分音符の長さだけ遅れて発音されます。
アルペジオ演奏の順序を逆にしたい場合には、@code{[g e c]} のように
和音を逆順で書きます。

@item @r{SE:} rand_vel(@var{amplitude})
@itemx @r{SE:} fgrand_vel(@var{amplitude})
@findex rand_vel
@findex fgrand_vel
各音符のベロシティに、@minus{}@var{amplitude} から @var{amplitude} までの
範囲にある乱数を加えます。
@code{rand_vel} は白色雑音、
@code{fgrand_vel} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。

@item @r{SE:} rand_ntime(@var{amplitude})
@itemx @r{SE:} fgrand_ntime(@var{amplitude})
@findex rand_ntime
@findex fgrand_ntime
各音符のノートオンとノートオフの時刻に対して
@minus{}@var{amplitude} から @var{amplitude} までの範囲の乱数を加えます。
@code{rand_ntime} は白色雑音、
@code{fgrand_ntime} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。
コントロールチェンジなど他のイベントの時刻はそのままですので、
このエフェクタによって各音符の属性が変わってしまう可能性があります。

@item @r{SE:} rand_ctrl(@var{ctrl-num}, @var{amplitude})
@itemx @r{SE:} fgrand_ctrl(@var{ctrl-num}, @var{amplitude})
@findex rand_ctrl
@findex fgrand_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベント
に対して、そのコントロール値に
@minus{}@var{amplitude} から @var{amplitude} までの範囲の乱数を加えます。
連続コントロールチェンジの場合には、
個々のコントロールチェンジイベントに直されてから乱数が加えられます。
@code{rand_ctrl} は白色雑音、
@code{fgrand_ctrl} は 1/f 雑音
（@ref{Random Number Generators} の @code{fgrand} の項参照）を加えます。

@item @r{SE:} dump()
@findex dump
イベントの内容をテキストとして出力します。

@item @r{SE:} auto_accent(@var{period}, @var{accent1}, @var{accent2}, @dots{})
@findex auto_accent
音符に一定のリズムにしたがって自動的にアクセントをつけます。
アタッチしたときの時刻から始まる
周期 @var{period} ごとに区切った時間区間を考え、
各音符について、それがある時間区間の先頭から発音が始まっている場合、
或は１つ前の時間区間の先頭以外で発音されいてそれが次の時間区画まで
持続している場合（これはシンコペーションの場合に相当する）に
その音符のベロシティーを増加させます。
増加されるベロシティーの大きさは第２引数以降で表され、
２つ以上指定されている場合には、各時間区画ごとに巡回的にそれらが
使用されます。
例えば、@code{auto_accent(h,40,20)} は 4/4 拍子における各小節の
１拍目にある音符のベロシティーを 40 増やし、３拍目にある音符の
ベロシティーを 20 増やします。

@item @r{SE:} roll(@var{assignments})
@findex roll
パーカッションでのロール奏法やストリングスでのトレモロ奏法を実現するように
音符を短い音符の列に分割します。和音の場合は、
分割された短い音符のそれぞれがすべての音を含む和音になります。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item speed = @var{speed}
分割された音符間の間隔を指定します。
デフォルト値は @code{z} つまり32分音符です。

@item attack = @var{velocity-increment}
最初の音符だけに特別に与えられるベロシティー増加値を指定します。
デフォルト値は 30 です。

@item decay = @var{decay-factor}
ベロシティーの減衰率を指定します。
分割された各音符のベロシティーは１つ前の音符のベロシティーに
この減衰率を乗じたものになります。デフォルト値は 0.9 です。

@item sustain = @var{sustain-level}
ベロシティーの下限値を指定します。
ベロシティーが減衰して @var{sustain-level} 以下になった場合には、
@var{sustain-level} にベロシティーが修正されます。
@var{sustain-level} が 0 の場合は、
次項の @var{relative-sustain-level} によって下限値が決定されます。 
@var{sustain-level} のデフォルトは 0 です。

@item rsustain = @var{relative-sustain-level}
ベロシティーの下限値を元の音符のベロシティーに対する相対値で
指定します。すなわち、元の音符のベロシティーにこの値を乗じたものが、
下限値として使用されます。この指定が有効なのは、
前項の @var{sustain-level} が 0 のときだけです。
@var{relative-sustain-level} のデフォルトは 0.7 です。

@end table

@noindent
上のデフォルト値はそれぞれ @code{roll_speed}, @code{roll_attach},
@code{roll_decay}, @code{roll_sustain}, @code{roll_rsustain} という
グローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@noindent
@code{roll} の使用例:

@table @code
@item roll()
すべてデフォルトの設定で音符を分割します。
@item roll(speed=z/2)
分割の間隔を64分音符にして音符を分割します。
@item roll(attack=0 decay=0)
一定のベロシティで音符を分割します。
@end table

@item @r{SE:} tremolo(@var{assignments})
@findex tremolo
ピアノやマリンバにおけるトレモロ奏法を実現するように
音符を短い音符の列に分割します。和音の場合は、その構成音が２つのグループ
に分けられ、各グループが交互に演奏されます。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item speed = @var{speed}
@itemx attack = @var{velocity-increment}
@itemx decay = @var{decay-factor}
@itemx sustain = @var{sustain-level}
@itemx rsustain = @var{relative-sustain-level}
これらの意味は上記の @code{roll} エフェクタと同じです。
ただしデフォルト値は異なり、
@code{speed=z attack=0 decay=1.0 sustain=0 rsustain=1.0} です。

@item group = @var{number-of-notes}
これは和音の構成音をグループ分けするときの分け方を決定します。
交互に演奏される音符群のうち先に演奏される方を第１グループ、
後から演奏される方を第２グループとしたとき、
和音の構成音のうち最後の @var{number-of-notes} 個が第２グループになり、
残りが第１グループになります。
デフォルトの @var{number-of-notes} の値は 1 です。      
例えば、デフォルトの設定では @samp{[C E G]} は 
@samp{[C E] G [C E] G @dots{}} と演奏されますが、@code{group} を 2 に
設定すれば @samp{C [E G] C [E G] @dots{}} と演奏されるようになります。
@end table

@noindent
上のデフォルト値はそれぞれ @code{tremolo_speed}, @code{tremolo_attach}, 
@code{tremolo_decay}, @code{tremolo_sustain}, @code{tremolo_rsustain},
@code{tremolo_group} というグローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@item @r{SE:} thin_ctrl(@var{ctrl-num}, @var{value-step})
@findex thin_ctrl
コントローラ番号 @var{ctrl-num} の拡張コントロールチェンジイベント
に対して、隣合うコントロール値の差が @var{value-step} 以上になるように
イベントを間引きます。

@item @r{SE:} quantize(@var{step} @r{[}, @var{assignments}@r{]})
@findex quantize
アタッチしたときの時刻を基準として計った
各イベントの時刻を、@var{step} の倍数に
なる（あるはそれに近づく）ように修正します。
@var{assignments} は次に示す代入コマンドを０個以上並べたものです。

@table @code
@item etype = '@var{event-type}, @dots{}'
時刻修正を行うイベントの種類を指定します。
イベント種別名(@pxref{Event Types})のリストをシングルクオートで囲んで
下さい。
デフォルト値は @code{'note'} です。

@item strength = @var{strength}
時刻修正の強さを指定します。
この値が 100 であると、結果として得られる時刻が
ちょうど @var{step} の倍数になるように、時刻に修正値が加えられます。
100 未満の場合は、その修正値が @var{strength}% に軽減されます。
デフォルト値は 100 です。

@item window = @var{window-width}
時刻修正が適用される範囲を指定します。
時刻修正は、修正前時刻とそれに最も近い @var{step} の倍数との差が
@var{step} * @var{window-width}/100 未満であるときだけ行われ、
それ以外の場合はもとの時刻が保たれます。
デフォルト値は 100 です。

@item keepdur = 0 または 1
@code{keepdur} が 0 のときは、ノートオフイベントについても
ノートオンイベントと同じようにして時刻修正が行われます。
@code{keepdur} が 1 のときは、
音符の持続時間が変わらないようにノートオフイベントの時刻を
ノートオン時刻に合わせて修正します。
デフォルト値は 1 です。
@end table

@noindent
例えば、すべての種類のイベントに対して16分音符でのクオンタイズをかける
には @code{quantize(s, etype='all')} とします。
上のデフォルト値はそれぞれ @code{quantize_etype}, @code{quantize_strength}, 
@code{quantize_window}, @code{quantize_keepdur} という
グローバルの変数型マクロに
記録されおり、これらを再定義すればデフォルト値を変更することが可能です。

@item @r{BE:} $smfout(@var{filename}, @var{resolution}, @var{format}, @var{R}, @var{d}, @var{n}, @var{chmask}, @var{trklist} @r{[}, @var{begin}@r{[}, @var{end}@r{]]})
@findex $smfout
イベントを標準MIDIファイルへ書き出します。
このエフェクタは終端エフェクタ(@pxref{Effector Chain})として
スタートアップファイルにおいてアタッチされます。
@var{filename} はMIDIファイル名であり、
拡張子を省略すると @samp{.mid} が補われます。
@var{resolution}、@var{format} はMIDIファイルの分解能とフォーマットです。
@var{resolution} には 0 を指定することもでき、その場合の分解能は、
ソーステキストの終わりまでに @code{load} または @code{loadtrk} コマンドが
実行されていれば読んだMIDIファイルの分解能の最大値、実行されていなければ
480 になります。
また、@var{format} には @minus{}1 を指定することができ、
その場合のフォーマットは、最終的に第１トラックだけにしかイベントが
生成されなかったときは format 0、それ以外で format 1 になります。
@var{R}, @var{d}, @var{n} はいずれも
0 または 1 の整数であり、1 のときそれぞれ @samp{-R}, @samp{-d}, 
@samp{-n} オプションを指定したのと同じ効果が得られます(@pxref{Options})。
@var{chmask} はチャネルスルービットの値であり、16ビット整数で
最下位ビットがMIDIチャネル 1 に対応します。
@var{trklist}, @var{begin}, @var{end} はどれも文字列であり、
それぞれ @samp{-T}, @samp{-f}, @samp{-t} オプションの
引数を表します(@pxref{Options})。
空文字列をこれらのオプション指定しないのと同じ効果があります。
@end table

@node Virtual Controllers and Effectors,  , Predefined Effectors, Effectors
@section 仮想コントローラとエフェクタ
@cindex 仮想コントローラとエフェクタ

エフェクタを利用することによって、
ユーザは仮想コントローラ(@pxref{Virtual Control Change})の意味を自由に
定義することができます。
例えば、下の例では200番の仮想コントローラをエクスクルーシブメッセージを
用いたマスタボリュームとして定義しています。
@code{msvol_handler} エフェクタは 200 番のコントロールチェンジイベントを
エクスクルーシブメッセージのイベントに置き換える働きがあり、
これによってマスターボリュームを通常のコントローラと
同じように扱うことが可能になります。
例えば最後の行のように、連続コントロールチェンジのコマンドによって
マスタボリュームを連続的に変化させることができます。

@example
defeff(msvol_handler, "", ExpandCtrl) @{
  case(ctrl(200)) @{ 
    excl(#(0x7f,0x7f,0x04,0x01,0x00,val))
    reject        // Delete the original event
  @}
@}

msvol_handler()   // Attach the effector

ctrl(200, 100)    // Set the master volume to 100
E D C 
ctrl_to(200, 0, 15u, 1)   // Decrescendo using master volume
@end example

@noindent
エフェクタフラグの @code{ExpandCtrl} は必要です。これが無いと
連続コントロールチェンジ場合は、コマンドによって指定された点の位置だけに
エクスクルーシブイベントが生成されることになってしまいます。

@c --------------------------------------------------------------------
@node Communication, Reading MIDI files, Effectors, Top
@chapter スレッド間通信
@cindex スレッド間通信

PMMLはメッセージパッシングによるスレッド間通信の機能を持っています。
この機能は、実際の合奏において指揮と演奏者間、或は演奏者どうしで
行われる様々な情報交換を模倣するために利用できます。
例えば、あるスレッドにおいて、同じパターンを繰り返し演奏していて、
別のスレッドからの合図が送られて来たらコーダへ飛ぶというときに、
スレッド間通信は役立ちます。

@menu
* Overview of ITC::             スレッド間通信の概要。
                                メッセージ、通信チャネル、シグナルとは？
* Sending Messages::            メッセージを送る signal コマンド  
* Receiving Messages::          メッセージを受け取る wait コマンド 
* Alternation::                 複数の通信チャネルの監視。メッセージ待ちの
                                間に別の処理をする方法。  
* Destroying Channels::         通信チャネルの破壊方法
@end menu

@node Overview of ITC, Sending Messages, Communication, Communication
@section スレッド間通信の概要
@cindex メッセージ
@cindex 通信チャネル
@cindex シグナル

スレッド間で交換されるデータは @dfn{メッセージ} と呼ばれます。
メッセージの型にはPMMLにおけるすべてのデータ型が使えます。
また、メッセージは空でも構いません。
空のメッセージは @dfn{シグナル} と呼ばれ、
スレッド間の同期を行うために利用されます。
なお、@ref{Wait for Child Threads} で述べられている
子スレッドの実行終了待ちコマンドも簡単なスレッド間同期を
実現しますので、それで機能的に十分であればそちらを使った方が
少ない計算量で済みます。

メッセージは @dfn{通信チャネル} と呼ばれる媒体を介して転送されます。
通信チャネルは無限長のメッセージキューを持ち、従って、送り手が待たされる
ことは一切ありません。
１つの通信チャネルに対して複数のスレッドがメッセージを
送出しても構いません。
通信チャネルは通信チャネル名という名前を持ちます。
通信チャネル名は常にグローバルです。つまり必ずルートスレッドの
識別子辞書に登録されます。

通信はすべてブロードキャスト通信です。
したがって、通信チャネルに送られたメッセージは自分を含むすべての
スレッドに対して届きます。
各スレッドはその届いたメッセージを
必ずしも受け取る必要はありません。
つまり、無視しても構いません。

メッセージの送出は @code{signal} コマンド、
受取は @code{wait} コマンドによって行います。
複数の通信チャネルを継続的に監視し、
もしそのどれかにメッセージが到着していればそれを受け取り、
さもなければ別の処理を行う @code{alt} コマンドも用意されています。
通信チャネルはこれらのコマンドのうち一番最初に実行されたものによって
作成されます。@code{undef} コマンドによって明示的に破壊されない限り、
一度作られた通信チャネルはコンパイルが終了するまで残ります。

@node Sending Messages, Receiving Messages, Overview of ITC, Communication
@section メッセージの送出
@cindex メッセージの送出
@findex signal

@code{signal} コマンドはメッセージをブロードキャストします。

@table @t
@item @r{C:} signal(@var{channel} @r{[}, @var{message}@r{]})
@end table

@var{channel} は通信チャネル名であり、同名の通信チャネルが無いときには
新たな通信チャネルが作成されます。
@var{message} は任意の型の式であり、送出するメッセージの内容を意味します。
@var{message} を省略すると内容が空のメッセージ、
つまりシグナルが送出されます。
送られるメッセージには送出時刻（@code{signal} を実行した
時の @code{t} レジスタの値）を示すタイムスタンプが記録されます。

@code{signal} コマンドがブロックする、つまり @code{signal} コマンド
によって @code{t} レジスタの値が増加することはありません。

@node Receiving Messages, Alternation, Sending Messages, Communication
@section メッセージの受け取り
@cindex メッセージの受け取り
@findex wait

@code{wait} コマンドはメッセージが到着するのを待って受けとります。

@table @t
@item @r{C:} wait(@var{channel} @r{[}, @r{[}@var{scope}@r{]}@var{macro-name}@r{]})
@end table

@var{channel} は通信チャネル名であり、同名の通信チャネルが無いときには
新たな通信チャネルが作成されます。
@var{macro-name} と @var{scope} はメッセージを受けとるための
変数型マクロの名前とその通用範囲指定です。
受け取るメッセージが空（シグナル）の場合、
@var{macro-name} を指定してはいけません。
逆に、空でないメッセージのときに @var{macro-name} を省略することは可能
であり、この場合でもメッセージを受け取られますが、その内容は捨てられます。

@code{wait} コマンドは、通信チャネル @var{channel} にメッセージが
既に到着していれば待たずにそれを受けとりますが、もしまだメッセージが
到着していない場合には到着するのを待って受けとります。
すなわち、@code{wait} コマンド実行後の @code{t} レジスタの値は、
実行前の @code{t} レジスタの値と到着したメッセージのタイムスタンプの
うちの最大値になります。受け取ったメッセージは
次のような代入コマンドを実行した場合と全く同じようにして変数マクロに格納
されます。

@example
@r{[}@var{scope}@r{]}@var{macro-name} = @r{メッセージの内容}
@end example

@code{signal} によってメッセージはブロードキャストされますので、
あるスレッドにおいて @code{wait} によってメッセージを受け取り、
その後に別のスレッドで @code{wait} を実行すると、やはり
同じメッセージを受けとることになります。
しかし、これには例外があります。
@samp{&} を伴わないグルーピングコマンド(@pxref{Grouping})または
@samp{&} を伴わない和音コマンド(@pxref{Chords})によって生成された
子スレッドは、その親スレッドと同一視され、もし子スレッドでメッセージを
受け取っても親スレッドが受け取ったものとみなされます。
下の例２を参照してください。
なお、@samp{&} つきのグルーピングコマンドや和音コマンドの場合は
この例外規定は適用されず、別なスレッドだと見なされます。

修飾子またはエフェクタアクションの中で @code{wait} コマンドを使用することは
できません。

@subsubheading @code{wait} の使用例１

@example
defthread(t1,t2,t3)

t1 @{
  C
  signal($e, "hello") // 通信チャネル $e に "hello" という文字列を送る
  D E
  signal($e)          // 通信チャネル $e にシグナルを送る
  F
@}

t2 @{
  wait($e, msg)
  print(msg)
       @print{} hello
  F                   // このF音はt1スレッドのD音と同時に発音される。
  wait($e)
@}

t3 @{
  G A 
  wait($e, msg)       // この wait は待たずにメッセージを受け取る
  print(msg)
       @print{} hello
  wait($e)
  C                   // このC音はt1スレッドのF音と同時に発音される。
@}
@end example

@subsubheading @code{wait} の使用例２

@example
defthread(t1,t2,t3)

t1 @{
  signal($e, 1)
  signal($e, 2)
@}

t2 @{
  C 
  /* 
   * 下の wait は t2 スレッドとは独立にメッセージを受け取る。
   */
  @{ E wait($e, msg) @}&   // msg は 1 になる
  /* 
   * 下の wait は t2 スレッドがメッセージを受け取ったと見なされる。
   */
  @{ G wait($e, msg) @}    // msg は 1 になる
  /* 
   * 下の wait は既に上の wait によって１つメッセージを受け取られて
   * いるので、２番目のメッセージを受け取る。
   */
  wait($e, msg)          // msg は 2 になる
@}
@end example

@node Alternation, Destroying Channels, Receiving Messages, Communication
@section 複数の通信チャネルの監視
@cindex 複数の通信チャネルの監視
@cindex 選択待機
@cindex 代替
@findex alt

@code{alt} コマンドは、複数の通信チャネルを継続的に監視し、
もしそのどれかにメッセージが到着していればそれを受け取り、
さもなければ別の処理を行います。

@table @t
@item @r{C:} alt @{ @var{guard} @dots{} @}
@end table

@noindent
ここでガード @var{guard} は次の２種類のうちのいずれかです。
１つの @code{alt} は任意個のガードを取ることができます。

@table @t
@item case(@var{channel} @r{[}, @r{[}@var{scope}@r{]}@var{macro-name}@r{]}) @{ @var{command} @dots{} @} 
このガードは通信チャネルガードと呼ばれ、
通信チャネル @var{channel} にメッセージが
到着したときに、@code{wait} コマンドと
全く同じようしてメッセージを受けとり、
さらにコマンド列 @var{command} @dots{} を実行するという働きがあります。
 
@item default @{ @var{command} @dots{} @}
このガードは @code{default} ガードと呼ばれ、
メッセージを受けとれる通信チャネルガードが無いときに
コマンド列 @var{command} @dots{} を実行する働きがあります。
@end table

@code{alt} は以下に述べる処理を無限に繰り返します。
まず、@code{alt} は通信チャネルガードに示されている
各通信チャネルに対して、現時刻（@code{t} レジスタの値）以前の
タイムスタンプを持ったメッセージが到着しているかどうかを調べます。
到着している場合には、そのメッセージを @code{wait} コマンドと
全く同じようにして受けとり、さらに対応するガード中のコマンド列を実行します。
複数の通信チャネルガードに到着している場合には、
その中で最小のタイムスタンプを持っているメッセージが選ばれ、
それに対応するガードが実行されます。
タイムスタンプの値が同じ場合は先に書かれたガードが優先します。
現時刻以前のタイムスタンプを持ったメッセージが到着していない場合は、
@code{default} ガードがあればそのコマンド列を実行し、
無ければメッセージが到着するまで待つか、あるいは既に到着している
メッセージがあるのであれば @code{t} レジスタを
タイムスタンプのうちの最小値まで進めます。

@code{alt} コマンドはそれ自身でループの機能を持っている点に
注意して下さい。
@code{alt} コマンドを終了させるためには、ガード中のコマンド列の
中で @code{break} (@pxref{Break Command})を実行します。
なお、コンパイル処理の最後になっても @code{alt} がメッセージ到着
待ち状態になっている場合には、
警告が発せられるとともに @code{alt} コマンドは強制終了されられます。

@code{default} ガードのコマンド列は、@code{break} を実行する場合を
除き、必ず @code{t} レジスタを前進させるように書いて下さい。
そうでないと、一旦 @code{default} ガード
が実行されると、永久に @code{default} ガードが繰り返されることに
なります。

@code{wait} コマンドの場合と同じように、
@samp{&} を伴わないグルーピングコマンド(@pxref{Grouping})または
@samp{&} を伴わない和音コマンド(@pxref{Chords})によって生成された
子スレッドは、その親スレッドと同一視され、
もし子スレッドが @code{alt} によって
メッセージを受け取っても親スレッドが受け取ったものとみなされます。

修飾子またはエフェクタアクションの中で @code{alt} コマンドを使用することは
できません。

@subsubheading @code{alt} コマンドの使用例

@example
defthread(melody,base)

melody @{
  q G A B A h G q F E
  q E D C _B
  signal(the_end)   // the_end チャネルにシグナルを送る
  w C
@}

base @{
  alt @{ 
    case(the_end) @{
      break       // シグナルが到着したら alt を終了する
    @}
    default @{
      q G2 G3     // シグナルが到着するまで G2 G3 というパターンを
                  // 繰り返し演奏する
    @}
  @}
  w C2
@}
@end example

@node Destroying Channels,  , Alternation, Communication
@section 通信チャネルの破壊
@cindex 通信チャネルの破壊
@findex undef

マクロ定義を取り消すための @code{undef} マクロ指令は、
通信チャネルを破壊し、それに使われているメモリ
を解放する目的にも使用できます。

@table @t
@item @r{MD:} undef(@var{channel})
@end table

@code{undef} によって通信チャネル @var{channel} が破壊できるのは、
その通信チャネルに対して @code{wait} または @code{alt} を実行途中の
スレッドがない時だけに限られます。

メッセージを送信した側のスレッドで @code{undef} を実行することは、
メッセージが受け取られる前に通信チャネルを破壊してしまう可能性があるため、
現実的ではありません。
受信側のスレッドにおいてメッセージの受信が完了した後
で @code{undef} を実行する必要があります。
メッセージを２つ以上のスレッドで受けている場合には、
その受信の順番が不定ですから、@code{undef} によって安全にチャネルを
破壊する方法はありません。

@c --------------------------------------------------------------------
@node Reading MIDI files, Concept Index, Communication, Top
@chapter 標準MIDIファイルの読み込み

PMMLでは、
標準MIDIファイルの内容をイベントバッファに読み込むことができます。
読み込んだイベントは、イベント生成コマンドによって生成されたイベントと
一緒にエフェクタ処理を受け、そして出力MIDIファイルへ書き出されます。
この機能は、標準MIDIファイルの内容に別の内容を追加したり、
エフェクタを利用して標準MIDIファイル中のイベントに修正を施す目的に
利用されます。

@menu
* Load Command::                MIDIファイル全体の読み込み 
* Loadtrk Command::             1つのトラックだけの読み込み 
* Closing MIDI Files::          MIDIファイルのクローズ 
* Get MIDI File Info::          MIDIファイルのトラック数などを得る方法 
@end menu

@node Load Command, Loadtrk Command, Reading MIDI files, Reading MIDI files
@section MIDIファイルの読み込み
@cindex MIDIファイルの読み込み
@findex load

@code{load} コマンドは、１つのMIDIファイルの全トラックを
イベントバッファに読み込みます。

@table @t
@item @r{C:} load(@var{filename}) @r{[}&@r{]}
@end table

@var{filename} は読み込む標準MIDIファイルのファイル名であり、
拡張子が @samp{.mid} の場合にはそれを省略できます。
読み込むファイルの分解能は正であればどんな値でも構いませんが、
分解能が負であるMIDIファイルは読むことができません。

ファイル中の各トラックは、それと同じ番号を持つトラックへ
それぞれ読み込まれます。@code{tk} レジスタの値は参照されません。

イベントバッファに置かれる各イベントの時刻には (@code{t} + @code{dt}) 
の値が加算されます。すなわち、読み込んだ曲の演奏は
(@code{t} + @code{dt}) の時刻から開始されます。

@samp{&} オプションがついていないときは、
ファイル読み込み終了後、@code{t} レジスタにMIDIファイルの
演奏時間（各トラックの演奏時間のうち最も長いもの）
が加算されます。@samp{&} オプションがある場合には @code{t} レジスタは
変化しません。

ファイルから読んだ各イベントがノートオン／オフまたは
キープレッシャーである場合には、ノート番号に @code{tp} レジスタの値が
加算されてからイベントバッファへ格納されます。
従って、@code{tp} レジスタの値が 0 以外ならば、
@code{load} で読まれる曲は移調されることになります。

@code{load} コマンドを実行するときのスレッドにアタッチ
されているエフェクタは、MIDIファイルから読まれたイベントに対しても
有効です。すなわち、@code{load} コマンドはMIDIファイルから読んだイベントを
通過条件が成立しない限りエフェクタのイベントバッファに置きます。

@node Loadtrk Command, Closing MIDI Files, Load Command, Reading MIDI files
@section １つのトラックだけの読み込み
@findex loadtrk

@code{loadtrk} コマンドは、あるMIDIファイル中の１つのトラックだけ
をイベントバッファに読み込むコマンドです。

@table @t
@item loadtrk(@var{filename}, @var{track-num}) @r{[}&@r{]}
@end table

トラック番号 @var{track-num} はMIDIファイル上のトラック番号です。
読み込んだイベントは、すべて @code{tk} レジスタで示されるトラックへ
格納されます。
その他については @code{load} コマンドと同じです。

入力ファイルが、パイプの受信端など破壊的（後戻り不能）なデバイスである
場合、同じファイルに対して複数回の @code{loadtrk} を実行するときは、
トラック番号の小さいものから順番に @code{loadtrk} を実行しなければ
なりません。さもないと、シーク不可能のエラーになってしまいます。

@node Closing MIDI Files, Get MIDI File Info, Loadtrk Command, Reading MIDI files
@section ファイルのクローズ
@cindex MIDIファイルのクローズ
@findex close

@code{close} コマンドはオープンされている標準MIDIファイルをクローズします。

@table @t
@item close(@var{filename})
@end table

@code{loadtrk} コマンド、または @code{ntrk}、@code{format}、@code{resolution}、
各組み込み関数を新しいファイルに対して適用すると
そのファイルがオープンされますが、
後に同じファイルが再度アクセスされたときの処理の手間を軽減するために、
実行後もオープンされたままになります。
@code{close} コマンドはこのようはファイルをクローズするためのものであり、
同時にオープンできるファイル数の制限を越えてファイルをオープンする場合に
必要です(@pxref{Limitations})。
@var{filename} にはオープンされたときと同じファイル名を指定します。

@noindent
注意：@code{load} コマンドは終了時にファイルをクローズしますので、
そのファイル対して @code{close} を実行してはいけません。

@node Get MIDI File Info,  , Closing MIDI Files, Reading MIDI files
@section MIDIファイル情報の取得
@cindex MIDIファイル情報の取得

次の組み込み関数はMIDIファイルに関する情報を取得します。
各コマンドで指定するファイル名において、
拡張子が @samp{.mid} の場合にはそれを省略できます。

@table @t
@item ntrk(@var{filename})
@var{filename} で指定された標準MIDIファイル中に含まれる
トラック数を返します。

@item format(@var{filename})
@var{filename} で指定された標準MIDIファイルの
フォーマットを表す整数(0,1,または2)を返します。

@item resolution(@var{filename})
@var{filename} で指定された標準MIDIファイルの分解能を返します。
@end table

@c --------------------------------------------------------------------
@node Concept Index, Command and Macro Index, Reading MIDI files, Top
@unnumbered 概念索引
@printindex cp

@c --------------------------------------------------------------------
@node Command and Macro Index,  , Concept Index, Top
@unnumbered コマンド、マクロ索引
@printindex fn

@c --------------------------------------------------------------------
@summarycontents
@contents

@bye
